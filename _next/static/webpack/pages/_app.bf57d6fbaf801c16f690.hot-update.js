webpackHotUpdate_N_E("pages/_app",{

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./src/subcomponents/BgParticles/BgParticles.module.css":
/*!************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./src/subcomponents/BgParticles/BgParticles.module.css ***!
  \************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".BgParticles_particlesBg__1QYvC {\n  /* Make video to at least 100% wide and tall */\n  min-width: 100%;\n  min-height: 100%;\n  max-width: 100%;\n  max-height: 100%;\n  /* Setting width & height to auto prevents the browser from stretching or squishing the video */\n  width: auto;\n  height: auto;\n  /* Center the video */\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%,-50%);\n  -o-object-fit: cover;\n     object-fit: cover;\n  overflow: hidden;\n  z-index: -9999;\n  background-color: #111;\n}", "",{"version":3,"sources":["webpack://src/subcomponents/BgParticles/BgParticles.module.css"],"names":[],"mappings":"AAAA;EACI,8CAA8C;EACjD,eAAe;EACf,gBAAgB;EAChB,eAAe;EACf,gBAAgB;EAEhB,+FAA+F;EAC/F,WAAW;EACX,YAAY;EAEZ,qBAAqB;EACrB,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,+BAA+B;EAE/B,oBAAiB;KAAjB,iBAAiB;EACjB,gBAAgB;EAChB,cAAc;EAEd,sBAAsB;AACvB","sourcesContent":[".particlesBg {\r\n    /* Make video to at least 100% wide and tall */\r\n min-width: 100%; \r\n min-height: 100%; \r\n max-width: 100%;\r\n max-height: 100%;\r\n\r\n /* Setting width & height to auto prevents the browser from stretching or squishing the video */\r\n width: auto;\r\n height: auto;\r\n\r\n /* Center the video */\r\n position: absolute;\r\n top: 50%;\r\n left: 50%;\r\n transform: translate(-50%,-50%);\r\n\r\n object-fit: cover;\r\n overflow: hidden; \r\n z-index: -9999;\r\n\r\n background-color: #111;\r\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"particlesBg": "BgParticles_particlesBg__1QYvC"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/isEqual.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEqual.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;


/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/react-particles-js/cjs/particles.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-particles-js/cjs/particles.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){for(var r in t)e[r]=t[r]}(exports,function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=1)}([function(e,t){e.exports=__webpack_require__(/*! react */ "./node_modules/react/index.js")},function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||t.hasOwnProperty(r)||n(t,e,r)},o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.Particles=void 0;var a=o(r(2));t.Particles=a.default,i(r(10),t),i(r(11),t),i(r(12),t),i(r(13),t),i(r(14),t),i(r(15),t),i(r(16),t),i(r(17),t),i(r(18),t),i(r(19),t),i(r(20),t),i(r(21),t),t.default=a.default},function(e,t,r){"use strict";function n(e){return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function i(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function o(e,t,r){return(o="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,r){var n=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=l(e)););return e}(e,t);if(n){var i=Object.getOwnPropertyDescriptor(n,t);return i.get?i.get.call(r):i.value}})(e,t,r||e)}function a(e,t){return(a=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function s(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=l(e);if(t){var i=l(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return u(this,r)}}function u(e,t){return!t||"object"!==n(t)&&"function"!=typeof t?c(e):t}function c(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function l(e){return(l=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var f=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),p=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),d=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.hasOwnProperty.call(e,r)&&f(t,e,r);return p(t,e),t},y=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});var v=d(r(0)),b=r(0),h=y(r(3)),m=r(4),g=r(5),P=r(6),O=r(9),_=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&a(e,t)}(f,e);var t,r,n,u=s(f);function f(e){var t;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),(t=u.call(this,e)).state={canvas:void 0,library:void 0},t.loadCanvas=t.loadCanvas.bind(c(t)),t}return t=f,(r=[{key:"buildParticlesLibrary",value:function(e,t){try{if(void 0===window)return null}catch(e){return null}O.tsParticles.init();var r=new m.Options;r.load(P.defaultParams),r.load(t);var n=new g.Container(e,r);return this.props.particlesRef&&(this.props.particlesRef.current=n),n}},{key:"refresh",value:function(e){var t=this,r=this.state.canvas;r&&(this.destroy(),this.setState({library:this.buildParticlesLibrary(e.id,e.params)},(function(){t.loadCanvas(r)})))}},{key:"destroy",value:function(){this.state.library&&this.state.library.destroy()}},{key:"loadCanvas",value:function(e){var t=this;e&&this.setState({canvas:e},(function(){var r=t.state.library;r&&(r.canvas.loadCanvas(e),r.start())}))}},{key:"shouldComponentUpdate",value:function(e){return!h.default(e,this.props)}},{key:"componentDidUpdate",value:function(){this.refresh(this.props)}},{key:"forceUpdate",value:function(){this.refresh(this.props),o(l(f.prototype),"forceUpdate",this).call(this)}},{key:"componentDidMount",value:function(){this.setState({library:this.buildParticlesLibrary(this.props.id,this.props.params)})}},{key:"componentWillUnmount",value:function(){this.destroy(),this.setState({library:void 0})}},{key:"render",value:function(){var e=this.props,t=e.width,r=e.height,n=e.className,i=e.canvasClassName,o=e.id;return v.createElement("div",{className:n,id:o},v.createElement("canvas",{ref:this.loadCanvas,className:i,style:Object.assign(Object.assign({},this.props.style),{width:t,height:r})}))}}])&&i(t.prototype,r),n&&i(t,n),f}(b.Component);t.default=_,_.defaultProps={width:"100%",height:"100%",params:P.defaultParams,style:{},id:"tsparticles"}},function(e,t){e.exports=__webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Options/Classes/Options */ "./node_modules/tsparticles/dist/Options/Classes/Options.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Core/Container */ "./node_modules/tsparticles/dist/Core/Container.js")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.defaultParams=void 0;var n=r(7),i=r(8);t.defaultParams={particles:{number:{value:40,max:-1,density:{enable:!1,area:1200}},color:{value:"#FFF"},shape:{type:n.ShapeType.circle,polygon:{sides:5},image:{src:"",width:100,height:100}},stroke:{width:0,color:"#000000"},opacity:{value:.5,random:!1,anim:{enable:!0,speed:1,minimumValue:.1,sync:!1}},size:{value:1,random:!1,anim:{enable:!1,speed:40,minimumValue:0,sync:!1}},links:{enable:!0,distance:150,color:"#FFF",opacity:.6,width:1,shadow:{enable:!1,blur:5,color:"lime"}},move:{enable:!0,speed:3,direction:n.MoveDirection.none,random:!1,straight:!1,outMode:n.OutMode.bounce,bounce:!0,attract:{enable:!1,rotateX:3e3,rotateY:3e3}}},interactivity:{detectsOn:n.InteractivityDetect.canvas,events:{onHover:{enable:!1,mode:n.HoverMode.grab},onClick:{enable:!1,mode:n.ClickMode.repulse},resize:!0},modes:{grab:{distance:180,links:{opacity:.35}},bubble:{distance:200,size:80,duration:.4},repulse:{distance:100,duration:5},push:{quantity:4},remove:{quantity:2}}},detectRetina:!0,fpsLimit:999,polygon:{enable:!1,scale:1,type:i.Type.inline,inline:{arrangement:i.InlineArrangement.onePerPoint},draw:{enable:!1,stroke:{width:.5,color:"rgba(255, 255, 255, .1)"}},move:{radius:10,type:i.MoveType.path},url:""}}},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums */ "./node_modules/tsparticles/dist/Enums/index.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Plugins/PolygonMask/PolygonMaskPlugin */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskPlugin.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles */ "./node_modules/tsparticles/dist/index.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/InteractivityDetect */ "./node_modules/tsparticles/dist/Enums/InteractivityDetect.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/MoveDirection */ "./node_modules/tsparticles/dist/Enums/MoveDirection.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/OutMode */ "./node_modules/tsparticles/dist/Enums/OutMode.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/PolygonMaskInlineArrangement */ "./node_modules/tsparticles/dist/Enums/PolygonMaskInlineArrangement.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/PolygonMaskMoveType */ "./node_modules/tsparticles/dist/Enums/PolygonMaskMoveType.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/PolygonMaskType */ "./node_modules/tsparticles/dist/Enums/PolygonMaskType.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/ProcessBubbleType */ "./node_modules/tsparticles/dist/Enums/ProcessBubbleType.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/RotateDirection */ "./node_modules/tsparticles/dist/Enums/RotateDirection.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/ShapeType */ "./node_modules/tsparticles/dist/Enums/ShapeType.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/Modes/ClickMode */ "./node_modules/tsparticles/dist/Enums/Modes/ClickMode.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/Modes/DivMode */ "./node_modules/tsparticles/dist/Enums/Modes/DivMode.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/Modes/HoverMode */ "./node_modules/tsparticles/dist/Enums/Modes/HoverMode.js")}]));

/***/ }),

/***/ "./node_modules/react-particles-js/index.js":
/*!**************************************************!*\
  !*** ./node_modules/react-particles-js/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ReactParticles = __webpack_require__(/*! ./cjs/particles */ "./node_modules/react-particles-js/cjs/particles.js");
for (let key in ReactParticles) {
    ReactParticles.default[key] = ReactParticles[key];
}
module.exports = ReactParticles.default;

/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Canvas.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Canvas.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Canvas = void 0;
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Canvas {
    constructor(container) {
        this.container = container;
        this.size = {
            height: 0,
            width: 0,
        };
        this.context = null;
        this.generatedCanvas = false;
    }
    init() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        this.resize();
        const options = this.container.options;
        const element = this.element;
        if (element) {
            if (options.backgroundMode.enable) {
                this.originalStyle = Utils_1.Utils.deepExtend({}, element.style);
                element.style.position = "fixed";
                element.style.zIndex = options.backgroundMode.zIndex.toString(10);
                element.style.top = "0";
                element.style.left = "0";
                element.style.width = "100%";
                element.style.height = "100%";
            }
            else {
                element.style.position = (_b = (_a = this.originalStyle) === null || _a === void 0 ? void 0 : _a.position) !== null && _b !== void 0 ? _b : "";
                element.style.zIndex = (_d = (_c = this.originalStyle) === null || _c === void 0 ? void 0 : _c.zIndex) !== null && _d !== void 0 ? _d : "";
                element.style.top = (_f = (_e = this.originalStyle) === null || _e === void 0 ? void 0 : _e.top) !== null && _f !== void 0 ? _f : "";
                element.style.left = (_h = (_g = this.originalStyle) === null || _g === void 0 ? void 0 : _g.left) !== null && _h !== void 0 ? _h : "";
                element.style.width = (_k = (_j = this.originalStyle) === null || _j === void 0 ? void 0 : _j.width) !== null && _k !== void 0 ? _k : "";
                element.style.height = (_m = (_l = this.originalStyle) === null || _l === void 0 ? void 0 : _l.height) !== null && _m !== void 0 ? _m : "";
            }
        }
        const cover = options.backgroundMask.cover;
        const color = cover.color;
        const trail = options.particles.move.trail;
        const coverRgb = Utils_1.ColorUtils.colorToRgb(color);
        this.coverColor =
            coverRgb !== undefined
                ? {
                    r: coverRgb.r,
                    g: coverRgb.g,
                    b: coverRgb.b,
                    a: cover.opacity,
                }
                : undefined;
        this.trailFillColor = Utils_1.ColorUtils.colorToRgb(trail.fillColor);
        this.initBackground();
        this.paint();
    }
    loadCanvas(canvas, generatedCanvas) {
        var _a;
        if (!canvas.className) {
            canvas.className = Utils_1.Constants.canvasClass;
        }
        if (this.generatedCanvas) {
            (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
        }
        this.generatedCanvas = generatedCanvas !== null && generatedCanvas !== void 0 ? generatedCanvas : this.generatedCanvas;
        this.element = canvas;
        this.originalStyle = Utils_1.Utils.deepExtend({}, this.element.style);
        this.size.height = canvas.offsetHeight;
        this.size.width = canvas.offsetWidth;
        this.context = this.element.getContext("2d");
        this.container.retina.init();
        this.initBackground();
    }
    destroy() {
        var _a;
        if (this.generatedCanvas) {
            (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
        }
        if (this.context) {
            Utils_1.CanvasUtils.clear(this.context, this.size);
        }
    }
    resize() {
        if (!this.element) {
            return;
        }
        this.element.width = this.size.width;
        this.element.height = this.size.height;
    }
    paint() {
        const options = this.container.options;
        if (!this.context) {
            return;
        }
        if (options.backgroundMask.enable && options.backgroundMask.cover && this.coverColor) {
            Utils_1.CanvasUtils.clear(this.context, this.size);
            this.paintBase(Utils_1.ColorUtils.getStyleFromRgb(this.coverColor, this.coverColor.a));
        }
        else {
            this.paintBase();
        }
    }
    clear() {
        const options = this.container.options;
        const trail = options.particles.move.trail;
        if (options.backgroundMask.enable) {
            this.paint();
        }
        else if (trail.enable && trail.length > 0 && this.trailFillColor) {
            this.paintBase(Utils_1.ColorUtils.getStyleFromRgb(this.trailFillColor, 1 / trail.length));
        }
        else if (this.context) {
            Utils_1.CanvasUtils.clear(this.context, this.size);
        }
    }
    windowResize() {
        if (!this.element) {
            return;
        }
        const container = this.container;
        container.canvas.initSize();
        container.particles.setDensity();
        for (const [, plugin] of container.plugins) {
            if (plugin.resize !== undefined) {
                plugin.resize();
            }
        }
    }
    initSize() {
        if (!this.element) {
            return;
        }
        const container = this.container;
        const pxRatio = container.retina.pixelRatio;
        container.canvas.size.width = this.element.offsetWidth * pxRatio;
        container.canvas.size.height = this.element.offsetHeight * pxRatio;
        this.element.width = container.canvas.size.width;
        this.element.height = container.canvas.size.height;
    }
    drawConnectLine(p1, p2) {
        var _a;
        const lineStyle = this.lineStyle(p1, p2);
        if (!lineStyle) {
            return;
        }
        const ctx = this.context;
        if (!ctx) {
            return;
        }
        const pos1 = p1.getPosition();
        const pos2 = p2.getPosition();
        Utils_1.CanvasUtils.drawConnectLine(ctx, (_a = p1.linksWidth) !== null && _a !== void 0 ? _a : this.container.retina.linksWidth, lineStyle, pos1, pos2);
    }
    drawGrabLine(particle, lineColor, opacity, mousePos) {
        var _a;
        const container = this.container;
        const ctx = container.canvas.context;
        if (!ctx) {
            return;
        }
        const beginPos = particle.getPosition();
        Utils_1.CanvasUtils.drawGrabLine(ctx, (_a = particle.linksWidth) !== null && _a !== void 0 ? _a : container.retina.linksWidth, beginPos, mousePos, lineColor, opacity);
    }
    drawParticleShadow(particle, mousePos) {
        if (!this.context) {
            return;
        }
        Utils_1.CanvasUtils.drawParticleShadow(this.container, this.context, particle, mousePos);
    }
    drawLinkTriangle(p1, link1, link2) {
        var _a;
        const container = this.container;
        const options = container.options;
        const p2 = link1.destination;
        const p3 = link2.destination;
        const triangleOptions = p1.particlesOptions.links.triangles;
        const opacityTriangle = (_a = triangleOptions.opacity) !== null && _a !== void 0 ? _a : (link1.opacity + link2.opacity) / 2;
        if (opacityTriangle <= 0) {
            return;
        }
        const pos1 = p1.getPosition();
        const pos2 = p2.getPosition();
        const pos3 = p3.getPosition();
        const ctx = this.context;
        if (!ctx) {
            return;
        }
        if (Utils_1.NumberUtils.getDistance(pos1, pos2) > container.retina.linksDistance ||
            Utils_1.NumberUtils.getDistance(pos3, pos2) > container.retina.linksDistance ||
            Utils_1.NumberUtils.getDistance(pos3, pos1) > container.retina.linksDistance) {
            return;
        }
        let colorTriangle = Utils_1.ColorUtils.colorToRgb(triangleOptions.color);
        if (!colorTriangle) {
            const linksOptions = p1.particlesOptions.links;
            const linkColor = linksOptions.id !== undefined
                ? container.particles.linksColors.get(linksOptions.id)
                : container.particles.linksColor;
            colorTriangle = Utils_1.ColorUtils.getLinkColor(p1, p2, linkColor);
        }
        if (!colorTriangle) {
            return;
        }
        Utils_1.CanvasUtils.drawLinkTriangle(ctx, pos1, pos2, pos3, options.backgroundMask.enable, options.backgroundMask.composite, colorTriangle, opacityTriangle);
    }
    drawLinkLine(p1, link) {
        var _a, _b;
        const container = this.container;
        const options = container.options;
        const p2 = link.destination;
        let opacity = link.opacity;
        const pos1 = p1.getPosition();
        const pos2 = p2.getPosition();
        const ctx = this.context;
        if (!ctx) {
            return;
        }
        let colorLine;
        const twinkle = p1.particlesOptions.twinkle.lines;
        if (twinkle.enable) {
            const twinkleFreq = twinkle.frequency;
            const twinkleRgb = Utils_1.ColorUtils.colorToRgb(twinkle.color);
            const twinkling = Math.random() < twinkleFreq;
            if (twinkling && twinkleRgb !== undefined) {
                colorLine = twinkleRgb;
                opacity = twinkle.opacity;
            }
        }
        if (!colorLine) {
            const linksOptions = p1.particlesOptions.links;
            const linkColor = linksOptions.id !== undefined
                ? container.particles.linksColors.get(linksOptions.id)
                : container.particles.linksColor;
            colorLine = Utils_1.ColorUtils.getLinkColor(p1, p2, linkColor);
        }
        if (!colorLine) {
            return;
        }
        const width = (_a = p1.linksWidth) !== null && _a !== void 0 ? _a : container.retina.linksWidth;
        const maxDistance = (_b = p1.linksDistance) !== null && _b !== void 0 ? _b : container.retina.linksDistance;
        Utils_1.CanvasUtils.drawLinkLine(ctx, width, pos1, pos2, maxDistance, container.canvas.size, p1.particlesOptions.links.warp, options.backgroundMask.enable, options.backgroundMask.composite, colorLine, opacity, p1.particlesOptions.links.shadow);
    }
    drawParticle(particle, delta) {
        var _a, _b, _c, _d;
        if (((_a = particle.image) === null || _a === void 0 ? void 0 : _a.loaded) === false || particle.spawning || particle.destroyed) {
            return;
        }
        const pfColor = particle.getFillColor();
        const psColor = (_b = particle.getStrokeColor()) !== null && _b !== void 0 ? _b : pfColor;
        if (!pfColor && !psColor) {
            return;
        }
        const options = this.container.options;
        const pOptions = particle.particlesOptions;
        const twinkle = pOptions.twinkle.particles;
        const twinkleFreq = twinkle.frequency;
        const twinkleRgb = Utils_1.ColorUtils.colorToRgb(twinkle.color);
        const twinkling = twinkle.enable && Math.random() < twinkleFreq;
        const radius = particle.getRadius();
        const opacity = twinkling ? twinkle.opacity : (_c = particle.bubble.opacity) !== null && _c !== void 0 ? _c : particle.opacity.value;
        const infectionStage = particle.infecter.infectionStage;
        const infection = options.infection;
        const infectionStages = infection.stages;
        const infectionColor = infectionStage !== undefined ? infectionStages[infectionStage].color : undefined;
        const infectionRgb = Utils_1.ColorUtils.colorToRgb(infectionColor);
        const fColor = twinkling && twinkleRgb !== undefined
            ? twinkleRgb
            : infectionRgb !== null && infectionRgb !== void 0 ? infectionRgb : (pfColor ? Utils_1.ColorUtils.hslToRgb(pfColor) : undefined);
        const sColor = twinkling && twinkleRgb !== undefined
            ? twinkleRgb
            : infectionRgb !== null && infectionRgb !== void 0 ? infectionRgb : (psColor ? Utils_1.ColorUtils.hslToRgb(psColor) : undefined);
        const fillColorValue = fColor !== undefined ? Utils_1.ColorUtils.getStyleFromRgb(fColor, opacity) : undefined;
        if (!this.context || (!fillColorValue && !sColor)) {
            return;
        }
        const strokeColorValue = sColor !== undefined
            ? Utils_1.ColorUtils.getStyleFromRgb(sColor, (_d = particle.stroke.opacity) !== null && _d !== void 0 ? _d : opacity)
            : fillColorValue;
        this.drawParticleLinks(particle);
        if (radius > 0) {
            Utils_1.CanvasUtils.drawParticle(this.container, this.context, particle, delta, fillColorValue, strokeColorValue, options.backgroundMask.enable, options.backgroundMask.composite, radius, opacity, particle.particlesOptions.shadow);
        }
    }
    drawParticleLinks(particle) {
        if (!this.context) {
            return;
        }
        const container = this.container;
        const particles = container.particles;
        const pOptions = particle.particlesOptions;
        if (particle.links.length > 0) {
            this.context.save();
            const p1Links = particle.links.filter((l) => {
                const linkFreq = container.particles.getLinkFrequency(particle, l.destination);
                return linkFreq <= pOptions.links.frequency;
            });
            for (const link of p1Links) {
                const p2 = link.destination;
                if (pOptions.links.triangles.enable) {
                    const links = p1Links.map((l) => l.destination);
                    const vertices = p2.links.filter((t) => {
                        const linkFreq = container.particles.getLinkFrequency(p2, t.destination);
                        return linkFreq <= p2.particlesOptions.links.frequency && links.indexOf(t.destination) >= 0;
                    });
                    if (vertices.length) {
                        for (const vertex of vertices) {
                            const p3 = vertex.destination;
                            const triangleFreq = particles.getTriangleFrequency(particle, p2, p3);
                            if (triangleFreq > pOptions.links.triangles.frequency) {
                                continue;
                            }
                            this.drawLinkTriangle(particle, link, vertex);
                        }
                    }
                }
                if (link.opacity > 0 && container.retina.linksWidth > 0) {
                    this.drawLinkLine(particle, link);
                }
            }
            this.context.restore();
        }
    }
    drawPlugin(plugin, delta) {
        if (!this.context) {
            return;
        }
        Utils_1.CanvasUtils.drawPlugin(this.context, plugin, delta);
    }
    drawLight(mousePos) {
        if (!this.context) {
            return;
        }
        Utils_1.CanvasUtils.drawLight(this.container, this.context, mousePos);
    }
    paintBase(baseColor) {
        if (!this.context) {
            return;
        }
        Utils_1.CanvasUtils.paintBase(this.context, this.size, baseColor);
    }
    lineStyle(p1, p2) {
        const options = this.container.options;
        const connectOptions = options.interactivity.modes.connect;
        if (this.context) {
            return Utils_1.CanvasUtils.gradient(this.context, p1, p2, connectOptions.links.opacity);
        }
    }
    initBackground() {
        const options = this.container.options;
        const background = options.background;
        const element = this.element;
        if (!element) {
            return;
        }
        const elementStyle = element.style;
        if (background.color) {
            const color = Utils_1.ColorUtils.colorToRgb(background.color);
            if (color) {
                elementStyle.backgroundColor = Utils_1.ColorUtils.getStyleFromRgb(color, background.opacity);
            }
        }
        if (background.image) {
            elementStyle.backgroundImage = background.image;
        }
        if (background.position) {
            elementStyle.backgroundPosition = background.position;
        }
        if (background.repeat) {
            elementStyle.backgroundRepeat = background.repeat;
        }
        if (background.size) {
            elementStyle.backgroundSize = background.size;
        }
    }
}
exports.Canvas = Canvas;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Container.js":
/*!*********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Container.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const Canvas_1 = __webpack_require__(/*! ./Canvas */ "./node_modules/tsparticles/dist/Core/Canvas.js");
const Particles_1 = __webpack_require__(/*! ./Particles */ "./node_modules/tsparticles/dist/Core/Particles.js");
const Retina_1 = __webpack_require__(/*! ./Retina */ "./node_modules/tsparticles/dist/Core/Retina.js");
const FrameManager_1 = __webpack_require__(/*! ./FrameManager */ "./node_modules/tsparticles/dist/Core/FrameManager.js");
const Options_1 = __webpack_require__(/*! ../Options/Classes/Options */ "./node_modules/tsparticles/dist/Options/Classes/Options.js");
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Container {
    constructor(id, sourceOptions, ...presets) {
        this.id = id;
        this.sourceOptions = sourceOptions;
        this.firstStart = true;
        this.started = false;
        this.destroyed = false;
        this.paused = true;
        this.lastFrameTime = 0;
        this.pageHidden = false;
        this.retina = new Retina_1.Retina(this);
        this.canvas = new Canvas_1.Canvas(this);
        this.particles = new Particles_1.Particles(this);
        this.drawer = new FrameManager_1.FrameManager(this);
        this.noise = {
            generate: () => {
                return {
                    angle: Math.random() * Math.PI * 2,
                    length: Math.random(),
                };
            },
            init: () => {
            },
            update: () => {
            },
        };
        this.interactivity = {
            mouse: {
                clicking: false,
                inside: false,
            },
        };
        this.bubble = {};
        this.repulse = { particles: [] };
        this.attract = { particles: [] };
        this.plugins = new Map();
        this.drawers = new Map();
        this.density = 1;
        this.options = new Options_1.Options();
        for (const preset of presets) {
            this.options.load(Utils_1.Plugins.getPreset(preset));
        }
        const shapes = Utils_1.Plugins.getSupportedShapes();
        for (const type of shapes) {
            const drawer = Utils_1.Plugins.getShapeDrawer(type);
            if (drawer) {
                this.drawers.set(type, drawer);
            }
        }
        if (this.sourceOptions) {
            this.options.load(this.sourceOptions);
        }
        this.fpsLimit = this.options.fpsLimit > 0 ? this.options.fpsLimit : 60;
        this.options.setTheme(undefined);
        this.eventListeners = new Utils_1.EventListeners(this);
        if (typeof IntersectionObserver !== "undefined" && IntersectionObserver) {
            this.intersectionObserver = new IntersectionObserver((entries) => this.intersectionManager(entries));
        }
    }
    play(force) {
        const needsUpdate = this.paused || force;
        if (this.firstStart && !this.options.autoPlay) {
            this.firstStart = false;
            return;
        }
        if (this.paused) {
            this.paused = false;
        }
        if (needsUpdate) {
            for (const [, plugin] of this.plugins) {
                if (plugin.play) {
                    plugin.play();
                }
            }
            this.lastFrameTime = performance.now();
        }
        this.draw();
    }
    pause() {
        if (this.drawAnimationFrame !== undefined) {
            Utils_1.Utils.cancelAnimation(this.drawAnimationFrame);
            delete this.drawAnimationFrame;
        }
        if (this.paused) {
            return;
        }
        for (const [, plugin] of this.plugins) {
            if (plugin.pause) {
                plugin.pause();
            }
        }
        if (!this.pageHidden) {
            this.paused = true;
        }
    }
    draw() {
        this.drawAnimationFrame = Utils_1.Utils.animate((timestamp) => this.drawer.nextFrame(timestamp));
    }
    getAnimationStatus() {
        return !this.paused;
    }
    setNoise(noiseOrGenerator, init, update) {
        if (!noiseOrGenerator) {
            return;
        }
        if (typeof noiseOrGenerator === "function") {
            this.noise.generate = noiseOrGenerator;
            if (init) {
                this.noise.init = init;
            }
            if (update) {
                this.noise.update = update;
            }
        }
        else {
            if (noiseOrGenerator.generate) {
                this.noise.generate = noiseOrGenerator.generate;
            }
            if (noiseOrGenerator.init) {
                this.noise.init = noiseOrGenerator.init;
            }
            if (noiseOrGenerator.update) {
                this.noise.update = noiseOrGenerator.update;
            }
        }
    }
    destroy() {
        this.stop();
        this.canvas.destroy();
        for (const [, drawer] of this.drawers) {
            if (drawer.destroy) {
                drawer.destroy(this);
            }
        }
        for (const key of this.drawers.keys()) {
            this.drawers.delete(key);
        }
        this.destroyed = true;
    }
    exportImg(callback) {
        this.exportImage(callback);
    }
    exportImage(callback, type, quality) {
        var _a;
        return (_a = this.canvas.element) === null || _a === void 0 ? void 0 : _a.toBlob(callback, type !== null && type !== void 0 ? type : "image/png", quality);
    }
    exportConfiguration() {
        return JSON.stringify(this.options, undefined, 2);
    }
    refresh() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stop();
            yield this.start();
        });
    }
    stop() {
        if (!this.started) {
            return;
        }
        this.firstStart = true;
        this.started = false;
        this.eventListeners.removeListeners();
        this.pause();
        this.particles.clear();
        this.canvas.clear();
        if (this.interactivity.element instanceof HTMLElement && this.intersectionObserver) {
            this.intersectionObserver.observe(this.interactivity.element);
        }
        for (const [, plugin] of this.plugins) {
            if (plugin.stop) {
                plugin.stop();
            }
        }
        for (const key of this.plugins.keys()) {
            this.plugins.delete(key);
        }
        this.particles.linksColors = new Map();
        delete this.particles.grabLineColor;
        delete this.particles.linksColor;
    }
    loadTheme(name) {
        return __awaiter(this, void 0, void 0, function* () {
            this.options.setTheme(name);
            yield this.refresh();
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.started) {
                return;
            }
            yield this.init();
            this.started = true;
            this.eventListeners.addListeners();
            if (this.interactivity.element instanceof HTMLElement && this.intersectionObserver) {
                this.intersectionObserver.observe(this.interactivity.element);
            }
            for (const [, plugin] of this.plugins) {
                if (plugin.startAsync !== undefined) {
                    yield plugin.startAsync();
                }
                else if (plugin.start !== undefined) {
                    plugin.start();
                }
            }
            this.play();
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.retina.init();
            this.canvas.init();
            this.fpsLimit = this.options.fpsLimit > 0 ? this.options.fpsLimit : 60;
            const availablePlugins = Utils_1.Plugins.getAvailablePlugins(this);
            for (const [id, plugin] of availablePlugins) {
                this.plugins.set(id, plugin);
            }
            for (const [, drawer] of this.drawers) {
                if (drawer.init) {
                    yield drawer.init(this);
                }
            }
            for (const [, plugin] of this.plugins) {
                if (plugin.init) {
                    plugin.init(this.options);
                }
                else if (plugin.initAsync !== undefined) {
                    yield plugin.initAsync(this.options);
                }
            }
            this.canvas.initSize();
            this.particles.init();
            this.particles.setDensity();
        });
    }
    intersectionManager(entries) {
        if (!this.options.pauseOnOutsideViewport) {
            return;
        }
        for (const entry of entries) {
            if (entry.target !== this.interactivity.element) {
                continue;
            }
            if (entry.isIntersecting) {
                this.play();
            }
            else {
                this.pause();
            }
        }
    }
}
exports.Container = Container;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/FrameManager.js":
/*!************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/FrameManager.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FrameManager = void 0;
class FrameManager {
    constructor(container) {
        this.container = container;
    }
    nextFrame(timestamp) {
        try {
            const container = this.container;
            if (container.lastFrameTime !== undefined &&
                timestamp < container.lastFrameTime + 1000 / container.fpsLimit) {
                container.draw();
                return;
            }
            const deltaValue = timestamp - container.lastFrameTime;
            const delta = {
                value: deltaValue,
                factor: (60 * deltaValue) / 1000,
            };
            container.lastFrameTime = timestamp;
            container.particles.draw(delta);
            if (container.getAnimationStatus()) {
                container.draw();
            }
        }
        catch (e) {
            console.error("tsParticles error in animation loop", e);
        }
    }
}
exports.FrameManager = FrameManager;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Loader.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Loader.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Loader = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/tsparticles/dist/Core/Container.js");
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const tsParticlesDom = [];
function fetchError(statusCode) {
    console.error(`Error tsParticles - fetch status: ${statusCode}`);
    console.error("Error tsParticles - File config not found");
}
class Loader {
    static dom() {
        return tsParticlesDom;
    }
    static domItem(index) {
        const dom = Loader.dom();
        const item = dom[index];
        if (item && !item.destroyed) {
            return item;
        }
        dom.splice(index, 1);
    }
    static load(tagId, options, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const domContainer = document.getElementById(tagId);
            if (!domContainer) {
                return;
            }
            return Loader.set(tagId, domContainer, options, index);
        });
    }
    static set(id, domContainer, options, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentOptions = options instanceof Array ? Utils_1.Utils.itemFromArray(options, index) : options;
            const dom = Loader.dom();
            const oldIndex = dom.findIndex((v) => v.id === id);
            if (oldIndex >= 0) {
                const old = Loader.domItem(oldIndex);
                if (old && !old.destroyed) {
                    old.destroy();
                    dom.splice(oldIndex, 1);
                }
            }
            let canvasEl;
            let generatedCanvas;
            if (domContainer.tagName.toLowerCase() === "canvas") {
                canvasEl = domContainer;
                generatedCanvas = false;
            }
            else {
                const existingCanvases = domContainer.getElementsByTagName("canvas");
                if (existingCanvases.length) {
                    canvasEl = existingCanvases[0];
                    if (!canvasEl.className) {
                        canvasEl.className = Utils_1.Constants.canvasClass;
                    }
                    generatedCanvas = false;
                }
                else {
                    generatedCanvas = true;
                    canvasEl = document.createElement("canvas");
                    canvasEl.className = Utils_1.Constants.canvasClass;
                    canvasEl.style.width = "100%";
                    canvasEl.style.height = "100%";
                    domContainer.appendChild(canvasEl);
                }
            }
            const newItem = new Container_1.Container(id, currentOptions);
            if (oldIndex >= 0) {
                dom.splice(oldIndex, 0, newItem);
            }
            else {
                dom.push(newItem);
            }
            newItem.canvas.loadCanvas(canvasEl, generatedCanvas);
            yield newItem.start();
            return newItem;
        });
    }
    static loadJSON(tagId, jsonUrl, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = jsonUrl instanceof Array ? Utils_1.Utils.itemFromArray(jsonUrl, index) : jsonUrl;
            const response = yield fetch(url);
            if (response.ok) {
                return Loader.load(tagId, yield response.json());
            }
            else {
                fetchError(response.status);
            }
        });
    }
    static setJSON(id, domContainer, jsonUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(jsonUrl);
            if (response.ok) {
                const options = yield response.json();
                return Loader.set(id, domContainer, options);
            }
            else {
                fetchError(response.status);
            }
        });
    }
    static setOnClickHandler(callback) {
        const dom = Loader.dom();
        if (dom.length === 0) {
            throw new Error("Can only set click handlers after calling tsParticles.load() or tsParticles.loadJSON()");
        }
        for (const domItem of dom) {
            const el = domItem.interactivity.element;
            if (!el) {
                continue;
            }
            const clickOrTouchHandler = (e, pos) => {
                if (domItem.destroyed) {
                    return;
                }
                const pxRatio = domItem.retina.pixelRatio;
                const posRetina = {
                    x: pos.x * pxRatio,
                    y: pos.y * pxRatio,
                };
                const particles = domItem.particles.quadTree.queryCircle(posRetina, domItem.retina.sizeValue);
                callback(e, particles);
            };
            const clickHandler = (e) => {
                if (domItem.destroyed) {
                    return;
                }
                const mouseEvent = e;
                const pos = {
                    x: mouseEvent.offsetX || mouseEvent.clientX,
                    y: mouseEvent.offsetY || mouseEvent.clientY,
                };
                clickOrTouchHandler(e, pos);
            };
            const touchStartHandler = () => {
                if (domItem.destroyed) {
                    return;
                }
                touched = true;
                touchMoved = false;
            };
            const touchMoveHandler = () => {
                if (domItem.destroyed) {
                    return;
                }
                touchMoved = true;
            };
            const touchEndHandler = (e) => {
                var _a, _b, _c;
                if (domItem.destroyed) {
                    return;
                }
                if (touched && !touchMoved) {
                    const touchEvent = e;
                    const lastTouch = touchEvent.touches[touchEvent.touches.length - 1];
                    const canvasRect = (_a = domItem.canvas.element) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
                    const pos = {
                        x: lastTouch.clientX - ((_b = canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.left) !== null && _b !== void 0 ? _b : 0),
                        y: lastTouch.clientY - ((_c = canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.top) !== null && _c !== void 0 ? _c : 0),
                    };
                    clickOrTouchHandler(e, pos);
                }
                touched = false;
                touchMoved = false;
            };
            const touchCancelHandler = () => {
                if (domItem.destroyed) {
                    return;
                }
                touched = false;
                touchMoved = false;
            };
            let touched = false;
            let touchMoved = false;
            el.addEventListener("click", clickHandler);
            el.addEventListener("touchstart", touchStartHandler);
            el.addEventListener("touchmove", touchMoveHandler);
            el.addEventListener("touchend", touchEndHandler);
            el.addEventListener("touchcancel", touchCancelHandler);
        }
    }
}
exports.Loader = Loader;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particle.js":
/*!********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particle.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Particle = void 0;
const Updater_1 = __webpack_require__(/*! ./Particle/Updater */ "./node_modules/tsparticles/dist/Core/Particle/Updater.js");
const Particles_1 = __webpack_require__(/*! ../Options/Classes/Particles/Particles */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Particles.js");
const Shape_1 = __webpack_require__(/*! ../Options/Classes/Particles/Shape/Shape */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Shape/Shape.js");
const Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Infecter_1 = __webpack_require__(/*! ./Particle/Infecter */ "./node_modules/tsparticles/dist/Core/Particle/Infecter.js");
const Mover_1 = __webpack_require__(/*! ./Particle/Mover */ "./node_modules/tsparticles/dist/Core/Particle/Mover.js");
class Particle {
    constructor(id, container, position, overrideOptions) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this.id = id;
        this.container = container;
        this.links = [];
        this.fill = true;
        this.close = true;
        this.lastNoiseTime = 0;
        this.destroyed = false;
        this.misplaced = false;
        const pxRatio = container.retina.pixelRatio;
        const options = container.options;
        const particlesOptions = new Particles_1.Particles();
        particlesOptions.load(options.particles);
        const shapeType = particlesOptions.shape.type;
        const reduceDuplicates = particlesOptions.reduceDuplicates;
        this.shape = shapeType instanceof Array ? Utils_1.Utils.itemFromArray(shapeType, this.id, reduceDuplicates) : shapeType;
        if (overrideOptions === null || overrideOptions === void 0 ? void 0 : overrideOptions.shape) {
            if (overrideOptions.shape.type) {
                const overrideShapeType = overrideOptions.shape.type;
                this.shape =
                    overrideShapeType instanceof Array
                        ? Utils_1.Utils.itemFromArray(overrideShapeType, this.id, reduceDuplicates)
                        : overrideShapeType;
            }
            const shapeOptions = new Shape_1.Shape();
            shapeOptions.load(overrideOptions.shape);
            if (this.shape) {
                const shapeData = shapeOptions.options[this.shape];
                if (shapeData) {
                    this.shapeData = Utils_1.Utils.deepExtend({}, shapeData instanceof Array
                        ? Utils_1.Utils.itemFromArray(shapeData, this.id, reduceDuplicates)
                        : shapeData);
                }
            }
        }
        else {
            const shapeData = particlesOptions.shape.options[this.shape];
            if (shapeData) {
                this.shapeData = Utils_1.Utils.deepExtend({}, shapeData instanceof Array ? Utils_1.Utils.itemFromArray(shapeData, this.id, reduceDuplicates) : shapeData);
            }
        }
        if (overrideOptions !== undefined) {
            particlesOptions.load(overrideOptions);
        }
        if (((_a = this.shapeData) === null || _a === void 0 ? void 0 : _a.particles) !== undefined) {
            particlesOptions.load((_b = this.shapeData) === null || _b === void 0 ? void 0 : _b.particles);
        }
        this.fill = (_d = (_c = this.shapeData) === null || _c === void 0 ? void 0 : _c.fill) !== null && _d !== void 0 ? _d : this.fill;
        this.close = (_f = (_e = this.shapeData) === null || _e === void 0 ? void 0 : _e.close) !== null && _f !== void 0 ? _f : this.close;
        this.particlesOptions = particlesOptions;
        this.noiseDelay = Utils_1.NumberUtils.getValue(this.particlesOptions.move.noise.delay) * 1000;
        container.retina.initParticle(this);
        const color = this.particlesOptions.color;
        const sizeOptions = this.particlesOptions.size;
        const sizeValue = Utils_1.NumberUtils.getValue(sizeOptions) * container.retina.pixelRatio;
        const randomSize = typeof sizeOptions.random === "boolean" ? sizeOptions.random : sizeOptions.random.enable;
        this.size = {
            value: sizeValue,
        };
        this.direction = this.particlesOptions.move.direction;
        this.bubble = {
            inRange: false,
        };
        this.initialVelocity = this.calculateVelocity();
        this.velocity = {
            horizontal: this.initialVelocity.horizontal,
            vertical: this.initialVelocity.vertical,
        };
        this.pathAngle = Math.atan2(this.initialVelocity.vertical, this.initialVelocity.horizontal);
        const rotateOptions = this.particlesOptions.rotate;
        this.rotate = {
            value: ((rotateOptions.random.enable ? Math.random() * 360 : rotateOptions.value) * Math.PI) / 180,
        };
        let rotateDirection = rotateOptions.direction;
        if (rotateDirection === Enums_1.RotateDirection.random) {
            const index = Math.floor(Math.random() * 2);
            rotateDirection = index > 0 ? Enums_1.RotateDirection.counterClockwise : Enums_1.RotateDirection.clockwise;
        }
        switch (rotateDirection) {
            case Enums_1.RotateDirection.counterClockwise:
            case "counterClockwise":
                this.rotate.status = Enums_1.AnimationStatus.decreasing;
                break;
            case Enums_1.RotateDirection.clockwise:
                this.rotate.status = Enums_1.AnimationStatus.increasing;
                break;
        }
        const rotateAnimation = this.particlesOptions.rotate.animation;
        if (rotateAnimation.enable) {
            this.rotate.velocity = (rotateAnimation.speed / 360) * container.retina.reduceFactor;
            if (!rotateAnimation.sync) {
                this.rotate.velocity *= Math.random();
            }
        }
        const sizeAnimation = this.particlesOptions.size.animation;
        if (sizeAnimation.enable) {
            this.size.status = Enums_1.AnimationStatus.increasing;
            if (!randomSize) {
                switch (sizeAnimation.startValue) {
                    case Enums_1.StartValueType.min:
                        this.size.value = sizeAnimation.minimumValue * pxRatio;
                        break;
                    case Enums_1.StartValueType.random:
                        this.size.value = Utils_1.NumberUtils.randomInRange(sizeAnimation.minimumValue * pxRatio, this.size.value);
                        break;
                    case Enums_1.StartValueType.max:
                    default:
                        this.size.status = Enums_1.AnimationStatus.decreasing;
                        break;
                }
            }
            this.size.velocity =
                (((_g = this.sizeAnimationSpeed) !== null && _g !== void 0 ? _g : container.retina.sizeAnimationSpeed) / 100) *
                    container.retina.reduceFactor;
            if (!sizeAnimation.sync) {
                this.size.velocity *= Math.random();
            }
        }
        this.color = {
            value: Utils_1.ColorUtils.colorToHsl(color, this.id, reduceDuplicates),
        };
        const colorAnimation = this.particlesOptions.color.animation;
        if (colorAnimation.enable) {
            this.color.velocity = (colorAnimation.speed / 100) * container.retina.reduceFactor;
            if (!colorAnimation.sync) {
                this.color.velocity *= Math.random();
            }
        }
        this.position = this.calcPosition(this.container, position);
        this.initialPosition = {
            x: this.position.x,
            y: this.position.y,
        };
        this.offset = {
            x: 0,
            y: 0,
        };
        const opacityOptions = this.particlesOptions.opacity;
        const randomOpacity = typeof opacityOptions.random === "boolean" ? opacityOptions.random : opacityOptions.random.enable;
        this.opacity = {
            value: Utils_1.NumberUtils.getValue(opacityOptions),
        };
        const opacityAnimation = opacityOptions.animation;
        if (opacityAnimation.enable) {
            this.opacity.status = Enums_1.AnimationStatus.increasing;
            if (!randomOpacity) {
                switch (opacityAnimation.startValue) {
                    case Enums_1.StartValueType.min:
                        this.opacity.value = opacityAnimation.minimumValue;
                        break;
                    case Enums_1.StartValueType.random:
                        this.opacity.value = Utils_1.NumberUtils.randomInRange(opacityAnimation.minimumValue, this.opacity.value);
                        break;
                    case Enums_1.StartValueType.max:
                    default:
                        this.opacity.status = Enums_1.AnimationStatus.decreasing;
                        break;
                }
            }
            this.opacity.velocity = (opacityAnimation.speed / 100) * container.retina.reduceFactor;
            if (!opacityAnimation.sync) {
                this.opacity.velocity *= Math.random();
            }
        }
        this.sides = 24;
        let drawer = container.drawers.get(this.shape);
        if (!drawer) {
            drawer = Utils_1.Plugins.getShapeDrawer(this.shape);
            if (drawer) {
                container.drawers.set(this.shape, drawer);
            }
        }
        const sideCountFunc = drawer === null || drawer === void 0 ? void 0 : drawer.getSidesCount;
        if (sideCountFunc) {
            this.sides = sideCountFunc(this);
        }
        const imageShape = this.loadImageShape(container, drawer);
        if (imageShape) {
            this.image = imageShape.image;
            this.fill = imageShape.fill;
            this.close = imageShape.close;
        }
        this.stroke =
            this.particlesOptions.stroke instanceof Array
                ? Utils_1.Utils.itemFromArray(this.particlesOptions.stroke, this.id, reduceDuplicates)
                : this.particlesOptions.stroke;
        this.strokeWidth = this.stroke.width * container.retina.pixelRatio;
        this.strokeColor = {
            value: (_h = Utils_1.ColorUtils.colorToHsl(this.stroke.color)) !== null && _h !== void 0 ? _h : this.color.value,
        };
        if (typeof this.stroke.color !== "string") {
            const strokeColorAnimation = (_j = this.stroke.color) === null || _j === void 0 ? void 0 : _j.animation;
            if (strokeColorAnimation && this.strokeColor) {
                if (strokeColorAnimation.enable) {
                    this.strokeColor.velocity = (strokeColorAnimation.speed / 100) * container.retina.reduceFactor;
                    if (!strokeColorAnimation.sync) {
                        this.strokeColor.velocity = this.strokeColor.velocity * Math.random();
                    }
                }
                else {
                    this.strokeColor.velocity = 0;
                }
                if (strokeColorAnimation.enable && !strokeColorAnimation.sync && this.strokeColor.value) {
                    this.strokeColor.value.h = Math.random() * 360;
                }
            }
        }
        const lifeOptions = particlesOptions.life;
        this.lifeDelay = container.retina.reduceFactor
            ? ((Utils_1.NumberUtils.getValue(lifeOptions.delay) * (lifeOptions.delay.sync ? 1 : Math.random())) /
                container.retina.reduceFactor) *
                1000
            : 0;
        this.lifeDelayTime = 0;
        this.lifeDuration = container.retina.reduceFactor
            ? ((Utils_1.NumberUtils.getValue(lifeOptions.duration) * (lifeOptions.duration.sync ? 1 : Math.random())) /
                container.retina.reduceFactor) *
                1000
            : 0;
        this.lifeTime = 0;
        this.livesRemaining = particlesOptions.life.count;
        this.spawning = this.lifeDelay > 0;
        if (this.lifeDuration <= 0) {
            this.lifeDuration = -1;
        }
        if (this.livesRemaining <= 0) {
            this.livesRemaining = -1;
        }
        this.shadowColor = Utils_1.ColorUtils.colorToRgb(this.particlesOptions.shadow.color);
        this.updater = new Updater_1.Updater(container, this);
        this.infecter = new Infecter_1.Infecter(container);
        this.mover = new Mover_1.Mover(container, this);
    }
    move(delta) {
        this.mover.move(delta);
    }
    update(delta) {
        this.updater.update(delta);
    }
    draw(delta) {
        this.container.canvas.drawParticle(this, delta);
    }
    getPosition() {
        return {
            x: this.position.x + this.offset.x,
            y: this.position.y + this.offset.y,
        };
    }
    getRadius() {
        return this.bubble.radius || this.size.value;
    }
    getFillColor() {
        var _a;
        return (_a = this.bubble.color) !== null && _a !== void 0 ? _a : this.color.value;
    }
    getStrokeColor() {
        var _a, _b;
        return (_b = (_a = this.bubble.color) !== null && _a !== void 0 ? _a : this.strokeColor.value) !== null && _b !== void 0 ? _b : this.color.value;
    }
    destroy() {
        this.destroyed = true;
        this.bubble.inRange = false;
        this.links = [];
    }
    calcPosition(container, position) {
        var _a, _b;
        for (const [, plugin] of container.plugins) {
            const pluginPos = plugin.particlePosition !== undefined ? plugin.particlePosition(position, this) : undefined;
            if (pluginPos !== undefined) {
                return Utils_1.Utils.deepExtend({}, pluginPos);
            }
        }
        const pos = {
            x: (_a = position === null || position === void 0 ? void 0 : position.x) !== null && _a !== void 0 ? _a : Math.random() * container.canvas.size.width,
            y: (_b = position === null || position === void 0 ? void 0 : position.y) !== null && _b !== void 0 ? _b : Math.random() * container.canvas.size.height,
        };
        const outMode = this.particlesOptions.move.outMode;
        if (Utils_1.Utils.isInArray(outMode, Enums_1.OutMode.bounce) || Utils_1.Utils.isInArray(outMode, Enums_1.OutMode.bounceHorizontal)) {
            if (pos.x > container.canvas.size.width - this.size.value * 2) {
                pos.x -= this.size.value;
            }
            else if (pos.x < this.size.value * 2) {
                pos.x += this.size.value;
            }
        }
        if (Utils_1.Utils.isInArray(outMode, Enums_1.OutMode.bounce) || Utils_1.Utils.isInArray(outMode, Enums_1.OutMode.bounceVertical)) {
            if (pos.y > container.canvas.size.height - this.size.value * 2) {
                pos.y -= this.size.value;
            }
            else if (pos.y < this.size.value * 2) {
                pos.y += this.size.value;
            }
        }
        return pos;
    }
    calculateVelocity() {
        const baseVelocity = Utils_1.NumberUtils.getParticleBaseVelocity(this);
        const res = {
            horizontal: 0,
            vertical: 0,
        };
        const moveOptions = this.particlesOptions.move;
        let rad;
        let radOffset = Math.PI / 4;
        if (typeof moveOptions.angle === "number") {
            rad = (Math.PI / 180) * moveOptions.angle;
        }
        else {
            rad = (Math.PI / 180) * moveOptions.angle.value;
            radOffset = (Math.PI / 180) * moveOptions.angle.offset;
        }
        const range = {
            left: Math.sin(radOffset + rad / 2) - Math.sin(radOffset - rad / 2),
            right: Math.cos(radOffset + rad / 2) - Math.cos(radOffset - rad / 2),
        };
        if (moveOptions.straight) {
            res.horizontal = baseVelocity.x;
            res.vertical = baseVelocity.y;
            if (moveOptions.random) {
                res.horizontal += Utils_1.NumberUtils.randomInRange(range.left, range.right) / 2;
                res.vertical += Utils_1.NumberUtils.randomInRange(range.left, range.right) / 2;
            }
        }
        else {
            res.horizontal = baseVelocity.x + Utils_1.NumberUtils.randomInRange(range.left, range.right) / 2;
            res.vertical = baseVelocity.y + Utils_1.NumberUtils.randomInRange(range.left, range.right) / 2;
        }
        return res;
    }
    loadImageShape(container, drawer) {
        var _a, _b, _c, _d, _e;
        if (!(this.shape === Enums_1.ShapeType.image || this.shape === Enums_1.ShapeType.images)) {
            return;
        }
        const imageDrawer = drawer;
        const images = imageDrawer.getImages(container).images;
        const imageData = this.shapeData;
        const image = (_a = images.find((t) => t.source === imageData.src)) !== null && _a !== void 0 ? _a : images[0];
        const color = this.getFillColor();
        let imageRes;
        if (!image) {
            return;
        }
        if (image.svgData !== undefined && imageData.replaceColor && color) {
            const svgColoredData = Utils_1.ColorUtils.replaceColorSvg(image, color, this.opacity.value);
            const svg = new Blob([svgColoredData], { type: "image/svg+xml" });
            const domUrl = URL || window.URL || window.webkitURL || window;
            const url = domUrl.createObjectURL(svg);
            const img = new Image();
            imageRes = {
                data: image,
                loaded: false,
                ratio: imageData.width / imageData.height,
                replaceColor: (_b = imageData.replaceColor) !== null && _b !== void 0 ? _b : imageData.replace_color,
                source: imageData.src,
            };
            img.addEventListener("load", () => {
                if (this.image) {
                    this.image.loaded = true;
                    image.element = img;
                }
                domUrl.revokeObjectURL(url);
            });
            img.addEventListener("error", () => {
                domUrl.revokeObjectURL(url);
                Utils_1.Utils.loadImage(imageData.src).then((img2) => {
                    if (this.image) {
                        image.element = img2.element;
                        this.image.loaded = true;
                    }
                });
            });
            img.src = url;
        }
        else {
            imageRes = {
                data: image,
                loaded: true,
                ratio: imageData.width / imageData.height,
                replaceColor: (_c = imageData.replaceColor) !== null && _c !== void 0 ? _c : imageData.replace_color,
                source: imageData.src,
            };
        }
        if (!imageRes.ratio) {
            imageRes.ratio = 1;
        }
        const fill = (_d = imageData.fill) !== null && _d !== void 0 ? _d : this.fill;
        const close = (_e = imageData.close) !== null && _e !== void 0 ? _e : this.close;
        return {
            image: imageRes,
            fill,
            close,
        };
    }
}
exports.Particle = Particle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particle/Infecter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particle/Infecter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Infecter = void 0;
class Infecter {
    constructor(container) {
        this.container = container;
    }
    startInfection(stage) {
        const options = this.container.options;
        const stages = options.infection.stages;
        const stagesCount = stages.length;
        if (stage > stagesCount || stage < 0) {
            return;
        }
        this.infectionDelay = 0;
        this.infectionDelayStage = stage;
    }
    updateInfectionStage(stage) {
        const options = this.container.options;
        const stagesCount = options.infection.stages.length;
        if (stage > stagesCount || stage < 0 || (this.infectionStage !== undefined && this.infectionStage > stage)) {
            return;
        }
        this.infectionStage = stage;
        this.infectionTime = 0;
    }
    updateInfection(delta) {
        const options = this.container.options;
        const infection = options.infection;
        const stages = options.infection.stages;
        const stagesCount = stages.length;
        if (this.infectionDelay !== undefined && this.infectionDelayStage !== undefined) {
            const stage = this.infectionDelayStage;
            if (stage > stagesCount || stage < 0) {
                return;
            }
            if (this.infectionDelay > infection.delay * 1000) {
                this.infectionStage = stage;
                this.infectionTime = 0;
                delete this.infectionDelay;
                delete this.infectionDelayStage;
            }
            else {
                this.infectionDelay += delta;
            }
        }
        else {
            delete this.infectionDelay;
            delete this.infectionDelayStage;
        }
        if (this.infectionStage !== undefined && this.infectionTime !== undefined) {
            const infectionStage = stages[this.infectionStage];
            if (infectionStage.duration !== undefined && infectionStage.duration >= 0) {
                if (this.infectionTime > infectionStage.duration * 1000) {
                    this.nextInfectionStage();
                }
                else {
                    this.infectionTime += delta;
                }
            }
            else {
                this.infectionTime += delta;
            }
        }
        else {
            delete this.infectionStage;
            delete this.infectionTime;
        }
    }
    nextInfectionStage() {
        const options = this.container.options;
        const stagesCount = options.infection.stages.length;
        if (stagesCount <= 0 || this.infectionStage === undefined) {
            return;
        }
        this.infectionTime = 0;
        if (stagesCount <= ++this.infectionStage) {
            if (options.infection.cure) {
                delete this.infectionStage;
                delete this.infectionTime;
                return;
            }
            else {
                this.infectionStage = 0;
                this.infectionTime = 0;
            }
        }
    }
}
exports.Infecter = Infecter;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particle/InteractionManager.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particle/InteractionManager.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionManager = void 0;
const Grabber_1 = __webpack_require__(/*! ../../Interactions/External/Grabber */ "./node_modules/tsparticles/dist/Interactions/External/Grabber.js");
const Repulser_1 = __webpack_require__(/*! ../../Interactions/External/Repulser */ "./node_modules/tsparticles/dist/Interactions/External/Repulser.js");
const Bubbler_1 = __webpack_require__(/*! ../../Interactions/External/Bubbler */ "./node_modules/tsparticles/dist/Interactions/External/Bubbler.js");
const Connector_1 = __webpack_require__(/*! ../../Interactions/External/Connector */ "./node_modules/tsparticles/dist/Interactions/External/Connector.js");
const Linker_1 = __webpack_require__(/*! ../../Interactions/Particles/Linker */ "./node_modules/tsparticles/dist/Interactions/Particles/Linker.js");
const Attractor_1 = __webpack_require__(/*! ../../Interactions/Particles/Attractor */ "./node_modules/tsparticles/dist/Interactions/Particles/Attractor.js");
const Collider_1 = __webpack_require__(/*! ../../Interactions/Particles/Collider */ "./node_modules/tsparticles/dist/Interactions/Particles/Collider.js");
const Infecter_1 = __webpack_require__(/*! ../../Interactions/Particles/Infecter */ "./node_modules/tsparticles/dist/Interactions/Particles/Infecter.js");
const TrailMaker_1 = __webpack_require__(/*! ../../Interactions/External/TrailMaker */ "./node_modules/tsparticles/dist/Interactions/External/TrailMaker.js");
const Attractor_2 = __webpack_require__(/*! ../../Interactions/External/Attractor */ "./node_modules/tsparticles/dist/Interactions/External/Attractor.js");
const Lighter_1 = __webpack_require__(/*! ../../Interactions/Particles/Lighter */ "./node_modules/tsparticles/dist/Interactions/Particles/Lighter.js");
const Lighter_2 = __webpack_require__(/*! ../../Interactions/External/Lighter */ "./node_modules/tsparticles/dist/Interactions/External/Lighter.js");
const Bouncer_1 = __webpack_require__(/*! ../../Interactions/External/Bouncer */ "./node_modules/tsparticles/dist/Interactions/External/Bouncer.js");
class InteractionManager {
    constructor(container) {
        this.container = container;
        this.externalInteractors = [
            new Bouncer_1.Bouncer(container),
            new Bubbler_1.Bubbler(container),
            new Connector_1.Connector(container),
            new Grabber_1.Grabber(container),
            new Lighter_2.Lighter(container),
            new Attractor_2.Attractor(container),
            new Repulser_1.Repulser(container),
            new TrailMaker_1.TrailMaker(container),
        ];
        this.particleInteractors = [
            new Attractor_1.Attractor(container),
            new Lighter_1.Lighter(container),
            new Collider_1.Collider(container),
            new Infecter_1.Infecter(container),
            new Linker_1.Linker(container),
        ];
    }
    init() {
    }
    externalInteract(delta) {
        for (const interactor of this.externalInteractors) {
            if (interactor.isEnabled()) {
                interactor.interact(delta);
            }
        }
    }
    particlesInteract(particle, delta) {
        for (const interactor of this.externalInteractors) {
            interactor.reset(particle);
        }
        for (const interactor of this.particleInteractors) {
            if (interactor.isEnabled(particle)) {
                interactor.interact(particle, delta);
            }
        }
    }
}
exports.InteractionManager = InteractionManager;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particle/Mover.js":
/*!**************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particle/Mover.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Mover = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
class Mover {
    constructor(container, particle) {
        this.container = container;
        this.particle = particle;
    }
    move(delta) {
        const particle = this.particle;
        particle.bubble.inRange = false;
        particle.links = [];
        for (const [, plugin] of this.container.plugins) {
            if (particle.destroyed) {
                break;
            }
            if (plugin.particleUpdate) {
                plugin.particleUpdate(particle, delta);
            }
        }
        if (particle.destroyed) {
            return;
        }
        this.moveParticle(delta);
        this.moveParallax();
    }
    moveParticle(delta) {
        var _a, _b;
        const particle = this.particle;
        const particlesOptions = particle.particlesOptions;
        if (!particlesOptions.move.enable) {
            return;
        }
        const container = this.container;
        const slowFactor = this.getProximitySpeedFactor();
        const baseSpeed = ((_a = particle.moveSpeed) !== null && _a !== void 0 ? _a : container.retina.moveSpeed) * container.retina.reduceFactor;
        const maxSize = (_b = particle.sizeValue) !== null && _b !== void 0 ? _b : container.retina.sizeValue;
        const sizeFactor = particlesOptions.move.size ? particle.getRadius() / maxSize : 1;
        const moveSpeed = (baseSpeed / 2) * sizeFactor * slowFactor * delta.factor;
        this.applyNoise(delta);
        const gravityOptions = particlesOptions.move.gravity;
        if (gravityOptions.enable) {
            particle.velocity.vertical += (gravityOptions.acceleration * delta.factor) / (60 * moveSpeed);
        }
        const velocity = {
            horizontal: particle.velocity.horizontal * moveSpeed,
            vertical: particle.velocity.vertical * moveSpeed,
        };
        if (gravityOptions.enable && velocity.vertical >= gravityOptions.maxSpeed && gravityOptions.maxSpeed > 0) {
            velocity.vertical = gravityOptions.maxSpeed;
            particle.velocity.vertical = velocity.vertical / moveSpeed;
        }
        particle.position.x += velocity.horizontal;
        particle.position.y += velocity.vertical;
        if (particlesOptions.move.vibrate) {
            particle.position.x += Math.sin(particle.position.x * Math.cos(particle.position.y));
            particle.position.y += Math.cos(particle.position.y * Math.sin(particle.position.x));
        }
        const initialPosition = particle.initialPosition;
        const initialDistance = Utils_1.NumberUtils.getDistance(initialPosition, particle.position);
        if (particle.maxDistance) {
            if (initialDistance >= particle.maxDistance && !particle.misplaced) {
                particle.misplaced = initialDistance > particle.maxDistance;
                particle.velocity.horizontal = particle.velocity.vertical / 2 - particle.velocity.horizontal;
                particle.velocity.vertical = particle.velocity.horizontal / 2 - particle.velocity.vertical;
            }
            else if (initialDistance < particle.maxDistance && particle.misplaced) {
                particle.misplaced = false;
            }
            else if (particle.misplaced) {
                if ((particle.position.x < initialPosition.x && particle.velocity.horizontal < 0) ||
                    (particle.position.x > initialPosition.x && particle.velocity.horizontal > 0)) {
                    particle.velocity.horizontal *= -Math.random();
                }
                if ((particle.position.y < initialPosition.y && particle.velocity.vertical < 0) ||
                    (particle.position.y > initialPosition.y && particle.velocity.vertical > 0)) {
                    particle.velocity.vertical *= -Math.random();
                }
            }
        }
    }
    applyNoise(delta) {
        const particle = this.particle;
        const particlesOptions = particle.particlesOptions;
        const noiseOptions = particlesOptions.move.noise;
        const noiseEnabled = noiseOptions.enable;
        if (!noiseEnabled) {
            return;
        }
        const container = this.container;
        if (particle.lastNoiseTime <= particle.noiseDelay) {
            particle.lastNoiseTime += delta.value;
            return;
        }
        const noise = container.noise.generate(particle);
        particle.velocity.horizontal += Math.cos(noise.angle) * noise.length;
        particle.velocity.horizontal = Utils_1.NumberUtils.clamp(particle.velocity.horizontal, -1, 1);
        particle.velocity.vertical += Math.sin(noise.angle) * noise.length;
        particle.velocity.vertical = Utils_1.NumberUtils.clamp(particle.velocity.vertical, -1, 1);
        particle.lastNoiseTime -= particle.noiseDelay;
    }
    moveParallax() {
        const container = this.container;
        const options = container.options;
        if (Utils_1.Utils.isSsr() || !options.interactivity.events.onHover.parallax.enable) {
            return;
        }
        const particle = this.particle;
        const parallaxForce = options.interactivity.events.onHover.parallax.force;
        const mousePos = container.interactivity.mouse.position;
        if (!mousePos) {
            return;
        }
        const canvasCenter = {
            x: container.canvas.size.width / 2,
            y: container.canvas.size.height / 2,
        };
        const parallaxSmooth = options.interactivity.events.onHover.parallax.smooth;
        const factor = particle.getRadius() / parallaxForce;
        const tmp = {
            x: (mousePos.x - canvasCenter.x) * factor,
            y: (mousePos.y - canvasCenter.y) * factor,
        };
        particle.offset.x += (tmp.x - particle.offset.x) / parallaxSmooth;
        particle.offset.y += (tmp.y - particle.offset.y) / parallaxSmooth;
    }
    getProximitySpeedFactor() {
        const container = this.container;
        const options = container.options;
        const active = Utils_1.Utils.isInArray(Enums_1.HoverMode.slow, options.interactivity.events.onHover.mode);
        if (!active) {
            return 1;
        }
        const mousePos = this.container.interactivity.mouse.position;
        if (!mousePos) {
            return 1;
        }
        const particlePos = this.particle.getPosition();
        const dist = Utils_1.NumberUtils.getDistance(mousePos, particlePos);
        const radius = container.retina.slowModeRadius;
        if (dist > radius) {
            return 1;
        }
        const proximityFactor = dist / radius || 0;
        const slowFactor = options.interactivity.modes.slow.factor;
        return proximityFactor / slowFactor;
    }
}
exports.Mover = Mover;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particle/Updater.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particle/Updater.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Updater = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const OutModeDirection_1 = __webpack_require__(/*! ../../Enums/Directions/OutModeDirection */ "./node_modules/tsparticles/dist/Enums/Directions/OutModeDirection.js");
function bounceHorizontal(data) {
    if (data.outMode === Enums_1.OutMode.bounce ||
        data.outMode === Enums_1.OutMode.bounceHorizontal ||
        data.outMode === "bounceHorizontal") {
        const velocity = data.particle.velocity.horizontal;
        let bounced = false;
        if ((data.direction === OutModeDirection_1.OutModeDirection.right && data.bounds.right >= data.canvasSize.width && velocity > 0) ||
            (data.direction === OutModeDirection_1.OutModeDirection.left && data.bounds.left <= 0 && velocity < 0)) {
            const newVelocity = Utils_1.NumberUtils.getValue(data.particle.particlesOptions.bounce.horizontal);
            data.particle.velocity.horizontal *= -newVelocity;
            bounced = true;
        }
        if (bounced) {
            const minPos = data.offset.x + data.size;
            if (data.bounds.right >= data.canvasSize.width) {
                data.particle.position.x = data.canvasSize.width - minPos;
            }
            else if (data.bounds.left <= 0) {
                data.particle.position.x = minPos;
            }
        }
    }
}
function bounceVertical(data) {
    if (data.outMode === Enums_1.OutMode.bounce ||
        data.outMode === Enums_1.OutMode.bounceVertical ||
        data.outMode === "bounceVertical") {
        const velocity = data.particle.velocity.vertical;
        let bounced = false;
        if ((data.direction === OutModeDirection_1.OutModeDirection.bottom &&
            data.bounds.bottom >= data.canvasSize.height &&
            velocity > 0) ||
            (data.direction === OutModeDirection_1.OutModeDirection.top && data.bounds.top <= 0 && velocity < 0)) {
            const newVelocity = Utils_1.NumberUtils.getValue(data.particle.particlesOptions.bounce.vertical);
            data.particle.velocity.vertical *= -newVelocity;
            bounced = true;
        }
        if (bounced) {
            const minPos = data.offset.y + data.size;
            if (data.bounds.bottom >= data.canvasSize.height) {
                data.particle.position.y = data.canvasSize.height - minPos;
            }
            else if (data.bounds.top <= 0) {
                data.particle.position.y = minPos;
            }
        }
    }
}
function checkDestroy(particle, destroy, value, minValue, maxValue) {
    switch (destroy) {
        case Enums_1.DestroyType.max:
            if (value >= maxValue) {
                particle.destroy();
            }
            break;
        case Enums_1.DestroyType.min:
            if (value <= minValue) {
                particle.destroy();
            }
            break;
    }
}
class Updater {
    constructor(container, particle) {
        this.container = container;
        this.particle = particle;
    }
    update(delta) {
        if (this.particle.destroyed) {
            return;
        }
        this.updateLife(delta);
        if (this.particle.destroyed || this.particle.spawning) {
            return;
        }
        this.updateOpacity(delta);
        this.updateSize(delta);
        this.updateAngle(delta);
        this.updateColor(delta);
        this.updateStrokeColor(delta);
        this.updateOutModes(delta);
    }
    updateLife(delta) {
        const particle = this.particle;
        let justSpawned = false;
        if (particle.spawning) {
            particle.lifeDelayTime += delta.value;
            if (particle.lifeDelayTime >= particle.lifeDelay) {
                justSpawned = true;
                particle.spawning = false;
                particle.lifeDelayTime = 0;
                particle.lifeTime = 0;
            }
        }
        if (particle.lifeDuration === -1) {
            return;
        }
        if (!particle.spawning) {
            if (justSpawned) {
                particle.lifeTime = 0;
            }
            else {
                particle.lifeTime += delta.value;
            }
            if (particle.lifeTime >= particle.lifeDuration) {
                particle.lifeTime = 0;
                if (particle.livesRemaining > 0) {
                    particle.livesRemaining--;
                }
                if (particle.livesRemaining === 0) {
                    particle.destroy();
                    return;
                }
                const canvasSize = this.container.canvas.size;
                particle.position.x = Utils_1.NumberUtils.randomInRange(0, canvasSize.width);
                particle.position.y = Utils_1.NumberUtils.randomInRange(0, canvasSize.height);
                particle.spawning = true;
                particle.lifeDelayTime = 0;
                particle.lifeTime = 0;
                const lifeOptions = particle.particlesOptions.life;
                particle.lifeDelay = Utils_1.NumberUtils.getValue(lifeOptions.delay) * 1000;
                particle.lifeDuration = Utils_1.NumberUtils.getValue(lifeOptions.duration) * 1000;
            }
        }
    }
    updateOpacity(delta) {
        var _a, _b;
        const particle = this.particle;
        const opacityAnim = particle.particlesOptions.opacity.anim;
        const minValue = opacityAnim.minimumValue;
        const maxValue = particle.particlesOptions.opacity.value;
        if (opacityAnim.enable) {
            switch (particle.opacity.status) {
                case Enums_1.AnimationStatus.increasing:
                    if (particle.opacity.value >= maxValue) {
                        particle.opacity.status = Enums_1.AnimationStatus.decreasing;
                    }
                    else {
                        particle.opacity.value += ((_a = particle.opacity.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;
                    }
                    break;
                case Enums_1.AnimationStatus.decreasing:
                    if (particle.opacity.value <= minValue) {
                        particle.opacity.status = Enums_1.AnimationStatus.increasing;
                    }
                    else {
                        particle.opacity.value -= ((_b = particle.opacity.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;
                    }
                    break;
            }
            checkDestroy(particle, opacityAnim.destroy, particle.opacity.value, minValue, maxValue);
            if (!particle.destroyed) {
                particle.opacity.value = Utils_1.NumberUtils.clamp(particle.opacity.value, minValue, maxValue);
            }
        }
    }
    updateSize(delta) {
        var _a, _b;
        const container = this.container;
        const particle = this.particle;
        const sizeOpt = particle.particlesOptions.size;
        const sizeAnim = sizeOpt.animation;
        const sizeVelocity = ((_a = particle.size.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;
        const maxValue = (_b = particle.sizeValue) !== null && _b !== void 0 ? _b : container.retina.sizeValue;
        const minValue = sizeAnim.minimumValue * container.retina.pixelRatio;
        if (sizeAnim.enable) {
            switch (particle.size.status) {
                case Enums_1.AnimationStatus.increasing:
                    if (particle.size.value >= maxValue) {
                        particle.size.status = Enums_1.AnimationStatus.decreasing;
                    }
                    else {
                        particle.size.value += sizeVelocity;
                    }
                    break;
                case Enums_1.AnimationStatus.decreasing:
                    if (particle.size.value <= minValue) {
                        particle.size.status = Enums_1.AnimationStatus.increasing;
                    }
                    else {
                        particle.size.value -= sizeVelocity;
                    }
            }
            checkDestroy(particle, sizeAnim.destroy, particle.size.value, minValue, maxValue);
            if (!particle.destroyed) {
                particle.size.value = Utils_1.NumberUtils.clamp(particle.size.value, minValue, maxValue);
            }
        }
    }
    updateAngle(delta) {
        var _a;
        const particle = this.particle;
        const rotate = particle.particlesOptions.rotate;
        const rotateAnimation = rotate.animation;
        const speed = ((_a = particle.rotate.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;
        const max = 2 * Math.PI;
        if (rotate.path) {
            particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);
        }
        else if (rotateAnimation.enable) {
            switch (particle.rotate.status) {
                case Enums_1.AnimationStatus.increasing:
                    particle.rotate.value += speed;
                    if (particle.rotate.value > max) {
                        particle.rotate.value -= max;
                    }
                    break;
                case Enums_1.AnimationStatus.decreasing:
                default:
                    particle.rotate.value -= speed;
                    if (particle.rotate.value < 0) {
                        particle.rotate.value += max;
                    }
                    break;
            }
        }
    }
    updateColor(delta) {
        var _a;
        const particle = this.particle;
        if (particle.color.value === undefined) {
            return;
        }
        if (particle.particlesOptions.color.animation.enable) {
            particle.color.value.h += ((_a = particle.color.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;
            if (particle.color.value.h > 360) {
                particle.color.value.h -= 360;
            }
        }
    }
    updateStrokeColor(delta) {
        var _a, _b;
        const particle = this.particle;
        const color = particle.stroke.color;
        if (typeof color === "string" || color === undefined) {
            return;
        }
        if (particle.strokeColor.value === undefined) {
            return;
        }
        if (color.animation.enable) {
            particle.strokeColor.value.h +=
                ((_b = (_a = particle.strokeColor.velocity) !== null && _a !== void 0 ? _a : particle.color.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;
            if (particle.strokeColor.value.h > 360) {
                particle.strokeColor.value.h -= 360;
            }
        }
    }
    updateOutModes(delta) {
        var _a, _b, _c, _d;
        const outModes = this.particle.particlesOptions.move.outModes;
        this.updateOutMode(delta, (_a = outModes.bottom) !== null && _a !== void 0 ? _a : outModes.default, OutModeDirection_1.OutModeDirection.bottom);
        this.updateOutMode(delta, (_b = outModes.left) !== null && _b !== void 0 ? _b : outModes.default, OutModeDirection_1.OutModeDirection.left);
        this.updateOutMode(delta, (_c = outModes.right) !== null && _c !== void 0 ? _c : outModes.default, OutModeDirection_1.OutModeDirection.right);
        this.updateOutMode(delta, (_d = outModes.top) !== null && _d !== void 0 ? _d : outModes.default, OutModeDirection_1.OutModeDirection.top);
    }
    updateOutMode(delta, outMode, direction) {
        const container = this.container;
        const particle = this.particle;
        switch (outMode) {
            case Enums_1.OutMode.bounce:
            case Enums_1.OutMode.bounceVertical:
            case Enums_1.OutMode.bounceHorizontal:
            case "bounceVertical":
            case "bounceHorizontal":
                this.updateBounce(delta, direction, outMode);
                break;
            case Enums_1.OutMode.destroy:
                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {
                    container.particles.remove(particle);
                }
                break;
            case Enums_1.OutMode.out:
                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {
                    this.fixOutOfCanvasPosition(direction);
                }
                break;
            case Enums_1.OutMode.none:
                this.bounceNone(direction);
                break;
        }
    }
    fixOutOfCanvasPosition(direction) {
        const container = this.container;
        const particle = this.particle;
        const wrap = particle.particlesOptions.move.warp;
        const canvasSize = container.canvas.size;
        const newPos = {
            bottom: canvasSize.height + particle.getRadius() - particle.offset.y,
            left: -particle.getRadius() - particle.offset.x,
            right: canvasSize.width + particle.getRadius() + particle.offset.x,
            top: -particle.getRadius() - particle.offset.y,
        };
        const sizeValue = particle.getRadius();
        const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);
        if (direction === OutModeDirection_1.OutModeDirection.right && nextBounds.left > canvasSize.width - particle.offset.x) {
            particle.position.x = newPos.left;
            if (!wrap) {
                particle.position.y = Math.random() * canvasSize.height;
            }
        }
        else if (direction === OutModeDirection_1.OutModeDirection.left && nextBounds.right < -particle.offset.x) {
            particle.position.x = newPos.right;
            if (!wrap) {
                particle.position.y = Math.random() * canvasSize.height;
            }
        }
        if (direction === OutModeDirection_1.OutModeDirection.bottom && nextBounds.top > canvasSize.height - particle.offset.y) {
            if (!wrap) {
                particle.position.x = Math.random() * canvasSize.width;
            }
            particle.position.y = newPos.top;
        }
        else if (direction === OutModeDirection_1.OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {
            if (!wrap) {
                particle.position.x = Math.random() * canvasSize.width;
            }
            particle.position.y = newPos.bottom;
        }
    }
    updateBounce(delta, direction, outMode) {
        const container = this.container;
        const particle = this.particle;
        let handled = false;
        for (const [, plugin] of container.plugins) {
            if (plugin.particleBounce !== undefined) {
                handled = plugin.particleBounce(particle, delta, direction);
            }
            if (handled) {
                break;
            }
        }
        if (handled) {
            return;
        }
        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = Utils_1.Utils.calculateBounds(pos, size), canvasSize = container.canvas.size;
        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });
        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });
    }
    bounceNone(direction) {
        const particle = this.particle;
        if (particle.particlesOptions.move.distance) {
            return;
        }
        const gravityOptions = particle.particlesOptions.move.gravity;
        const container = this.container;
        if (!gravityOptions.enable) {
            if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {
                container.particles.remove(particle);
            }
        }
        else {
            const position = particle.position;
            if ((gravityOptions.acceleration >= 0 &&
                position.y > container.canvas.size.height &&
                direction === OutModeDirection_1.OutModeDirection.bottom) ||
                (gravityOptions.acceleration < 0 && position.y < 0 && direction === OutModeDirection_1.OutModeDirection.top)) {
                container.particles.remove(particle);
            }
        }
    }
}
exports.Updater = Updater;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particles.js":
/*!*********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particles.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Particles = void 0;
const Particle_1 = __webpack_require__(/*! ./Particle */ "./node_modules/tsparticles/dist/Core/Particle.js");
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const InteractionManager_1 = __webpack_require__(/*! ./Particle/InteractionManager */ "./node_modules/tsparticles/dist/Core/Particle/InteractionManager.js");
class Particles {
    constructor(container) {
        this.container = container;
        this.nextId = 0;
        this.array = [];
        this.limit = 0;
        this.linksFreq = new Map();
        this.trianglesFreq = new Map();
        this.interactionManager = new InteractionManager_1.InteractionManager(container);
        const canvasSize = this.container.canvas.size;
        this.linksColors = new Map();
        this.quadTree = new Utils_1.QuadTree(new Utils_1.Rectangle(-canvasSize.width / 4, -canvasSize.height / 4, (canvasSize.width * 3) / 2, (canvasSize.height * 3) / 2), 4);
    }
    get count() {
        return this.array.length;
    }
    init() {
        const container = this.container;
        const options = container.options;
        this.linksFreq = new Map();
        this.trianglesFreq = new Map();
        let handled = false;
        for (const particle of options.manualParticles) {
            const pos = particle.position
                ? {
                    x: (particle.position.x * container.canvas.size.width) / 100,
                    y: (particle.position.y * container.canvas.size.height) / 100,
                }
                : undefined;
            this.addParticle(pos, particle.options);
        }
        for (const [, plugin] of container.plugins) {
            if (plugin.particlesInitialization !== undefined) {
                handled = plugin.particlesInitialization();
            }
            if (handled) {
                break;
            }
        }
        if (!handled) {
            for (let i = this.count; i < options.particles.number.value; i++) {
                this.addParticle();
            }
        }
        if (options.infection.enable) {
            for (let i = 0; i < options.infection.infections; i++) {
                const notInfected = this.array.filter((p) => p.infecter.infectionStage === undefined);
                const infected = Utils_1.Utils.itemFromArray(notInfected);
                infected.infecter.startInfection(0);
            }
        }
        this.interactionManager.init();
        container.noise.init();
    }
    redraw() {
        this.clear();
        this.init();
        this.draw({ value: 0, factor: 0 });
    }
    removeAt(index, quantity) {
        if (index >= 0 && index <= this.count) {
            for (const particle of this.array.splice(index, quantity !== null && quantity !== void 0 ? quantity : 1)) {
                particle.destroy();
            }
        }
    }
    remove(particle) {
        this.removeAt(this.array.indexOf(particle));
    }
    update(delta) {
        const container = this.container;
        const particlesToDelete = [];
        container.noise.update();
        for (const particle of this.array) {
            particle.move(delta);
            if (particle.destroyed) {
                particlesToDelete.push(particle);
                continue;
            }
            this.quadTree.insert(new Utils_1.Point(particle.getPosition(), particle));
        }
        for (const particle of particlesToDelete) {
            this.remove(particle);
        }
        this.interactionManager.externalInteract(delta);
        for (const particle of this.container.particles.array) {
            particle.update(delta);
            if (!particle.destroyed && !particle.spawning) {
                this.interactionManager.particlesInteract(particle, delta);
            }
        }
    }
    draw(delta) {
        const container = this.container;
        container.canvas.clear();
        const canvasSize = this.container.canvas.size;
        this.quadTree = new Utils_1.QuadTree(new Utils_1.Rectangle(-canvasSize.width / 4, -canvasSize.height / 4, (canvasSize.width * 3) / 2, (canvasSize.height * 3) / 2), 4);
        this.update(delta);
        for (const [, plugin] of container.plugins) {
            container.canvas.drawPlugin(plugin, delta);
        }
        for (const p of this.array) {
            p.draw(delta);
        }
    }
    clear() {
        this.array = [];
    }
    push(nb, mouse, overrideOptions) {
        const container = this.container;
        const options = container.options;
        const limit = options.particles.number.limit * container.density;
        this.pushing = true;
        if (limit > 0) {
            const countToRemove = this.count + nb - limit;
            if (countToRemove > 0) {
                this.removeQuantity(countToRemove);
            }
        }
        for (let i = 0; i < nb; i++) {
            this.addParticle(mouse === null || mouse === void 0 ? void 0 : mouse.position, overrideOptions);
        }
        this.pushing = false;
    }
    addParticle(position, overrideOptions) {
        try {
            const particle = new Particle_1.Particle(this.nextId, this.container, position, overrideOptions);
            this.array.push(particle);
            this.nextId++;
            return particle;
        }
        catch (_a) {
            console.warn("error adding particle");
            return;
        }
    }
    removeQuantity(quantity) {
        this.removeAt(0, quantity);
    }
    getLinkFrequency(p1, p2) {
        const key = `${Math.min(p1.id, p2.id)}_${Math.max(p1.id, p2.id)}`;
        let res = this.linksFreq.get(key);
        if (res === undefined) {
            res = Math.random();
            this.linksFreq.set(key, res);
        }
        return res;
    }
    getTriangleFrequency(p1, p2, p3) {
        let [id1, id2, id3] = [p1.id, p2.id, p3.id];
        if (id1 > id2) {
            [id2, id1] = [id1, id2];
        }
        if (id2 > id3) {
            [id3, id2] = [id2, id3];
        }
        if (id1 > id3) {
            [id3, id1] = [id1, id3];
        }
        const key = `${id1}_${id2}_${id3}`;
        let res = this.trianglesFreq.get(key);
        if (res === undefined) {
            res = Math.random();
            this.trianglesFreq.set(key, res);
        }
        return res;
    }
    setDensity() {
        const options = this.container.options;
        this.applyDensity(options.particles);
    }
    applyDensity(options) {
        var _a;
        if (!((_a = options.number.density) === null || _a === void 0 ? void 0 : _a.enable)) {
            return;
        }
        const numberOptions = options.number;
        const densityFactor = this.initDensityFactor(numberOptions.density);
        const optParticlesNumber = numberOptions.value;
        const optParticlesLimit = numberOptions.limit > 0 ? numberOptions.limit : optParticlesNumber;
        const particlesNumber = Math.min(optParticlesNumber, optParticlesLimit) * densityFactor;
        const particlesCount = this.count;
        this.limit = numberOptions.limit * densityFactor;
        if (particlesCount < particlesNumber) {
            this.push(Math.abs(particlesNumber - particlesCount), undefined, options);
        }
        else if (particlesCount > particlesNumber) {
            this.removeQuantity(particlesCount - particlesNumber);
        }
    }
    initDensityFactor(densityOptions) {
        const container = this.container;
        if (!container.canvas.element || !densityOptions.enable) {
            return 1;
        }
        const canvas = container.canvas.element;
        const pxRatio = container.retina.pixelRatio;
        return (canvas.width * canvas.height) / (densityOptions.factor * pxRatio * pxRatio * densityOptions.area);
    }
}
exports.Particles = Particles;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Retina.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Retina.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Retina = void 0;
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Retina {
    constructor(container) {
        this.container = container;
    }
    init() {
        const container = this.container;
        const options = container.options;
        if (options.detectRetina) {
            this.pixelRatio = Utils_1.Utils.isSsr() ? 1 : window.devicePixelRatio;
        }
        else {
            this.pixelRatio = 1;
        }
        const motionOptions = this.container.options.motion;
        if (motionOptions && (motionOptions.disable || motionOptions.reduce.value)) {
            if (Utils_1.Utils.isSsr() || typeof matchMedia === "undefined" || !matchMedia) {
                this.reduceFactor = 1;
            }
            else {
                const mediaQuery = matchMedia("(prefers-reduced-motion: reduce)");
                if (mediaQuery) {
                    this.handleMotionChange(mediaQuery);
                    const handleChange = () => {
                        this.handleMotionChange(mediaQuery);
                        container.refresh().catch(() => {
                        });
                    };
                    if (mediaQuery.addEventListener !== undefined) {
                        mediaQuery.addEventListener("change", handleChange);
                    }
                    else if (mediaQuery.addListener !== undefined) {
                        mediaQuery.addListener(handleChange);
                    }
                }
            }
        }
        else {
            this.reduceFactor = 1;
        }
        const ratio = this.pixelRatio;
        if (container.canvas.element) {
            const element = container.canvas.element;
            container.canvas.size.width = element.offsetWidth * ratio;
            container.canvas.size.height = element.offsetHeight * ratio;
        }
        const particles = options.particles;
        this.linksDistance = particles.links.distance * ratio;
        this.linksWidth = particles.links.width * ratio;
        this.moveSpeed = particles.move.speed * ratio;
        this.sizeValue = particles.size.value * ratio;
        this.sizeAnimationSpeed = particles.size.animation.speed * ratio;
        const modes = options.interactivity.modes;
        this.connectModeDistance = modes.connect.distance * ratio;
        this.connectModeRadius = modes.connect.radius * ratio;
        this.grabModeDistance = modes.grab.distance * ratio;
        this.repulseModeDistance = modes.repulse.distance * ratio;
        this.bounceModeDistance = modes.bounce.distance * ratio;
        this.attractModeDistance = modes.attract.distance * ratio;
        this.slowModeRadius = modes.slow.radius * ratio;
        this.bubbleModeDistance = modes.bubble.distance * ratio;
        if (modes.bubble.size) {
            this.bubbleModeSize = modes.bubble.size * ratio;
        }
    }
    initParticle(particle) {
        const particlesOptions = particle.particlesOptions;
        const ratio = this.pixelRatio;
        particle.linksDistance = particlesOptions.links.distance * ratio;
        particle.linksWidth = particlesOptions.links.width * ratio;
        particle.moveSpeed = particlesOptions.move.speed * ratio;
        particle.sizeValue = particlesOptions.size.value * ratio;
        particle.sizeAnimationSpeed = particlesOptions.size.animation.speed * ratio;
        particle.maxDistance = particlesOptions.move.distance * ratio;
    }
    handleMotionChange(mediaQuery) {
        const options = this.container.options;
        if (mediaQuery.matches) {
            const motion = options.motion;
            this.reduceFactor = motion.disable ? 0 : motion.reduce.value ? 1 / motion.reduce.factor : 1;
        }
        else {
            this.reduceFactor = 1;
        }
    }
}
exports.Retina = Retina;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/AnimationStatus.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/AnimationStatus.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimationStatus = void 0;
var AnimationStatus;
(function (AnimationStatus) {
    AnimationStatus[AnimationStatus["increasing"] = 0] = "increasing";
    AnimationStatus[AnimationStatus["decreasing"] = 1] = "decreasing";
})(AnimationStatus = exports.AnimationStatus || (exports.AnimationStatus = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Directions/MoveDirection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Directions/MoveDirection.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MoveDirection = void 0;
var MoveDirection;
(function (MoveDirection) {
    MoveDirection["bottom"] = "bottom";
    MoveDirection["bottomLeft"] = "bottom-left";
    MoveDirection["bottomRight"] = "bottom-right";
    MoveDirection["left"] = "left";
    MoveDirection["none"] = "none";
    MoveDirection["right"] = "right";
    MoveDirection["top"] = "top";
    MoveDirection["topLeft"] = "top-left";
    MoveDirection["topRight"] = "top-right";
})(MoveDirection = exports.MoveDirection || (exports.MoveDirection = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Directions/OutModeDirection.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Directions/OutModeDirection.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OutModeDirection = void 0;
var OutModeDirection;
(function (OutModeDirection) {
    OutModeDirection["bottom"] = "bottom";
    OutModeDirection["left"] = "left";
    OutModeDirection["right"] = "right";
    OutModeDirection["top"] = "top";
})(OutModeDirection = exports.OutModeDirection || (exports.OutModeDirection = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Directions/RotateDirection.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Directions/RotateDirection.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RotateDirection = void 0;
var RotateDirection;
(function (RotateDirection) {
    RotateDirection["clockwise"] = "clockwise";
    RotateDirection["counterClockwise"] = "counter-clockwise";
    RotateDirection["random"] = "random";
})(RotateDirection = exports.RotateDirection || (exports.RotateDirection = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Directions/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Directions/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./MoveDirection */ "./node_modules/tsparticles/dist/Enums/Directions/MoveDirection.js"), exports);
__exportStar(__webpack_require__(/*! ./RotateDirection */ "./node_modules/tsparticles/dist/Enums/Directions/RotateDirection.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/InteractivityDetect.js":
/*!********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/InteractivityDetect.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractivityDetect = void 0;
var InteractivityDetect;
(function (InteractivityDetect) {
    InteractivityDetect["canvas"] = "canvas";
    InteractivityDetect["parent"] = "parent";
    InteractivityDetect["window"] = "window";
})(InteractivityDetect = exports.InteractivityDetect || (exports.InteractivityDetect = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/ClickMode.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/ClickMode.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ClickMode = void 0;
var ClickMode;
(function (ClickMode) {
    ClickMode["attract"] = "attract";
    ClickMode["bubble"] = "bubble";
    ClickMode["push"] = "push";
    ClickMode["remove"] = "remove";
    ClickMode["repulse"] = "repulse";
    ClickMode["pause"] = "pause";
    ClickMode["trail"] = "trail";
})(ClickMode = exports.ClickMode || (exports.ClickMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/CollisionMode.js":
/*!********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/CollisionMode.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CollisionMode = void 0;
var CollisionMode;
(function (CollisionMode) {
    CollisionMode["absorb"] = "absorb";
    CollisionMode["bounce"] = "bounce";
    CollisionMode["destroy"] = "destroy";
})(CollisionMode = exports.CollisionMode || (exports.CollisionMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/DivMode.js":
/*!**************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/DivMode.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DivMode = void 0;
var DivMode;
(function (DivMode) {
    DivMode["bounce"] = "bounce";
    DivMode["bubble"] = "bubble";
    DivMode["repulse"] = "repulse";
})(DivMode = exports.DivMode || (exports.DivMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/HoverMode.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/HoverMode.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HoverMode = void 0;
var HoverMode;
(function (HoverMode) {
    HoverMode["attract"] = "attract";
    HoverMode["bounce"] = "bounce";
    HoverMode["bubble"] = "bubble";
    HoverMode["connect"] = "connect";
    HoverMode["grab"] = "grab";
    HoverMode["light"] = "light";
    HoverMode["repulse"] = "repulse";
    HoverMode["slow"] = "slow";
    HoverMode["trail"] = "trail";
})(HoverMode = exports.HoverMode || (exports.HoverMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/OutMode.js":
/*!**************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/OutMode.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OutMode = void 0;
var OutMode;
(function (OutMode) {
    OutMode["bounce"] = "bounce";
    OutMode["bounceHorizontal"] = "bounce-horizontal";
    OutMode["bounceVertical"] = "bounce-vertical";
    OutMode["none"] = "none";
    OutMode["out"] = "out";
    OutMode["destroy"] = "destroy";
})(OutMode = exports.OutMode || (exports.OutMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/SizeMode.js":
/*!***************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/SizeMode.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SizeMode = void 0;
var SizeMode;
(function (SizeMode) {
    SizeMode["precise"] = "precise";
    SizeMode["percent"] = "percent";
})(SizeMode = exports.SizeMode || (exports.SizeMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/ThemeMode.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/ThemeMode.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ThemeMode = void 0;
var ThemeMode;
(function (ThemeMode) {
    ThemeMode["any"] = "any";
    ThemeMode["dark"] = "dark";
    ThemeMode["light"] = "light";
})(ThemeMode = exports.ThemeMode || (exports.ThemeMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/index.js":
/*!************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./ClickMode */ "./node_modules/tsparticles/dist/Enums/Modes/ClickMode.js"), exports);
__exportStar(__webpack_require__(/*! ./DivMode */ "./node_modules/tsparticles/dist/Enums/Modes/DivMode.js"), exports);
__exportStar(__webpack_require__(/*! ./HoverMode */ "./node_modules/tsparticles/dist/Enums/Modes/HoverMode.js"), exports);
__exportStar(__webpack_require__(/*! ./CollisionMode */ "./node_modules/tsparticles/dist/Enums/Modes/CollisionMode.js"), exports);
__exportStar(__webpack_require__(/*! ./OutMode */ "./node_modules/tsparticles/dist/Enums/Modes/OutMode.js"), exports);
__exportStar(__webpack_require__(/*! ./SizeMode */ "./node_modules/tsparticles/dist/Enums/Modes/SizeMode.js"), exports);
__exportStar(__webpack_require__(/*! ./ThemeMode */ "./node_modules/tsparticles/dist/Enums/Modes/ThemeMode.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/MoveDirection.js":
/*!**************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/MoveDirection.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./Directions */ "./node_modules/tsparticles/dist/Enums/Directions/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/OutMode.js":
/*!********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/OutMode.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/PolygonMaskInlineArrangement.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/PolygonMaskInlineArrangement.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonMaskInlineArrangement = void 0;
const Enums_1 = __webpack_require__(/*! ../Plugins/PolygonMask/Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
Object.defineProperty(exports, "PolygonMaskInlineArrangement", { enumerable: true, get: function () { return Enums_1.InlineArrangement; } });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/PolygonMaskMoveType.js":
/*!********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/PolygonMaskMoveType.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonMaskMoveType = void 0;
const Enums_1 = __webpack_require__(/*! ../Plugins/PolygonMask/Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
Object.defineProperty(exports, "PolygonMaskMoveType", { enumerable: true, get: function () { return Enums_1.MoveType; } });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/PolygonMaskType.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/PolygonMaskType.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonMaskType = void 0;
const Enums_1 = __webpack_require__(/*! ../Plugins/PolygonMask/Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
Object.defineProperty(exports, "PolygonMaskType", { enumerable: true, get: function () { return Enums_1.Type; } });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/ProcessBubbleType.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/ProcessBubbleType.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./Types */ "./node_modules/tsparticles/dist/Enums/Types/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/RotateDirection.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/RotateDirection.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./Directions */ "./node_modules/tsparticles/dist/Enums/Directions/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/ShapeType.js":
/*!**********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/ShapeType.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./Types */ "./node_modules/tsparticles/dist/Enums/Types/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Types/DestroyType.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Types/DestroyType.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DestroyType = void 0;
var DestroyType;
(function (DestroyType) {
    DestroyType["none"] = "none";
    DestroyType["max"] = "max";
    DestroyType["min"] = "min";
})(DestroyType = exports.DestroyType || (exports.DestroyType = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Types/DivType.js":
/*!**************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Types/DivType.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DivType = void 0;
var DivType;
(function (DivType) {
    DivType["circle"] = "circle";
    DivType["rectangle"] = "rectangle";
})(DivType = exports.DivType || (exports.DivType = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Types/ProcessBubbleType.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Types/ProcessBubbleType.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessBubbleType = void 0;
var ProcessBubbleType;
(function (ProcessBubbleType) {
    ProcessBubbleType["color"] = "color";
    ProcessBubbleType["opacity"] = "opacity";
    ProcessBubbleType["size"] = "size";
})(ProcessBubbleType = exports.ProcessBubbleType || (exports.ProcessBubbleType = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Types/ShapeType.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Types/ShapeType.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ShapeType = void 0;
var ShapeType;
(function (ShapeType) {
    ShapeType["char"] = "char";
    ShapeType["character"] = "character";
    ShapeType["circle"] = "circle";
    ShapeType["edge"] = "edge";
    ShapeType["image"] = "image";
    ShapeType["images"] = "images";
    ShapeType["line"] = "line";
    ShapeType["polygon"] = "polygon";
    ShapeType["square"] = "square";
    ShapeType["star"] = "star";
    ShapeType["triangle"] = "triangle";
})(ShapeType = exports.ShapeType || (exports.ShapeType = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Types/StartValueType.js":
/*!*********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Types/StartValueType.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StartValueType = void 0;
var StartValueType;
(function (StartValueType) {
    StartValueType["max"] = "max";
    StartValueType["min"] = "min";
    StartValueType["random"] = "random";
})(StartValueType = exports.StartValueType || (exports.StartValueType = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Types/index.js":
/*!************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Types/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./DestroyType */ "./node_modules/tsparticles/dist/Enums/Types/DestroyType.js"), exports);
__exportStar(__webpack_require__(/*! ./ProcessBubbleType */ "./node_modules/tsparticles/dist/Enums/Types/ProcessBubbleType.js"), exports);
__exportStar(__webpack_require__(/*! ./ShapeType */ "./node_modules/tsparticles/dist/Enums/Types/ShapeType.js"), exports);
__exportStar(__webpack_require__(/*! ./StartValueType */ "./node_modules/tsparticles/dist/Enums/Types/StartValueType.js"), exports);
__exportStar(__webpack_require__(/*! ./DivType */ "./node_modules/tsparticles/dist/Enums/Types/DivType.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/index.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./Directions */ "./node_modules/tsparticles/dist/Enums/Directions/index.js"), exports);
__exportStar(__webpack_require__(/*! ./Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js"), exports);
__exportStar(__webpack_require__(/*! ./AnimationStatus */ "./node_modules/tsparticles/dist/Enums/AnimationStatus.js"), exports);
__exportStar(__webpack_require__(/*! ./Types */ "./node_modules/tsparticles/dist/Enums/Types/index.js"), exports);
__exportStar(__webpack_require__(/*! ./InteractivityDetect */ "./node_modules/tsparticles/dist/Enums/InteractivityDetect.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Attractor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Attractor.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Attractor = void 0;
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Attractor {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        const container = this.container;
        const options = container.options;
        const mouse = container.interactivity.mouse;
        const events = options.interactivity.events;
        if (!((events.onHover.enable && mouse.position) || (events.onClick.enable && mouse.clickPosition))) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        const clickMode = events.onClick.mode;
        return Utils_1.Utils.isInArray(Enums_1.HoverMode.attract, hoverMode) || Utils_1.Utils.isInArray(Enums_1.ClickMode.attract, clickMode);
    }
    reset() {
    }
    interact() {
        const container = this.container;
        const options = container.options;
        const mouseMoveStatus = container.interactivity.status === Utils_1.Constants.mouseMoveEvent;
        const events = options.interactivity.events;
        const hoverEnabled = events.onHover.enable;
        const hoverMode = events.onHover.mode;
        const clickEnabled = events.onClick.enable;
        const clickMode = events.onClick.mode;
        if (mouseMoveStatus && hoverEnabled && Utils_1.Utils.isInArray(Enums_1.HoverMode.attract, hoverMode)) {
            this.hoverAttract();
        }
        else if (clickEnabled && Utils_1.Utils.isInArray(Enums_1.ClickMode.attract, clickMode)) {
            this.clickAttract();
        }
    }
    hoverAttract() {
        const container = this.container;
        const mousePos = container.interactivity.mouse.position;
        if (!mousePos) {
            return;
        }
        const attractRadius = container.retina.attractModeDistance;
        this.processAttract(mousePos, attractRadius, new Utils_1.Circle(mousePos.x, mousePos.y, attractRadius));
    }
    processAttract(position, attractRadius, area) {
        const container = this.container;
        const query = container.particles.quadTree.query(area);
        for (const particle of query) {
            const { dx, dy, distance } = Utils_1.NumberUtils.getDistances(particle.position, position);
            const normVec = {
                x: dx / distance,
                y: dy / distance,
            };
            const velocity = container.options.interactivity.modes.attract.speed;
            const attractFactor = Utils_1.NumberUtils.clamp((1 - Math.pow(distance / attractRadius, 2)) * velocity, 0, 50);
            particle.position.x = particle.position.x - normVec.x * attractFactor;
            particle.position.y = particle.position.y - normVec.y * attractFactor;
        }
    }
    clickAttract() {
        const container = this.container;
        if (!container.attract.finish) {
            if (!container.attract.count) {
                container.attract.count = 0;
            }
            container.attract.count++;
            if (container.attract.count === container.particles.count) {
                container.attract.finish = true;
            }
        }
        if (container.attract.clicking) {
            const mousePos = container.interactivity.mouse.clickPosition;
            if (!mousePos) {
                return;
            }
            const attractRadius = container.retina.attractModeDistance;
            this.processAttract(mousePos, attractRadius, new Utils_1.Circle(mousePos.x, mousePos.y, attractRadius));
        }
        else if (container.attract.clicking === false) {
            container.attract.particles = [];
        }
        return;
    }
}
exports.Attractor = Attractor;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Bouncer.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Bouncer.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Bouncer = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Modes_1 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
const Utils_2 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Modes_2 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
const Types_1 = __webpack_require__(/*! ../../Enums/Types */ "./node_modules/tsparticles/dist/Enums/Types/index.js");
class Bouncer {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        const container = this.container;
        const options = container.options;
        const mouse = container.interactivity.mouse;
        const events = options.interactivity.events;
        const divs = events.onDiv;
        return ((mouse.position && events.onHover.enable && Utils_2.Utils.isInArray(Modes_1.HoverMode.bounce, events.onHover.mode)) ||
            Utils_2.Utils.isDivModeEnabled(Modes_2.DivMode.bounce, divs));
    }
    interact() {
        const container = this.container;
        const options = container.options;
        const events = options.interactivity.events;
        const mouseMoveStatus = container.interactivity.status === Utils_1.Constants.mouseMoveEvent;
        const hoverEnabled = events.onHover.enable;
        const hoverMode = events.onHover.mode;
        const divs = events.onDiv;
        if (mouseMoveStatus && hoverEnabled && Utils_2.Utils.isInArray(Modes_1.HoverMode.bounce, hoverMode)) {
            this.processMouseBounce();
        }
        else {
            Utils_2.Utils.divModeExecute(Modes_2.DivMode.bounce, divs, (selector, div) => this.singleSelectorBounce(selector, div));
        }
    }
    reset() {
    }
    processMouseBounce() {
        const container = this.container;
        const pxRatio = container.retina.pixelRatio;
        const tolerance = 10 * pxRatio;
        const mousePos = container.interactivity.mouse.position;
        const radius = container.retina.bounceModeDistance;
        if (mousePos) {
            this.processBounce(mousePos, radius, new Utils_2.Circle(mousePos.x, mousePos.y, radius + tolerance));
        }
    }
    singleSelectorBounce(selector, div) {
        const container = this.container;
        const query = document.querySelectorAll(selector);
        if (!query.length) {
            return;
        }
        query.forEach((item) => {
            const elem = item;
            const pxRatio = container.retina.pixelRatio;
            const pos = {
                x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,
                y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio,
            };
            const radius = (elem.offsetWidth / 2) * pxRatio;
            const tolerance = 10 * pxRatio;
            const area = div.type === Types_1.DivType.circle
                ? new Utils_2.Circle(pos.x, pos.y, radius + tolerance)
                : new Utils_2.Rectangle(elem.offsetLeft * pxRatio - tolerance, elem.offsetTop * pxRatio - tolerance, elem.offsetWidth * pxRatio + tolerance * 2, elem.offsetHeight * pxRatio + tolerance * 2);
            this.processBounce(pos, radius, area);
        });
    }
    processBounce(position, radius, area) {
        const query = this.container.particles.quadTree.query(area);
        for (const particle of query) {
            if (area instanceof Utils_2.Circle) {
                Utils_2.Utils.circleBounce(Utils_2.Utils.circleBounceDataFromParticle(particle), {
                    position,
                    radius,
                    velocity: {
                        horizontal: 0,
                        vertical: 0,
                    },
                    factor: {
                        horizontal: 0,
                        vertical: 0,
                    },
                });
            }
            else if (area instanceof Utils_2.Rectangle) {
                Utils_2.Utils.rectBounce(particle, Utils_2.Utils.calculateBounds(position, radius));
            }
        }
    }
}
exports.Bouncer = Bouncer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Bubbler.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Bubbler.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Bubbler = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
function calculateBubbleValue(particleValue, modeValue, optionsValue, ratio) {
    if (modeValue > optionsValue) {
        const size = particleValue + (modeValue - optionsValue) * ratio;
        return Utils_1.NumberUtils.clamp(size, particleValue, modeValue);
    }
    else if (modeValue < optionsValue) {
        const size = particleValue - (optionsValue - modeValue) * ratio;
        return Utils_1.NumberUtils.clamp(size, modeValue, particleValue);
    }
}
class Bubbler {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        const container = this.container;
        const options = container.options;
        const mouse = container.interactivity.mouse;
        const events = options.interactivity.events;
        const divs = events.onDiv;
        const divBubble = Utils_1.Utils.isDivModeEnabled(Enums_1.DivMode.bubble, divs);
        if (!(divBubble || (events.onHover.enable && mouse.position) || (events.onClick.enable && mouse.clickPosition))) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        const clickMode = events.onClick.mode;
        return (Utils_1.Utils.isInArray(Enums_1.HoverMode.bubble, hoverMode) || Utils_1.Utils.isInArray(Enums_1.ClickMode.bubble, clickMode) || divBubble);
    }
    reset(particle, force) {
        if (!particle.bubble.inRange || force) {
            delete particle.bubble.div;
            delete particle.bubble.opacity;
            delete particle.bubble.radius;
            delete particle.bubble.color;
        }
    }
    interact() {
        const options = this.container.options;
        const events = options.interactivity.events;
        const onHover = events.onHover;
        const onClick = events.onClick;
        const hoverEnabled = onHover.enable;
        const hoverMode = onHover.mode;
        const clickEnabled = onClick.enable;
        const clickMode = onClick.mode;
        const divs = events.onDiv;
        if (hoverEnabled && Utils_1.Utils.isInArray(Enums_1.HoverMode.bubble, hoverMode)) {
            this.hoverBubble();
        }
        else if (clickEnabled && Utils_1.Utils.isInArray(Enums_1.ClickMode.bubble, clickMode)) {
            this.clickBubble();
        }
        else {
            Utils_1.Utils.divModeExecute(Enums_1.DivMode.bubble, divs, (selector, div) => this.singleSelectorHover(selector, div));
        }
    }
    singleSelectorHover(selector, div) {
        const container = this.container;
        const selectors = document.querySelectorAll(selector);
        if (!selectors.length) {
            return;
        }
        selectors.forEach((item) => {
            const elem = item;
            const pxRatio = container.retina.pixelRatio;
            const pos = {
                x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,
                y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio,
            };
            const repulseRadius = (elem.offsetWidth / 2) * pxRatio;
            const area = div.type === Enums_1.DivType.circle
                ? new Utils_1.Circle(pos.x, pos.y, repulseRadius)
                : new Utils_1.Rectangle(elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio);
            const query = container.particles.quadTree.query(area);
            for (const particle of query) {
                if (!area.contains(particle.getPosition())) {
                    continue;
                }
                particle.bubble.inRange = true;
                const divs = container.options.interactivity.modes.bubble.divs;
                const divBubble = Utils_1.Utils.divMode(divs, elem);
                if (!particle.bubble.div || particle.bubble.div !== elem) {
                    this.reset(particle, true);
                    particle.bubble.div = elem;
                }
                this.hoverBubbleSize(particle, 1, divBubble);
                this.hoverBubbleOpacity(particle, 1, divBubble);
                this.hoverBubbleColor(particle, divBubble);
            }
        });
    }
    process(particle, distMouse, timeSpent, data) {
        const container = this.container;
        const bubbleParam = data.bubbleObj.optValue;
        if (bubbleParam === undefined) {
            return;
        }
        const options = container.options;
        const bubbleDuration = options.interactivity.modes.bubble.duration;
        const bubbleDistance = container.retina.bubbleModeDistance;
        const particlesParam = data.particlesObj.optValue;
        const pObjBubble = data.bubbleObj.value;
        const pObj = data.particlesObj.value || 0;
        const type = data.type;
        if (bubbleParam !== particlesParam) {
            if (!container.bubble.durationEnd) {
                if (distMouse <= bubbleDistance) {
                    const obj = pObjBubble !== null && pObjBubble !== void 0 ? pObjBubble : pObj;
                    if (obj !== bubbleParam) {
                        const value = pObj - (timeSpent * (pObj - bubbleParam)) / bubbleDuration;
                        if (type === Enums_1.ProcessBubbleType.size) {
                            particle.bubble.radius = value;
                        }
                        if (type === Enums_1.ProcessBubbleType.opacity) {
                            particle.bubble.opacity = value;
                        }
                    }
                }
                else {
                    if (type === Enums_1.ProcessBubbleType.size) {
                        delete particle.bubble.radius;
                    }
                    if (type === Enums_1.ProcessBubbleType.opacity) {
                        delete particle.bubble.opacity;
                    }
                }
            }
            else if (pObjBubble) {
                if (type === Enums_1.ProcessBubbleType.size) {
                    delete particle.bubble.radius;
                }
                if (type === Enums_1.ProcessBubbleType.opacity) {
                    delete particle.bubble.opacity;
                }
            }
        }
    }
    clickBubble() {
        var _a;
        const container = this.container;
        const options = container.options;
        const mouseClickPos = container.interactivity.mouse.clickPosition;
        if (mouseClickPos === undefined) {
            return;
        }
        const distance = container.retina.bubbleModeDistance;
        const query = container.particles.quadTree.queryCircle(mouseClickPos, distance);
        for (const particle of query) {
            if (!container.bubble.clicking) {
                continue;
            }
            particle.bubble.inRange = !container.bubble.durationEnd;
            const pos = particle.getPosition();
            const distMouse = Utils_1.NumberUtils.getDistance(pos, mouseClickPos);
            const timeSpent = (new Date().getTime() - (container.interactivity.mouse.clickTime || 0)) / 1000;
            if (timeSpent > options.interactivity.modes.bubble.duration) {
                container.bubble.durationEnd = true;
            }
            if (timeSpent > options.interactivity.modes.bubble.duration * 2) {
                container.bubble.clicking = false;
                container.bubble.durationEnd = false;
            }
            const sizeData = {
                bubbleObj: {
                    optValue: container.retina.bubbleModeSize,
                    value: particle.bubble.radius,
                },
                particlesObj: {
                    optValue: (_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue,
                    value: particle.size.value,
                },
                type: Enums_1.ProcessBubbleType.size,
            };
            this.process(particle, distMouse, timeSpent, sizeData);
            const opacityData = {
                bubbleObj: {
                    optValue: options.interactivity.modes.bubble.opacity,
                    value: particle.bubble.opacity,
                },
                particlesObj: {
                    optValue: particle.particlesOptions.opacity.value,
                    value: particle.opacity.value,
                },
                type: Enums_1.ProcessBubbleType.opacity,
            };
            this.process(particle, distMouse, timeSpent, opacityData);
            if (!container.bubble.durationEnd) {
                if (distMouse <= container.retina.bubbleModeDistance) {
                    this.hoverBubbleColor(particle);
                }
                else {
                    delete particle.bubble.color;
                }
            }
            else {
                delete particle.bubble.color;
            }
        }
    }
    hoverBubble() {
        const container = this.container;
        const mousePos = container.interactivity.mouse.position;
        if (mousePos === undefined) {
            return;
        }
        const distance = container.retina.bubbleModeDistance;
        const query = container.particles.quadTree.queryCircle(mousePos, distance);
        for (const particle of query) {
            particle.bubble.inRange = true;
            const pos = particle.getPosition();
            const pointDistance = Utils_1.NumberUtils.getDistance(pos, mousePos);
            const ratio = 1 - pointDistance / distance;
            if (pointDistance <= distance) {
                if (ratio >= 0 && container.interactivity.status === Utils_1.Constants.mouseMoveEvent) {
                    this.hoverBubbleSize(particle, ratio);
                    this.hoverBubbleOpacity(particle, ratio);
                    this.hoverBubbleColor(particle);
                }
            }
            else {
                this.reset(particle);
            }
            if (container.interactivity.status === Utils_1.Constants.mouseLeaveEvent) {
                this.reset(particle);
            }
        }
    }
    hoverBubbleSize(particle, ratio, divBubble) {
        var _a;
        const container = this.container;
        const modeSize = (divBubble === null || divBubble === void 0 ? void 0 : divBubble.size) ? divBubble.size * container.retina.pixelRatio
            : container.retina.bubbleModeSize;
        if (modeSize === undefined) {
            return;
        }
        const optSize = (_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue;
        const pSize = particle.size.value;
        const size = calculateBubbleValue(pSize, modeSize, optSize, ratio);
        if (size !== undefined) {
            particle.bubble.radius = size;
        }
    }
    hoverBubbleOpacity(particle, ratio, divBubble) {
        var _a;
        const options = this.container.options;
        const modeOpacity = (_a = divBubble === null || divBubble === void 0 ? void 0 : divBubble.opacity) !== null && _a !== void 0 ? _a : options.interactivity.modes.bubble.opacity;
        if (modeOpacity === undefined) {
            return;
        }
        const optOpacity = particle.particlesOptions.opacity.value;
        const pOpacity = particle.opacity.value;
        const opacity = calculateBubbleValue(pOpacity, modeOpacity, optOpacity, ratio);
        if (opacity !== undefined) {
            particle.bubble.opacity = opacity;
        }
    }
    hoverBubbleColor(particle, divBubble) {
        var _a;
        const options = this.container.options;
        if (particle.bubble.color === undefined) {
            const modeColor = (_a = divBubble === null || divBubble === void 0 ? void 0 : divBubble.color) !== null && _a !== void 0 ? _a : options.interactivity.modes.bubble.color;
            if (modeColor === undefined) {
                return;
            }
            const bubbleColor = modeColor instanceof Array ? Utils_1.Utils.itemFromArray(modeColor) : modeColor;
            particle.bubble.color = Utils_1.ColorUtils.colorToHsl(bubbleColor);
        }
    }
}
exports.Bubbler = Bubbler;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Connector.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Connector.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Connector = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Modes_1 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class Connector {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        const container = this.container;
        const mouse = container.interactivity.mouse;
        const events = container.options.interactivity.events;
        if (!(events.onHover.enable && mouse.position)) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        return Utils_1.Utils.isInArray(Modes_1.HoverMode.connect, hoverMode);
    }
    reset() {
    }
    interact() {
        const container = this.container;
        const options = container.options;
        if (options.interactivity.events.onHover.enable && container.interactivity.status === "mousemove") {
            const mousePos = container.interactivity.mouse.position;
            if (!mousePos) {
                return;
            }
            const distance = Math.abs(container.retina.connectModeRadius);
            const query = container.particles.quadTree.queryCircle(mousePos, distance);
            let i = 0;
            for (const p1 of query) {
                const pos1 = p1.getPosition();
                for (const p2 of query.slice(i + 1)) {
                    const pos2 = p2.getPosition();
                    const distMax = Math.abs(container.retina.connectModeDistance);
                    const xDiff = Math.abs(pos1.x - pos2.x);
                    const yDiff = Math.abs(pos1.y - pos2.y);
                    if (xDiff < distMax && yDiff < distMax) {
                        container.canvas.drawConnectLine(p1, p2);
                    }
                }
                ++i;
            }
        }
    }
}
exports.Connector = Connector;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Grabber.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Grabber.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Grabber = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Modes_1 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class Grabber {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        const container = this.container;
        const mouse = container.interactivity.mouse;
        const events = container.options.interactivity.events;
        if (!(events.onHover.enable && mouse.position)) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        return Utils_1.Utils.isInArray(Modes_1.HoverMode.grab, hoverMode);
    }
    reset() {
    }
    interact() {
        var _a;
        const container = this.container;
        const options = container.options;
        const interactivity = options.interactivity;
        if (interactivity.events.onHover.enable && container.interactivity.status === Utils_1.Constants.mouseMoveEvent) {
            const mousePos = container.interactivity.mouse.position;
            if (mousePos === undefined) {
                return;
            }
            const distance = container.retina.grabModeDistance;
            const query = container.particles.quadTree.queryCircle(mousePos, distance);
            for (const particle of query) {
                const pos = particle.getPosition();
                const pointDistance = Utils_1.NumberUtils.getDistance(pos, mousePos);
                if (pointDistance <= distance) {
                    const grabLineOptions = interactivity.modes.grab.links;
                    const lineOpacity = grabLineOptions.opacity;
                    const opacityLine = lineOpacity - (pointDistance * lineOpacity) / distance;
                    if (opacityLine > 0) {
                        const optColor = (_a = grabLineOptions.color) !== null && _a !== void 0 ? _a : particle.particlesOptions.links.color;
                        if (!container.particles.grabLineColor) {
                            const linksOptions = container.options.interactivity.modes.grab.links;
                            container.particles.grabLineColor = Utils_1.ColorUtils.getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);
                        }
                        const colorLine = Utils_1.ColorUtils.getLinkColor(particle, undefined, container.particles.grabLineColor);
                        if (colorLine === undefined) {
                            return;
                        }
                        container.canvas.drawGrabLine(particle, colorLine, opacityLine, mousePos);
                    }
                }
            }
        }
    }
}
exports.Grabber = Grabber;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Lighter.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Lighter.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Lighter = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Modes_1 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class Lighter {
    constructor(container) {
        this.container = container;
    }
    interact() {
        const container = this.container;
        const options = container.options;
        if (options.interactivity.events.onHover.enable && container.interactivity.status === "mousemove") {
            const mousePos = container.interactivity.mouse.position;
            if (!mousePos) {
                return;
            }
            container.canvas.drawLight(mousePos);
        }
    }
    isEnabled() {
        const container = this.container;
        const mouse = container.interactivity.mouse;
        const events = container.options.interactivity.events;
        if (!(events.onHover.enable && mouse.position)) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        return Utils_1.Utils.isInArray(Modes_1.HoverMode.light, hoverMode);
    }
    reset() {
    }
}
exports.Lighter = Lighter;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Repulser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Repulser.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Repulser = void 0;
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Repulser {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        const container = this.container;
        const options = container.options;
        const mouse = container.interactivity.mouse;
        const events = options.interactivity.events;
        const divs = events.onDiv;
        const divRepulse = Utils_1.Utils.isDivModeEnabled(Enums_1.DivMode.repulse, divs);
        if (!(divRepulse || (events.onHover.enable && mouse.position) || (events.onClick.enable && mouse.clickPosition))) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        const clickMode = events.onClick.mode;
        return (Utils_1.Utils.isInArray(Enums_1.HoverMode.repulse, hoverMode) || Utils_1.Utils.isInArray(Enums_1.ClickMode.repulse, clickMode) || divRepulse);
    }
    reset() {
    }
    interact() {
        const container = this.container;
        const options = container.options;
        const mouseMoveStatus = container.interactivity.status === Utils_1.Constants.mouseMoveEvent;
        const events = options.interactivity.events;
        const hoverEnabled = events.onHover.enable;
        const hoverMode = events.onHover.mode;
        const clickEnabled = events.onClick.enable;
        const clickMode = events.onClick.mode;
        const divs = events.onDiv;
        if (mouseMoveStatus && hoverEnabled && Utils_1.Utils.isInArray(Enums_1.HoverMode.repulse, hoverMode)) {
            this.hoverRepulse();
        }
        else if (clickEnabled && Utils_1.Utils.isInArray(Enums_1.ClickMode.repulse, clickMode)) {
            this.clickRepulse();
        }
        else {
            Utils_1.Utils.divModeExecute(Enums_1.DivMode.repulse, divs, (selector, div) => this.singleSelectorRepulse(selector, div));
        }
    }
    singleSelectorRepulse(selector, div) {
        const container = this.container;
        const query = document.querySelectorAll(selector);
        if (!query.length) {
            return;
        }
        query.forEach((item) => {
            const elem = item;
            const pxRatio = container.retina.pixelRatio;
            const pos = {
                x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,
                y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio,
            };
            const repulseRadius = (elem.offsetWidth / 2) * pxRatio;
            const area = div.type === Enums_1.DivType.circle
                ? new Utils_1.Circle(pos.x, pos.y, repulseRadius)
                : new Utils_1.Rectangle(elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio);
            const divs = container.options.interactivity.modes.repulse.divs;
            const divRepulse = Utils_1.Utils.divMode(divs, elem);
            this.processRepulse(pos, repulseRadius, area, divRepulse);
        });
    }
    hoverRepulse() {
        const container = this.container;
        const mousePos = container.interactivity.mouse.position;
        if (!mousePos) {
            return;
        }
        const repulseRadius = container.retina.repulseModeDistance;
        this.processRepulse(mousePos, repulseRadius, new Utils_1.Circle(mousePos.x, mousePos.y, repulseRadius));
    }
    processRepulse(position, repulseRadius, area, divRepulse) {
        var _a;
        const container = this.container;
        const query = container.particles.quadTree.query(area);
        for (const particle of query) {
            const { dx, dy, distance } = Utils_1.NumberUtils.getDistances(particle.position, position);
            const normVec = {
                x: dx / distance,
                y: dy / distance,
            };
            const velocity = ((_a = divRepulse === null || divRepulse === void 0 ? void 0 : divRepulse.speed) !== null && _a !== void 0 ? _a : container.options.interactivity.modes.repulse.speed) * 100;
            const repulseFactor = Utils_1.NumberUtils.clamp((1 - Math.pow(distance / repulseRadius, 2)) * velocity, 0, 50);
            particle.position.x = particle.position.x + normVec.x * repulseFactor;
            particle.position.y = particle.position.y + normVec.y * repulseFactor;
        }
    }
    clickRepulse() {
        const container = this.container;
        if (!container.repulse.finish) {
            if (!container.repulse.count) {
                container.repulse.count = 0;
            }
            container.repulse.count++;
            if (container.repulse.count === container.particles.count) {
                container.repulse.finish = true;
            }
        }
        if (container.repulse.clicking) {
            const repulseDistance = container.retina.repulseModeDistance;
            const repulseRadius = Math.pow(repulseDistance / 6, 3);
            const mouseClickPos = container.interactivity.mouse.clickPosition;
            if (mouseClickPos === undefined) {
                return;
            }
            const range = new Utils_1.Circle(mouseClickPos.x, mouseClickPos.y, repulseRadius);
            const query = container.particles.quadTree.query(range);
            for (const particle of query) {
                const { dx, dy, distance } = Utils_1.NumberUtils.getDistances(mouseClickPos, particle.position);
                const d = distance * distance;
                const velocity = container.options.interactivity.modes.repulse.speed;
                const force = (-repulseRadius * velocity) / d;
                if (d <= repulseRadius) {
                    container.repulse.particles.push(particle);
                    const angle = Math.atan2(dy, dx);
                    particle.velocity.horizontal = force * Math.cos(angle);
                    particle.velocity.vertical = force * Math.sin(angle);
                }
            }
        }
        else if (container.repulse.clicking === false) {
            for (const particle of container.repulse.particles) {
                particle.velocity.horizontal = particle.initialVelocity.horizontal;
                particle.velocity.vertical = particle.initialVelocity.vertical;
            }
            container.repulse.particles = [];
        }
    }
}
exports.Repulser = Repulser;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/TrailMaker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/TrailMaker.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TrailMaker = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Modes_1 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class TrailMaker {
    constructor(container) {
        this.container = container;
        this.delay = 0;
    }
    interact(delta) {
        if (!this.container.retina.reduceFactor) {
            return;
        }
        const container = this.container;
        const options = container.options;
        const trailOptions = options.interactivity.modes.trail;
        const optDelay = (trailOptions.delay * 1000) / this.container.retina.reduceFactor;
        if (this.delay < optDelay) {
            this.delay += delta.value;
        }
        if (this.delay >= optDelay) {
            container.particles.push(trailOptions.quantity, container.interactivity.mouse, trailOptions.particles);
            this.delay -= optDelay;
        }
    }
    isEnabled() {
        const container = this.container;
        const options = container.options;
        const mouse = container.interactivity.mouse;
        const events = options.interactivity.events;
        return ((mouse.clicking &&
            mouse.inside &&
            !!mouse.position &&
            Utils_1.Utils.isInArray(Modes_1.ClickMode.trail, events.onClick.mode)) ||
            (mouse.inside && !!mouse.position && Utils_1.Utils.isInArray(Modes_1.HoverMode.trail, events.onHover.mode)));
    }
    reset() {
    }
}
exports.TrailMaker = TrailMaker;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/Particles/Attractor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/Particles/Attractor.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Attractor = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Attractor {
    constructor(container) {
        this.container = container;
    }
    interact(p1) {
        var _a;
        const container = this.container;
        const distance = (_a = p1.linksDistance) !== null && _a !== void 0 ? _a : container.retina.linksDistance;
        const pos1 = p1.getPosition();
        const query = container.particles.quadTree.queryCircle(pos1, distance);
        for (const p2 of query) {
            if (p1 === p2 || !p2.particlesOptions.move.attract.enable || p2.destroyed || p2.spawning) {
                continue;
            }
            const pos2 = p2.getPosition();
            const { dx, dy } = Utils_1.NumberUtils.getDistances(pos1, pos2);
            const rotate = p1.particlesOptions.move.attract.rotate;
            const ax = dx / (rotate.x * 1000);
            const ay = dy / (rotate.y * 1000);
            p1.velocity.horizontal -= ax;
            p1.velocity.vertical -= ay;
            p2.velocity.horizontal += ax;
            p2.velocity.vertical += ay;
        }
    }
    isEnabled(particle) {
        return particle.particlesOptions.move.attract.enable;
    }
    reset() {
    }
}
exports.Attractor = Attractor;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/Particles/Collider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/Particles/Collider.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Collider = void 0;
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
function bounce(p1, p2) {
    Utils_1.Utils.circleBounce(Utils_1.Utils.circleBounceDataFromParticle(p1), Utils_1.Utils.circleBounceDataFromParticle(p2));
}
function destroy(p1, p2) {
    if (p1.getRadius() === undefined && p2.getRadius() !== undefined) {
        p1.destroy();
    }
    else if (p1.getRadius() !== undefined && p2.getRadius() === undefined) {
        p2.destroy();
    }
    else if (p1.getRadius() !== undefined && p2.getRadius() !== undefined) {
        if (p1.getRadius() >= p2.getRadius()) {
            p2.destroy();
        }
        else {
            p1.destroy();
        }
    }
}
class Collider {
    constructor(container) {
        this.container = container;
    }
    isEnabled(particle) {
        return particle.particlesOptions.collisions.enable;
    }
    reset() {
    }
    interact(p1) {
        const container = this.container;
        const pos1 = p1.getPosition();
        const query = container.particles.quadTree.queryCircle(pos1, p1.getRadius() * 2);
        for (const p2 of query) {
            if (p1 === p2 ||
                !p2.particlesOptions.collisions.enable ||
                p1.particlesOptions.collisions.mode !== p2.particlesOptions.collisions.mode ||
                p2.destroyed ||
                p2.spawning) {
                continue;
            }
            const pos2 = p2.getPosition();
            const dist = Utils_1.NumberUtils.getDistance(pos1, pos2);
            const radius1 = p1.getRadius();
            const radius2 = p2.getRadius();
            const distP = radius1 + radius2;
            if (dist <= distP) {
                this.resolveCollision(p1, p2);
            }
        }
    }
    resolveCollision(p1, p2) {
        switch (p1.particlesOptions.collisions.mode) {
            case Enums_1.CollisionMode.absorb: {
                this.absorb(p1, p2);
                break;
            }
            case Enums_1.CollisionMode.bounce: {
                bounce(p1, p2);
                break;
            }
            case Enums_1.CollisionMode.destroy: {
                destroy(p1, p2);
                break;
            }
        }
    }
    absorb(p1, p2) {
        const container = this.container;
        const fps = container.options.fpsLimit / 1000;
        if (p1.getRadius() === undefined && p2.getRadius() !== undefined) {
            p1.destroy();
        }
        else if (p1.getRadius() !== undefined && p2.getRadius() === undefined) {
            p2.destroy();
        }
        else if (p1.getRadius() !== undefined && p2.getRadius() !== undefined) {
            if (p1.getRadius() >= p2.getRadius()) {
                const factor = Utils_1.NumberUtils.clamp(p1.getRadius() / p2.getRadius(), 0, p2.getRadius()) * fps;
                p1.size.value += factor;
                p2.size.value -= factor;
                if (p2.getRadius() <= container.retina.pixelRatio) {
                    p2.size.value = 0;
                    p2.destroy();
                }
            }
            else {
                const factor = Utils_1.NumberUtils.clamp(p2.getRadius() / p1.getRadius(), 0, p1.getRadius()) * fps;
                p1.size.value -= factor;
                p2.size.value += factor;
                if (p1.getRadius() <= container.retina.pixelRatio) {
                    p1.size.value = 0;
                    p1.destroy();
                }
            }
        }
    }
}
exports.Collider = Collider;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/Particles/Infecter.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/Particles/Infecter.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Infecter = void 0;
class Infecter {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        return this.container.options.infection.enable;
    }
    reset() {
    }
    interact(p1, delta) {
        var _a, _b;
        const infecter1 = p1.infecter;
        infecter1.updateInfection(delta.value);
        if (infecter1.infectionStage === undefined) {
            return;
        }
        const container = this.container;
        const options = container.options;
        const infectionOptions = options.infection;
        if (!infectionOptions.enable || infectionOptions.stages.length < 1) {
            return;
        }
        const infectionStage1 = infectionOptions.stages[infecter1.infectionStage];
        const pxRatio = container.retina.pixelRatio;
        const radius = p1.getRadius() * 2 + infectionStage1.radius * pxRatio;
        const pos = p1.getPosition();
        const infectedStage1 = (_a = infectionStage1.infectedStage) !== null && _a !== void 0 ? _a : infecter1.infectionStage;
        const query = container.particles.quadTree.queryCircle(pos, radius);
        const infections = infectionStage1.rate;
        const neighbors = query.length;
        for (const p2 of query) {
            if (p2 === p1 ||
                p2.destroyed ||
                p2.spawning ||
                !(p2.infecter.infectionStage === undefined || p2.infecter.infectionStage !== infecter1.infectionStage)) {
                continue;
            }
            const infecter2 = p2.infecter;
            if (Math.random() < infections / neighbors) {
                if (infecter2.infectionStage === undefined) {
                    infecter2.startInfection(infectedStage1);
                }
                else if (infecter2.infectionStage < infecter1.infectionStage) {
                    infecter2.updateInfectionStage(infectedStage1);
                }
                else if (infecter2.infectionStage > infecter1.infectionStage) {
                    const infectionStage2 = infectionOptions.stages[infecter2.infectionStage];
                    const infectedStage2 = (_b = infectionStage2 === null || infectionStage2 === void 0 ? void 0 : infectionStage2.infectedStage) !== null && _b !== void 0 ? _b : infecter2.infectionStage;
                    infecter1.updateInfectionStage(infectedStage2);
                }
            }
        }
    }
}
exports.Infecter = Infecter;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/Particles/Lighter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/Particles/Lighter.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Lighter = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Modes_1 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class Lighter {
    constructor(container) {
        this.container = container;
    }
    interact(particle) {
        const container = this.container;
        const options = container.options;
        if (options.interactivity.events.onHover.enable && container.interactivity.status === "mousemove") {
            const mousePos = this.container.interactivity.mouse.position;
            if (mousePos) {
                container.canvas.drawParticleShadow(particle, mousePos);
            }
        }
    }
    isEnabled() {
        const container = this.container;
        const mouse = container.interactivity.mouse;
        const events = container.options.interactivity.events;
        if (!(events.onHover.enable && mouse.position)) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        return Utils_1.Utils.isInArray(Modes_1.HoverMode.light, hoverMode);
    }
    reset() {
    }
}
exports.Lighter = Lighter;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/Particles/Linker.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/Particles/Linker.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Linker = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Linker {
    constructor(container) {
        this.container = container;
    }
    isEnabled(particle) {
        return particle.particlesOptions.links.enable;
    }
    reset() {
    }
    interact(p1) {
        var _a;
        const container = this.container;
        const linkOpt1 = p1.particlesOptions.links;
        const optOpacity = linkOpt1.opacity;
        const optDistance = (_a = p1.linksDistance) !== null && _a !== void 0 ? _a : container.retina.linksDistance;
        const canvasSize = container.canvas.size;
        const warp = linkOpt1.warp;
        const pos1 = p1.getPosition();
        const range = warp
            ? new Utils_1.CircleWarp(pos1.x, pos1.y, optDistance, canvasSize)
            : new Utils_1.Circle(pos1.x, pos1.y, optDistance);
        const query = container.particles.quadTree.query(range);
        for (const p2 of query) {
            const linkOpt2 = p2.particlesOptions.links;
            if (p1 === p2 || !linkOpt2.enable || linkOpt1.id !== linkOpt2.id || p2.spawning || p2.destroyed) {
                continue;
            }
            const pos2 = p2.getPosition();
            let distance = Utils_1.NumberUtils.getDistance(pos1, pos2);
            if (warp) {
                if (distance > optDistance) {
                    const pos2NE = {
                        x: pos2.x - canvasSize.width,
                        y: pos2.y,
                    };
                    distance = Utils_1.NumberUtils.getDistance(pos1, pos2NE);
                    if (distance > optDistance) {
                        const pos2SE = {
                            x: pos2.x - canvasSize.width,
                            y: pos2.y - canvasSize.height,
                        };
                        distance = Utils_1.NumberUtils.getDistance(pos1, pos2SE);
                        if (distance > optDistance) {
                            const pos2SW = {
                                x: pos2.x,
                                y: pos2.y - canvasSize.height,
                            };
                            distance = Utils_1.NumberUtils.getDistance(pos1, pos2SW);
                        }
                    }
                }
            }
            if (distance > optDistance) {
                return;
            }
            const opacityLine = (1 - distance / optDistance) * optOpacity;
            const linksOptions = p1.particlesOptions.links;
            let linkColor = linksOptions.id !== undefined
                ? container.particles.linksColors.get(linksOptions.id)
                : container.particles.linksColor;
            if (!linkColor) {
                const optColor = linksOptions.color;
                linkColor = Utils_1.ColorUtils.getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);
                if (linksOptions.id !== undefined) {
                    container.particles.linksColors.set(linksOptions.id, linkColor);
                }
                else {
                    container.particles.linksColor = linkColor;
                }
            }
            if (p2.links.map((t) => t.destination).indexOf(p1) === -1 &&
                p1.links.map((t) => t.destination).indexOf(p2) === -1) {
                p1.links.push({
                    destination: p2,
                    opacity: opacityLine,
                });
            }
        }
    }
}
exports.Linker = Linker;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Background/Background.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Background/Background.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Background = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class Background {
    constructor() {
        this.color = new OptionsColor_1.OptionsColor();
        this.color.value = "";
        this.image = "";
        this.position = "";
        this.repeat = "";
        this.size = "";
        this.opacity = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        if (data.image !== undefined) {
            this.image = data.image;
        }
        if (data.position !== undefined) {
            this.position = data.position;
        }
        if (data.repeat !== undefined) {
            this.repeat = data.repeat;
        }
        if (data.size !== undefined) {
            this.size = data.size;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}
exports.Background = Background;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/BackgroundMask/BackgroundMask.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/BackgroundMask/BackgroundMask.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BackgroundMask = void 0;
const BackgroundMaskCover_1 = __webpack_require__(/*! ./BackgroundMaskCover */ "./node_modules/tsparticles/dist/Options/Classes/BackgroundMask/BackgroundMaskCover.js");
class BackgroundMask {
    constructor() {
        this.composite = "destination-out";
        this.cover = new BackgroundMaskCover_1.BackgroundMaskCover();
        this.enable = false;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.composite !== undefined) {
            this.composite = data.composite;
        }
        if (data.cover !== undefined) {
            const cover = data.cover;
            const color = (typeof data.cover === "string" ? { color: data.cover } : data.cover);
            this.cover.load(cover.color !== undefined ? cover : { color: color });
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
    }
}
exports.BackgroundMask = BackgroundMask;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/BackgroundMask/BackgroundMaskCover.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/BackgroundMask/BackgroundMaskCover.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BackgroundMaskCover = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class BackgroundMaskCover {
    constructor() {
        this.color = new OptionsColor_1.OptionsColor();
        this.opacity = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}
exports.BackgroundMaskCover = BackgroundMaskCover;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/BackgroundMode/BackgroundMode.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/BackgroundMode/BackgroundMode.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BackgroundMode = void 0;
class BackgroundMode {
    constructor() {
        this.enable = false;
        this.zIndex = -1;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.zIndex !== undefined) {
            this.zIndex = data.zIndex;
        }
    }
}
exports.BackgroundMode = BackgroundMode;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Infection/Infection.js":
/*!******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Infection/Infection.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Infection = void 0;
const InfectionStage_1 = __webpack_require__(/*! ./InfectionStage */ "./node_modules/tsparticles/dist/Options/Classes/Infection/InfectionStage.js");
class Infection {
    constructor() {
        this.cure = false;
        this.delay = 0;
        this.enable = false;
        this.infections = 0;
        this.stages = [];
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.cure !== undefined) {
            this.cure = data.cure;
        }
        if (data.delay !== undefined) {
            this.delay = data.delay;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.infections !== undefined) {
            this.infections = data.infections;
        }
        if (data.stages === undefined) {
            return;
        }
        this.stages = data.stages.map((t) => {
            const s = new InfectionStage_1.InfectionStage();
            s.load(t);
            return s;
        });
    }
}
exports.Infection = Infection;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Infection/InfectionStage.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Infection/InfectionStage.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InfectionStage = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class InfectionStage {
    constructor() {
        this.color = new OptionsColor_1.OptionsColor();
        this.color.value = "#ff0000";
        this.radius = 0;
        this.rate = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        this.duration = data.duration;
        this.infectedStage = data.infectedStage;
        if (data.radius !== undefined) {
            this.radius = data.radius;
        }
        if (data.rate !== undefined) {
            this.rate = data.rate;
        }
    }
}
exports.InfectionStage = InfectionStage;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/ClickEvent.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/ClickEvent.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ClickEvent = void 0;
class ClickEvent {
    constructor() {
        this.enable = false;
        this.mode = [];
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
    }
}
exports.ClickEvent = ClickEvent;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/DivEvent.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/DivEvent.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DivEvent = void 0;
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
class DivEvent {
    constructor() {
        this.selectors = [];
        this.enable = false;
        this.mode = [];
        this.type = Enums_1.DivType.circle;
    }
    get elementId() {
        return this.ids;
    }
    set elementId(value) {
        this.ids = value;
    }
    get el() {
        return this.elementId;
    }
    set el(value) {
        this.elementId = value;
    }
    get ids() {
        if (this.selectors instanceof Array) {
            return this.selectors.map((t) => t.replace("#", ""));
        }
        else {
            return this.selectors.replace("#", "");
        }
    }
    set ids(value) {
        if (value instanceof Array) {
            this.selectors = value.map((t) => `#${t}`);
        }
        else {
            this.selectors = `#${value}`;
        }
    }
    load(data) {
        var _a, _b;
        if (data === undefined) {
            return;
        }
        const ids = (_b = (_a = data.ids) !== null && _a !== void 0 ? _a : data.elementId) !== null && _b !== void 0 ? _b : data.el;
        if (ids !== undefined) {
            this.ids = ids;
        }
        if (data.selectors !== undefined) {
            this.selectors = data.selectors;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
        if (data.type !== undefined) {
            this.type = data.type;
        }
    }
}
exports.DivEvent = DivEvent;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/Events.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/Events.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = void 0;
const ClickEvent_1 = __webpack_require__(/*! ./ClickEvent */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/ClickEvent.js");
const DivEvent_1 = __webpack_require__(/*! ./DivEvent */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/DivEvent.js");
const HoverEvent_1 = __webpack_require__(/*! ./HoverEvent */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/HoverEvent.js");
class Events {
    constructor() {
        this.onClick = new ClickEvent_1.ClickEvent();
        this.onDiv = new DivEvent_1.DivEvent();
        this.onHover = new HoverEvent_1.HoverEvent();
        this.resize = true;
    }
    get onclick() {
        return this.onClick;
    }
    set onclick(value) {
        this.onClick = value;
    }
    get ondiv() {
        return this.onDiv;
    }
    set ondiv(value) {
        this.onDiv = value;
    }
    get onhover() {
        return this.onHover;
    }
    set onhover(value) {
        this.onHover = value;
    }
    load(data) {
        var _a, _b, _c;
        if (data === undefined) {
            return;
        }
        this.onClick.load((_a = data.onClick) !== null && _a !== void 0 ? _a : data.onclick);
        const onDiv = (_b = data.onDiv) !== null && _b !== void 0 ? _b : data.ondiv;
        if (onDiv !== undefined) {
            if (onDiv instanceof Array) {
                this.onDiv = onDiv.map((div) => {
                    const tmp = new DivEvent_1.DivEvent();
                    tmp.load(div);
                    return tmp;
                });
            }
            else {
                this.onDiv = new DivEvent_1.DivEvent();
                this.onDiv.load(onDiv);
            }
        }
        this.onHover.load((_c = data.onHover) !== null && _c !== void 0 ? _c : data.onhover);
        if (data.resize !== undefined) {
            this.resize = data.resize;
        }
    }
}
exports.Events = Events;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/HoverEvent.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/HoverEvent.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HoverEvent = void 0;
const Parallax_1 = __webpack_require__(/*! ./Parallax */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/Parallax.js");
class HoverEvent {
    constructor() {
        this.enable = false;
        this.mode = [];
        this.parallax = new Parallax_1.Parallax();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
        this.parallax.load(data.parallax);
    }
}
exports.HoverEvent = HoverEvent;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/Parallax.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/Parallax.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Parallax = void 0;
class Parallax {
    constructor() {
        this.enable = false;
        this.force = 2;
        this.smooth = 10;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.force !== undefined) {
            this.force = data.force;
        }
        if (data.smooth !== undefined) {
            this.smooth = data.smooth;
        }
    }
}
exports.Parallax = Parallax;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Interactivity.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Interactivity.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Interactivity = void 0;
const Enums_1 = __webpack_require__(/*! ../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Events_1 = __webpack_require__(/*! ./Events/Events */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/Events.js");
const Modes_1 = __webpack_require__(/*! ./Modes/Modes */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Modes.js");
class Interactivity {
    constructor() {
        this.detectsOn = Enums_1.InteractivityDetect.canvas;
        this.events = new Events_1.Events();
        this.modes = new Modes_1.Modes();
    }
    get detect_on() {
        return this.detectsOn;
    }
    set detect_on(value) {
        this.detectsOn = value;
    }
    load(data) {
        var _a, _b, _c;
        if (data === undefined) {
            return;
        }
        const detectsOn = (_a = data.detectsOn) !== null && _a !== void 0 ? _a : data.detect_on;
        if (detectsOn !== undefined) {
            this.detectsOn = detectsOn;
        }
        this.events.load(data.events);
        this.modes.load(data.modes);
        if (((_c = (_b = data.modes) === null || _b === void 0 ? void 0 : _b.slow) === null || _c === void 0 ? void 0 : _c.active) === true) {
            if (this.events.onHover.mode instanceof Array) {
                if (this.events.onHover.mode.indexOf(Enums_1.HoverMode.slow) < 0) {
                    this.events.onHover.mode.push(Enums_1.HoverMode.slow);
                }
            }
            else if (this.events.onHover.mode !== Enums_1.HoverMode.slow) {
                this.events.onHover.mode = [this.events.onHover.mode, Enums_1.HoverMode.slow];
            }
        }
    }
}
exports.Interactivity = Interactivity;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Attract.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Attract.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Attract = void 0;
class Attract {
    constructor() {
        this.distance = 200;
        this.duration = 0.4;
        this.speed = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.duration !== undefined) {
            this.duration = data.duration;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
    }
}
exports.Attract = Attract;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Bounce.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Bounce.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Bounce = void 0;
class Bounce {
    constructor() {
        this.distance = 200;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
    }
}
exports.Bounce = Bounce;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Bubble.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Bubble.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Bubble = void 0;
const BubbleDiv_1 = __webpack_require__(/*! ./BubbleDiv */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleDiv.js");
const BubbleBase_1 = __webpack_require__(/*! ./BubbleBase */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleBase.js");
class Bubble extends BubbleBase_1.BubbleBase {
    load(data) {
        super.load(data);
        if (!(data !== undefined && data.divs !== undefined)) {
            return;
        }
        if (data.divs instanceof Array) {
            this.divs = data.divs.map((s) => {
                const tmp = new BubbleDiv_1.BubbleDiv();
                tmp.load(s);
                return tmp;
            });
        }
        else {
            if (this.divs instanceof Array || !this.divs) {
                this.divs = new BubbleDiv_1.BubbleDiv();
            }
            this.divs.load(data.divs);
        }
    }
}
exports.Bubble = Bubble;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleBase.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleBase.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BubbleBase = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class BubbleBase {
    constructor() {
        this.distance = 200;
        this.duration = 0.4;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.duration !== undefined) {
            this.duration = data.duration;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
        if (data.color !== undefined) {
            if (data.color instanceof Array) {
                this.color = data.color.map((s) => OptionsColor_1.OptionsColor.create(undefined, s));
            }
            else {
                if (this.color instanceof Array) {
                    this.color = new OptionsColor_1.OptionsColor();
                }
                this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
            }
        }
        if (data.size !== undefined) {
            this.size = data.size;
        }
    }
}
exports.BubbleBase = BubbleBase;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleDiv.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleDiv.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BubbleDiv = void 0;
const BubbleBase_1 = __webpack_require__(/*! ./BubbleBase */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleBase.js");
class BubbleDiv extends BubbleBase_1.BubbleBase {
    constructor() {
        super();
        this.selectors = [];
    }
    get ids() {
        if (this.selectors instanceof Array) {
            return this.selectors.map((t) => t.replace("#", ""));
        }
        else {
            return this.selectors.replace("#", "");
        }
    }
    set ids(value) {
        if (value instanceof Array) {
            this.selectors = value.map((t) => `#${t}`);
        }
        else {
            this.selectors = `#${value}`;
        }
    }
    load(data) {
        super.load(data);
        if (data === undefined) {
            return;
        }
        if (data.ids !== undefined) {
            this.ids = data.ids;
        }
        if (data.selectors !== undefined) {
            this.selectors = data.selectors;
        }
    }
}
exports.BubbleDiv = BubbleDiv;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Connect.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Connect.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Connect = void 0;
const ConnectLinks_1 = __webpack_require__(/*! ./ConnectLinks */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/ConnectLinks.js");
class Connect {
    constructor() {
        this.distance = 80;
        this.links = new ConnectLinks_1.ConnectLinks();
        this.radius = 60;
    }
    get line_linked() {
        return this.links;
    }
    set line_linked(value) {
        this.links = value;
    }
    get lineLinked() {
        return this.links;
    }
    set lineLinked(value) {
        this.links = value;
    }
    load(data) {
        var _a, _b;
        if (data === undefined) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        this.links.load((_b = (_a = data.links) !== null && _a !== void 0 ? _a : data.lineLinked) !== null && _b !== void 0 ? _b : data.line_linked);
        if (data.radius !== undefined) {
            this.radius = data.radius;
        }
    }
}
exports.Connect = Connect;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/ConnectLinks.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/ConnectLinks.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectLinks = void 0;
class ConnectLinks {
    constructor() {
        this.opacity = 0.5;
    }
    load(data) {
        if (!(data !== undefined && data.opacity !== undefined)) {
            return;
        }
        this.opacity = data.opacity;
    }
}
exports.ConnectLinks = ConnectLinks;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Grab.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Grab.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Grab = void 0;
const GrabLinks_1 = __webpack_require__(/*! ./GrabLinks */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/GrabLinks.js");
class Grab {
    constructor() {
        this.distance = 100;
        this.links = new GrabLinks_1.GrabLinks();
    }
    get line_linked() {
        return this.links;
    }
    set line_linked(value) {
        this.links = value;
    }
    get lineLinked() {
        return this.links;
    }
    set lineLinked(value) {
        this.links = value;
    }
    load(data) {
        var _a, _b;
        if (data === undefined) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        this.links.load((_b = (_a = data.links) !== null && _a !== void 0 ? _a : data.lineLinked) !== null && _b !== void 0 ? _b : data.line_linked);
    }
}
exports.Grab = Grab;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/GrabLinks.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/GrabLinks.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GrabLinks = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class GrabLinks {
    constructor() {
        this.blink = false;
        this.consent = false;
        this.opacity = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.blink !== undefined) {
            this.blink = data.blink;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        if (data.consent !== undefined) {
            this.consent = data.consent;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}
exports.GrabLinks = GrabLinks;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Light.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Light.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Light = void 0;
const LightArea_1 = __webpack_require__(/*! ./LightArea */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightArea.js");
const LightShadow_1 = __webpack_require__(/*! ./LightShadow */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightShadow.js");
class Light {
    constructor() {
        this.area = new LightArea_1.LightArea();
        this.shadow = new LightShadow_1.LightShadow();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.area.load(data.area);
        this.shadow.load(data.shadow);
    }
}
exports.Light = Light;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightArea.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightArea.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LightArea = void 0;
const LightGradient_1 = __webpack_require__(/*! ./LightGradient */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightGradient.js");
class LightArea {
    constructor() {
        this.gradient = new LightGradient_1.LightGradient();
        this.radius = 1000;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.gradient.load(data.gradient);
        if (data.radius !== undefined) {
            this.radius = data.radius;
        }
    }
}
exports.LightArea = LightArea;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightGradient.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightGradient.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LightGradient = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class LightGradient {
    constructor() {
        this.start = new OptionsColor_1.OptionsColor();
        this.stop = new OptionsColor_1.OptionsColor();
        this.start.value = "#ffffff";
        this.stop.value = "#000000";
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.start = OptionsColor_1.OptionsColor.create(this.start, data.start);
        this.stop = OptionsColor_1.OptionsColor.create(this.stop, data.stop);
    }
}
exports.LightGradient = LightGradient;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightShadow.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightShadow.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LightShadow = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class LightShadow {
    constructor() {
        this.color = new OptionsColor_1.OptionsColor();
        this.color.value = "#000000";
        this.length = 2000;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        if (data.length !== undefined) {
            this.length = data.length;
        }
    }
}
exports.LightShadow = LightShadow;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Modes.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Modes.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Modes = void 0;
const Bubble_1 = __webpack_require__(/*! ./Bubble */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Bubble.js");
const Connect_1 = __webpack_require__(/*! ./Connect */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Connect.js");
const Grab_1 = __webpack_require__(/*! ./Grab */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Grab.js");
const Remove_1 = __webpack_require__(/*! ./Remove */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Remove.js");
const Push_1 = __webpack_require__(/*! ./Push */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Push.js");
const Repulse_1 = __webpack_require__(/*! ./Repulse */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Repulse.js");
const Slow_1 = __webpack_require__(/*! ./Slow */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Slow.js");
const Trail_1 = __webpack_require__(/*! ./Trail */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Trail.js");
const Attract_1 = __webpack_require__(/*! ./Attract */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Attract.js");
const Light_1 = __webpack_require__(/*! ./Light */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Light.js");
const Bounce_1 = __webpack_require__(/*! ./Bounce */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Bounce.js");
class Modes {
    constructor() {
        this.attract = new Attract_1.Attract();
        this.bounce = new Bounce_1.Bounce();
        this.bubble = new Bubble_1.Bubble();
        this.connect = new Connect_1.Connect();
        this.grab = new Grab_1.Grab();
        this.light = new Light_1.Light();
        this.push = new Push_1.Push();
        this.remove = new Remove_1.Remove();
        this.repulse = new Repulse_1.Repulse();
        this.slow = new Slow_1.Slow();
        this.trail = new Trail_1.Trail();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.attract.load(data.attract);
        this.bubble.load(data.bubble);
        this.connect.load(data.connect);
        this.grab.load(data.grab);
        this.light.load(data.light);
        this.push.load(data.push);
        this.remove.load(data.remove);
        this.repulse.load(data.repulse);
        this.slow.load(data.slow);
        this.trail.load(data.trail);
    }
}
exports.Modes = Modes;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Push.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Push.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Push = void 0;
class Push {
    constructor() {
        this.quantity = 4;
    }
    get particles_nb() {
        return this.quantity;
    }
    set particles_nb(value) {
        this.quantity = value;
    }
    load(data) {
        var _a;
        if (data === undefined) {
            return;
        }
        const quantity = (_a = data.quantity) !== null && _a !== void 0 ? _a : data.particles_nb;
        if (quantity !== undefined) {
            this.quantity = quantity;
        }
    }
}
exports.Push = Push;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Remove.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Remove.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Remove = void 0;
class Remove {
    constructor() {
        this.quantity = 2;
    }
    get particles_nb() {
        return this.quantity;
    }
    set particles_nb(value) {
        this.quantity = value;
    }
    load(data) {
        var _a;
        if (data === undefined) {
            return;
        }
        const quantity = (_a = data.quantity) !== null && _a !== void 0 ? _a : data.particles_nb;
        if (quantity !== undefined) {
            this.quantity = quantity;
        }
    }
}
exports.Remove = Remove;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Repulse.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Repulse.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Repulse = void 0;
const RepulseDiv_1 = __webpack_require__(/*! ./RepulseDiv */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseDiv.js");
const RepulseBase_1 = __webpack_require__(/*! ./RepulseBase */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseBase.js");
class Repulse extends RepulseBase_1.RepulseBase {
    load(data) {
        super.load(data);
        if ((data === null || data === void 0 ? void 0 : data.divs) === undefined) {
            return;
        }
        if (data.divs instanceof Array) {
            this.divs = data.divs.map((s) => {
                const tmp = new RepulseDiv_1.RepulseDiv();
                tmp.load(s);
                return tmp;
            });
        }
        else {
            if (this.divs instanceof Array || !this.divs) {
                this.divs = new RepulseDiv_1.RepulseDiv();
            }
            this.divs.load(data.divs);
        }
    }
}
exports.Repulse = Repulse;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseBase.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseBase.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RepulseBase = void 0;
class RepulseBase {
    constructor() {
        this.distance = 200;
        this.duration = 0.4;
        this.speed = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.duration !== undefined) {
            this.duration = data.duration;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
    }
}
exports.RepulseBase = RepulseBase;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseDiv.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseDiv.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RepulseDiv = void 0;
const RepulseBase_1 = __webpack_require__(/*! ./RepulseBase */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseBase.js");
class RepulseDiv extends RepulseBase_1.RepulseBase {
    constructor() {
        super();
        this.selectors = [];
    }
    get ids() {
        if (this.selectors instanceof Array) {
            return this.selectors.map((t) => t.replace("#", ""));
        }
        else {
            return this.selectors.replace("#", "");
        }
    }
    set ids(value) {
        if (value instanceof Array) {
            this.selectors = value.map(() => `#${value}`);
        }
        else {
            this.selectors = `#${value}`;
        }
    }
    load(data) {
        super.load(data);
        if (data === undefined) {
            return;
        }
        if (data.ids !== undefined) {
            this.ids = data.ids;
        }
        if (data.selectors !== undefined) {
            this.selectors = data.selectors;
        }
    }
}
exports.RepulseDiv = RepulseDiv;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Slow.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Slow.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Slow = void 0;
class Slow {
    constructor() {
        this.factor = 3;
        this.radius = 200;
    }
    get active() {
        return false;
    }
    set active(_value) {
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.factor !== undefined) {
            this.factor = data.factor;
        }
        if (data.radius !== undefined) {
            this.radius = data.radius;
        }
    }
}
exports.Slow = Slow;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Trail.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Trail.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Trail = void 0;
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Trail {
    constructor() {
        this.delay = 1;
        this.quantity = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.delay !== undefined) {
            this.delay = data.delay;
        }
        if (data.quantity !== undefined) {
            this.quantity = data.quantity;
        }
        if (data.particles !== undefined) {
            this.particles = Utils_1.Utils.deepExtend({}, data.particles);
        }
    }
}
exports.Trail = Trail;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/ManualParticle.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/ManualParticle.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ManualParticle = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class ManualParticle {
    load(data) {
        var _a, _b;
        if (!data) {
            return;
        }
        if (data.position !== undefined) {
            this.position = {
                x: (_a = data.position.x) !== null && _a !== void 0 ? _a : 50,
                y: (_b = data.position.y) !== null && _b !== void 0 ? _b : 50,
            };
        }
        if (data.options !== undefined) {
            this.options = Utils_1.Utils.deepExtend({}, data.options);
        }
    }
}
exports.ManualParticle = ManualParticle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Motion/Motion.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Motion/Motion.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Motion = void 0;
const MotionReduce_1 = __webpack_require__(/*! ./MotionReduce */ "./node_modules/tsparticles/dist/Options/Classes/Motion/MotionReduce.js");
class Motion {
    constructor() {
        this.disable = false;
        this.reduce = new MotionReduce_1.MotionReduce();
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.disable !== undefined) {
            this.disable = data.disable;
        }
        this.reduce.load(data.reduce);
    }
}
exports.Motion = Motion;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Motion/MotionReduce.js":
/*!******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Motion/MotionReduce.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MotionReduce = void 0;
class MotionReduce {
    constructor() {
        this.factor = 4;
        this.value = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.factor !== undefined) {
            this.factor = data.factor;
        }
        if (data.value !== undefined) {
            this.value = data.value;
        }
    }
}
exports.MotionReduce = MotionReduce;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Options.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Options.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Options = void 0;
const Interactivity_1 = __webpack_require__(/*! ./Interactivity/Interactivity */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Interactivity.js");
const Particles_1 = __webpack_require__(/*! ./Particles/Particles */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Particles.js");
const BackgroundMask_1 = __webpack_require__(/*! ./BackgroundMask/BackgroundMask */ "./node_modules/tsparticles/dist/Options/Classes/BackgroundMask/BackgroundMask.js");
const Background_1 = __webpack_require__(/*! ./Background/Background */ "./node_modules/tsparticles/dist/Options/Classes/Background/Background.js");
const Infection_1 = __webpack_require__(/*! ./Infection/Infection */ "./node_modules/tsparticles/dist/Options/Classes/Infection/Infection.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Theme_1 = __webpack_require__(/*! ./Theme/Theme */ "./node_modules/tsparticles/dist/Options/Classes/Theme/Theme.js");
const Modes_1 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
const BackgroundMode_1 = __webpack_require__(/*! ./BackgroundMode/BackgroundMode */ "./node_modules/tsparticles/dist/Options/Classes/BackgroundMode/BackgroundMode.js");
const Motion_1 = __webpack_require__(/*! ./Motion/Motion */ "./node_modules/tsparticles/dist/Options/Classes/Motion/Motion.js");
const ManualParticle_1 = __webpack_require__(/*! ./ManualParticle */ "./node_modules/tsparticles/dist/Options/Classes/ManualParticle.js");
class Options {
    constructor() {
        this.autoPlay = true;
        this.background = new Background_1.Background();
        this.backgroundMask = new BackgroundMask_1.BackgroundMask();
        this.backgroundMode = new BackgroundMode_1.BackgroundMode();
        this.detectRetina = true;
        this.fpsLimit = 30;
        this.infection = new Infection_1.Infection();
        this.interactivity = new Interactivity_1.Interactivity();
        this.manualParticles = [];
        this.motion = new Motion_1.Motion();
        this.particles = new Particles_1.Particles();
        this.pauseOnBlur = true;
        this.pauseOnOutsideViewport = false;
        this.themes = [];
    }
    get fps_limit() {
        return this.fpsLimit;
    }
    set fps_limit(value) {
        this.fpsLimit = value;
    }
    get retina_detect() {
        return this.detectRetina;
    }
    set retina_detect(value) {
        this.detectRetina = value;
    }
    load(data) {
        var _a, _b;
        if (data === undefined) {
            return;
        }
        if (data.preset !== undefined) {
            if (data.preset instanceof Array) {
                for (const preset of data.preset) {
                    this.importPreset(preset);
                }
            }
            else {
                this.importPreset(data.preset);
            }
        }
        if (data.autoPlay !== undefined) {
            this.autoPlay = data.autoPlay;
        }
        const detectRetina = (_a = data.detectRetina) !== null && _a !== void 0 ? _a : data.retina_detect;
        if (detectRetina !== undefined) {
            this.detectRetina = detectRetina;
        }
        const fpsLimit = (_b = data.fpsLimit) !== null && _b !== void 0 ? _b : data.fps_limit;
        if (fpsLimit !== undefined) {
            this.fpsLimit = fpsLimit;
        }
        if (data.pauseOnBlur !== undefined) {
            this.pauseOnBlur = data.pauseOnBlur;
        }
        if (data.pauseOnOutsideViewport !== undefined) {
            this.pauseOnOutsideViewport = data.pauseOnOutsideViewport;
        }
        this.background.load(data.background);
        this.backgroundMode.load(data.backgroundMode);
        this.backgroundMask.load(data.backgroundMask);
        this.infection.load(data.infection);
        this.interactivity.load(data.interactivity);
        if (data.manualParticles !== undefined) {
            this.manualParticles = data.manualParticles.map((t) => {
                const tmp = new ManualParticle_1.ManualParticle();
                tmp.load(t);
                return tmp;
            });
        }
        this.motion.load(data.motion);
        this.particles.load(data.particles);
        Utils_1.Plugins.loadOptions(this, data);
        if (data.themes !== undefined) {
            for (const theme of data.themes) {
                const optTheme = new Theme_1.Theme();
                optTheme.load(theme);
                this.themes.push(optTheme);
            }
        }
    }
    setTheme(name) {
        if (name) {
            const chosenTheme = this.themes.find((theme) => theme.name === name);
            if (chosenTheme) {
                this.load(chosenTheme.options);
            }
        }
        else {
            const clientDarkMode = typeof matchMedia !== "undefined" && matchMedia("(prefers-color-scheme: dark)").matches;
            let defaultTheme = this.themes.find((theme) => theme.default.value &&
                ((theme.default.mode === Modes_1.ThemeMode.dark && clientDarkMode) ||
                    (theme.default.mode === Modes_1.ThemeMode.light && !clientDarkMode)));
            if (!defaultTheme) {
                defaultTheme = this.themes.find((theme) => theme.default.value && theme.default.mode === Modes_1.ThemeMode.any);
            }
            if (defaultTheme) {
                this.load(defaultTheme.options);
            }
        }
    }
    importPreset(preset) {
        this.load(Utils_1.Plugins.getPreset(preset));
    }
}
exports.Options = Options;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionsColor = void 0;
class OptionsColor {
    constructor() {
        this.value = "#fff";
    }
    static create(source, data) {
        const color = source !== null && source !== void 0 ? source : new OptionsColor();
        if (data !== undefined) {
            color.load(typeof data === "string" ? { value: data } : data);
        }
        return color;
    }
    load(data) {
        if ((data === null || data === void 0 ? void 0 : data.value) === undefined) {
            return;
        }
        this.value = data.value;
    }
}
exports.OptionsColor = OptionsColor;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/AnimatableColor.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/AnimatableColor.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimatableColor = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
const ColorAnimation_1 = __webpack_require__(/*! ./ColorAnimation */ "./node_modules/tsparticles/dist/Options/Classes/Particles/ColorAnimation.js");
class AnimatableColor extends OptionsColor_1.OptionsColor {
    constructor() {
        super();
        this.animation = new ColorAnimation_1.ColorAnimation();
    }
    static create(source, data) {
        const color = source !== null && source !== void 0 ? source : new AnimatableColor();
        if (data !== undefined) {
            color.load(typeof data === "string" ? { value: data } : data);
        }
        return color;
    }
    load(data) {
        super.load(data);
        this.animation.load(data === null || data === void 0 ? void 0 : data.animation);
    }
}
exports.AnimatableColor = AnimatableColor;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/Bounce.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/Bounce.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Bounce = void 0;
const BounceFactor_1 = __webpack_require__(/*! ./BounceFactor */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/BounceFactor.js");
class Bounce {
    constructor() {
        this.horizontal = new BounceFactor_1.BounceFactor();
        this.vertical = new BounceFactor_1.BounceFactor();
    }
    load(data) {
        if (!data) {
            return;
        }
        this.horizontal.load(data.horizontal);
        this.vertical.load(data.vertical);
    }
}
exports.Bounce = Bounce;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/BounceFactor.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/BounceFactor.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BounceFactor = void 0;
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class BounceFactor extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.random.minimumValue = 0.1;
        this.value = 1;
    }
}
exports.BounceFactor = BounceFactor;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Collisions.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Collisions.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Collisions = void 0;
const Enums_1 = __webpack_require__(/*! ../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Bounce_1 = __webpack_require__(/*! ./Bounce/Bounce */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/Bounce.js");
class Collisions {
    constructor() {
        this.bounce = new Bounce_1.Bounce();
        this.enable = false;
        this.mode = Enums_1.CollisionMode.bounce;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.bounce.load(data.bounce);
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
    }
}
exports.Collisions = Collisions;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/ColorAnimation.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/ColorAnimation.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorAnimation = void 0;
class ColorAnimation {
    constructor() {
        this.enable = false;
        this.speed = 1;
        this.sync = true;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.ColorAnimation = ColorAnimation;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Life/Life.js":
/*!******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Life/Life.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Life = void 0;
const LifeDelay_1 = __webpack_require__(/*! ./LifeDelay */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Life/LifeDelay.js");
const LifeDuration_1 = __webpack_require__(/*! ./LifeDuration */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Life/LifeDuration.js");
class Life {
    constructor() {
        this.count = 0;
        this.delay = new LifeDelay_1.LifeDelay();
        this.duration = new LifeDuration_1.LifeDuration();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.count !== undefined) {
            this.count = data.count;
        }
        this.delay.load(data.delay);
        this.duration.load(data.duration);
    }
}
exports.Life = Life;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Life/LifeDelay.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Life/LifeDelay.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LifeDelay = void 0;
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class LifeDelay extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.sync = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        super.load(data);
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.LifeDelay = LifeDelay;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Life/LifeDuration.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Life/LifeDuration.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LifeDuration = void 0;
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class LifeDuration extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.random.minimumValue = 0.0001;
        this.sync = false;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        super.load(data);
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.LifeDuration = LifeDuration;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Links/Links.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Links/Links.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Links = void 0;
const LinksShadow_1 = __webpack_require__(/*! ./LinksShadow */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Links/LinksShadow.js");
const LinksTriangle_1 = __webpack_require__(/*! ./LinksTriangle */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Links/LinksTriangle.js");
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class Links {
    constructor() {
        this.blink = false;
        this.color = new OptionsColor_1.OptionsColor();
        this.consent = false;
        this.distance = 100;
        this.enable = false;
        this.frequency = 1;
        this.opacity = 1;
        this.shadow = new LinksShadow_1.LinksShadow();
        this.triangles = new LinksTriangle_1.LinksTriangle();
        this.width = 1;
        this.warp = false;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.id !== undefined) {
            this.id = data.id;
        }
        if (data.blink !== undefined) {
            this.blink = data.blink;
        }
        this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        if (data.consent !== undefined) {
            this.consent = data.consent;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.frequency !== undefined) {
            this.frequency = data.frequency;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
        this.shadow.load(data.shadow);
        this.triangles.load(data.triangles);
        if (data.width !== undefined) {
            this.width = data.width;
        }
        if (data.warp !== undefined) {
            this.warp = data.warp;
        }
    }
}
exports.Links = Links;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Links/LinksShadow.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Links/LinksShadow.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LinksShadow = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class LinksShadow {
    constructor() {
        this.blur = 5;
        this.color = new OptionsColor_1.OptionsColor();
        this.enable = false;
        this.color.value = "#00ff00";
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.blur !== undefined) {
            this.blur = data.blur;
        }
        this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
    }
}
exports.LinksShadow = LinksShadow;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Links/LinksTriangle.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Links/LinksTriangle.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LinksTriangle = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class LinksTriangle {
    constructor() {
        this.enable = false;
        this.frequency = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.frequency !== undefined) {
            this.frequency = data.frequency;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}
exports.LinksTriangle = LinksTriangle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Attract.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Attract.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Attract = void 0;
class Attract {
    constructor() {
        this.enable = false;
        this.rotate = {
            x: 3000,
            y: 3000,
        };
    }
    get rotateX() {
        return this.rotate.x;
    }
    set rotateX(value) {
        this.rotate.x = value;
    }
    get rotateY() {
        return this.rotate.y;
    }
    set rotateY(value) {
        this.rotate.y = value;
    }
    load(data) {
        var _a, _b, _c, _d;
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        const rotateX = (_b = (_a = data.rotate) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : data.rotateX;
        if (rotateX !== undefined) {
            this.rotate.x = rotateX;
        }
        const rotateY = (_d = (_c = data.rotate) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : data.rotateY;
        if (rotateY !== undefined) {
            this.rotate.y = rotateY;
        }
    }
}
exports.Attract = Attract;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Move.js":
/*!******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Move.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Move = void 0;
const Attract_1 = __webpack_require__(/*! ./Attract */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Attract.js");
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Trail_1 = __webpack_require__(/*! ./Trail */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Trail.js");
const Noise_1 = __webpack_require__(/*! ./Noise/Noise */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Noise/Noise.js");
const MoveAngle_1 = __webpack_require__(/*! ./MoveAngle */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/MoveAngle.js");
const MoveGravity_1 = __webpack_require__(/*! ./MoveGravity */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/MoveGravity.js");
const OutModes_1 = __webpack_require__(/*! ./OutModes */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/OutModes.js");
class Move {
    constructor() {
        this.angle = new MoveAngle_1.MoveAngle();
        this.attract = new Attract_1.Attract();
        this.direction = Enums_1.MoveDirection.none;
        this.distance = 0;
        this.enable = false;
        this.gravity = new MoveGravity_1.MoveGravity();
        this.noise = new Noise_1.Noise();
        this.outModes = new OutModes_1.OutModes();
        this.random = false;
        this.size = false;
        this.speed = 2;
        this.straight = false;
        this.trail = new Trail_1.Trail();
        this.vibrate = false;
        this.warp = false;
    }
    get collisions() {
        return false;
    }
    set collisions(value) {
    }
    get bounce() {
        return this.collisions;
    }
    set bounce(value) {
        this.collisions = value;
    }
    get out_mode() {
        return this.outMode;
    }
    set out_mode(value) {
        this.outMode = value;
    }
    get outMode() {
        return this.outModes.default;
    }
    set outMode(value) {
        this.outModes.default = value;
    }
    load(data) {
        var _a, _b;
        if (data === undefined) {
            return;
        }
        if (data.angle !== undefined) {
            if (typeof data.angle === "number") {
                this.angle.value = data.angle;
            }
            else {
                this.angle.load(data.angle);
            }
        }
        this.attract.load(data.attract);
        if (data.direction !== undefined) {
            this.direction = data.direction;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        this.gravity.load(data.gravity);
        this.noise.load(data.noise);
        const outMode = (_a = data.outMode) !== null && _a !== void 0 ? _a : data.out_mode;
        if (data.outModes !== undefined || outMode !== undefined) {
            if (typeof data.outModes === "string" || (data.outModes === undefined && outMode !== undefined)) {
                this.outModes.load({
                    default: (_b = data.outModes) !== null && _b !== void 0 ? _b : outMode,
                });
            }
            else {
                this.outModes.load(data.outModes);
            }
        }
        if (data.random !== undefined) {
            this.random = data.random;
        }
        if (data.size !== undefined) {
            this.size = data.size;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
        if (data.straight !== undefined) {
            this.straight = data.straight;
        }
        this.trail.load(data.trail);
        if (data.vibrate !== undefined) {
            this.vibrate = data.vibrate;
        }
        if (data.warp !== undefined) {
            this.warp = data.warp;
        }
    }
}
exports.Move = Move;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/MoveAngle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/MoveAngle.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MoveAngle = void 0;
class MoveAngle {
    constructor() {
        this.offset = 45;
        this.value = 90;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.offset !== undefined) {
            this.offset = data.offset;
        }
        if (data.value !== undefined) {
            this.value = data.value;
        }
    }
}
exports.MoveAngle = MoveAngle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/MoveGravity.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/MoveGravity.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MoveGravity = void 0;
class MoveGravity {
    constructor() {
        this.acceleration = 9.81;
        this.enable = false;
        this.maxSpeed = 50;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.acceleration !== undefined) {
            this.acceleration = data.acceleration;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.maxSpeed !== undefined) {
            this.maxSpeed = data.maxSpeed;
        }
    }
}
exports.MoveGravity = MoveGravity;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Noise/Noise.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Noise/Noise.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Noise = void 0;
const NoiseDelay_1 = __webpack_require__(/*! ./NoiseDelay */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Noise/NoiseDelay.js");
class Noise {
    constructor() {
        this.delay = new NoiseDelay_1.NoiseDelay();
        this.enable = false;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.delay.load(data.delay);
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
    }
}
exports.Noise = Noise;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Noise/NoiseDelay.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Noise/NoiseDelay.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NoiseDelay = void 0;
const ValueWithRandom_1 = __webpack_require__(/*! ../../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class NoiseDelay extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
    }
}
exports.NoiseDelay = NoiseDelay;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/OutModes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/OutModes.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OutModes = void 0;
const Modes_1 = __webpack_require__(/*! ../../../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class OutModes {
    constructor() {
        this.default = Modes_1.OutMode.out;
    }
    load(data) {
        var _a, _b, _c, _d;
        if (!data) {
            return;
        }
        if (data.default !== undefined) {
            this.default = data.default;
        }
        this.bottom = (_a = data.bottom) !== null && _a !== void 0 ? _a : data.default;
        this.left = (_b = data.left) !== null && _b !== void 0 ? _b : data.default;
        this.right = (_c = data.right) !== null && _c !== void 0 ? _c : data.default;
        this.top = (_d = data.top) !== null && _d !== void 0 ? _d : data.default;
    }
}
exports.OutModes = OutModes;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Trail.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Trail.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Trail = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class Trail {
    constructor() {
        this.enable = false;
        this.length = 10;
        this.fillColor = new OptionsColor_1.OptionsColor();
        this.fillColor.value = "#000000";
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        this.fillColor = OptionsColor_1.OptionsColor.create(this.fillColor, data.fillColor);
        if (data.length !== undefined) {
            this.length = data.length;
        }
    }
}
exports.Trail = Trail;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Number/Density.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Number/Density.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Density = void 0;
class Density {
    constructor() {
        this.enable = false;
        this.area = 800;
        this.factor = 1000;
    }
    get value_area() {
        return this.area;
    }
    set value_area(value) {
        this.area = value;
    }
    load(data) {
        var _a;
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        const area = (_a = data.area) !== null && _a !== void 0 ? _a : data.value_area;
        if (area !== undefined) {
            this.area = area;
        }
        if (data.factor !== undefined) {
            this.factor = data.factor;
        }
    }
}
exports.Density = Density;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Number/ParticlesNumber.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Number/ParticlesNumber.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ParticlesNumber = void 0;
const Density_1 = __webpack_require__(/*! ./Density */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Number/Density.js");
class ParticlesNumber {
    constructor() {
        this.density = new Density_1.Density();
        this.limit = 0;
        this.value = 100;
    }
    get max() {
        return this.limit;
    }
    set max(value) {
        this.limit = value;
    }
    load(data) {
        var _a;
        if (data === undefined) {
            return;
        }
        this.density.load(data.density);
        const limit = (_a = data.limit) !== null && _a !== void 0 ? _a : data.max;
        if (limit !== undefined) {
            this.limit = limit;
        }
        if (data.value !== undefined) {
            this.value = data.value;
        }
    }
}
exports.ParticlesNumber = ParticlesNumber;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Opacity/Opacity.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Opacity/Opacity.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Opacity = void 0;
const OpacityAnimation_1 = __webpack_require__(/*! ./OpacityAnimation */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Opacity/OpacityAnimation.js");
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class Opacity extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.animation = new OpacityAnimation_1.OpacityAnimation();
        this.random.minimumValue = 0.1;
        this.value = 1;
    }
    get anim() {
        return this.animation;
    }
    set anim(value) {
        this.animation = value;
    }
    load(data) {
        var _a;
        if (!data) {
            return;
        }
        super.load(data);
        this.animation.load((_a = data.animation) !== null && _a !== void 0 ? _a : data.anim);
    }
}
exports.Opacity = Opacity;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Opacity/OpacityAnimation.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Opacity/OpacityAnimation.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OpacityAnimation = void 0;
const Types_1 = __webpack_require__(/*! ../../../../Enums/Types */ "./node_modules/tsparticles/dist/Enums/Types/index.js");
class OpacityAnimation {
    constructor() {
        this.destroy = Types_1.DestroyType.none;
        this.enable = false;
        this.minimumValue = 0;
        this.speed = 2;
        this.startValue = Types_1.StartValueType.random;
        this.sync = false;
    }
    get opacity_min() {
        return this.minimumValue;
    }
    set opacity_min(value) {
        this.minimumValue = value;
    }
    load(data) {
        var _a;
        if (data === undefined) {
            return;
        }
        if (data.destroy !== undefined) {
            this.destroy = data.destroy;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        const minimumValue = (_a = data.minimumValue) !== null && _a !== void 0 ? _a : data.opacity_min;
        if (minimumValue !== undefined) {
            this.minimumValue = minimumValue;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
        if (data.startValue !== undefined) {
            this.startValue = data.startValue;
        }
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.OpacityAnimation = OpacityAnimation;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Particles.js":
/*!******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Particles.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Particles = void 0;
const Links_1 = __webpack_require__(/*! ./Links/Links */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Links/Links.js");
const Move_1 = __webpack_require__(/*! ./Move/Move */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Move.js");
const ParticlesNumber_1 = __webpack_require__(/*! ./Number/ParticlesNumber */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Number/ParticlesNumber.js");
const Opacity_1 = __webpack_require__(/*! ./Opacity/Opacity */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Opacity/Opacity.js");
const Shape_1 = __webpack_require__(/*! ./Shape/Shape */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Shape/Shape.js");
const Size_1 = __webpack_require__(/*! ./Size/Size */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Size/Size.js");
const Rotate_1 = __webpack_require__(/*! ./Rotate/Rotate */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Rotate/Rotate.js");
const Shadow_1 = __webpack_require__(/*! ./Shadow */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Shadow.js");
const Stroke_1 = __webpack_require__(/*! ./Stroke */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Stroke.js");
const Collisions_1 = __webpack_require__(/*! ./Collisions */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Collisions.js");
const Twinkle_1 = __webpack_require__(/*! ./Twinkle/Twinkle */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Twinkle/Twinkle.js");
const AnimatableColor_1 = __webpack_require__(/*! ./AnimatableColor */ "./node_modules/tsparticles/dist/Options/Classes/Particles/AnimatableColor.js");
const Life_1 = __webpack_require__(/*! ./Life/Life */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Life/Life.js");
const Bounce_1 = __webpack_require__(/*! ./Bounce/Bounce */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/Bounce.js");
class Particles {
    constructor() {
        this.bounce = new Bounce_1.Bounce();
        this.collisions = new Collisions_1.Collisions();
        this.color = new AnimatableColor_1.AnimatableColor();
        this.life = new Life_1.Life();
        this.links = new Links_1.Links();
        this.move = new Move_1.Move();
        this.number = new ParticlesNumber_1.ParticlesNumber();
        this.opacity = new Opacity_1.Opacity();
        this.reduceDuplicates = false;
        this.rotate = new Rotate_1.Rotate();
        this.shadow = new Shadow_1.Shadow();
        this.shape = new Shape_1.Shape();
        this.size = new Size_1.Size();
        this.stroke = new Stroke_1.Stroke();
        this.twinkle = new Twinkle_1.Twinkle();
    }
    get line_linked() {
        return this.links;
    }
    set line_linked(value) {
        this.links = value;
    }
    get lineLinked() {
        return this.links;
    }
    set lineLinked(value) {
        this.links = value;
    }
    load(data) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (data === undefined) {
            return;
        }
        this.bounce.load(data.bounce);
        this.color = AnimatableColor_1.AnimatableColor.create(this.color, data.color);
        this.life.load(data.life);
        const links = (_b = (_a = data.links) !== null && _a !== void 0 ? _a : data.lineLinked) !== null && _b !== void 0 ? _b : data.line_linked;
        if (links !== undefined) {
            this.links.load(links);
        }
        this.move.load(data.move);
        this.number.load(data.number);
        this.opacity.load(data.opacity);
        if (data.reduceDuplicates !== undefined) {
            this.reduceDuplicates = data.reduceDuplicates;
        }
        this.rotate.load(data.rotate);
        this.shape.load(data.shape);
        this.size.load(data.size);
        this.shadow.load(data.shadow);
        this.twinkle.load(data.twinkle);
        const collisions = (_d = (_c = data.move) === null || _c === void 0 ? void 0 : _c.collisions) !== null && _d !== void 0 ? _d : (_e = data.move) === null || _e === void 0 ? void 0 : _e.bounce;
        if (collisions !== undefined) {
            this.collisions.enable = collisions;
        }
        this.collisions.load(data.collisions);
        const strokeToLoad = (_f = data.stroke) !== null && _f !== void 0 ? _f : (_g = data.shape) === null || _g === void 0 ? void 0 : _g.stroke;
        if (strokeToLoad === undefined) {
            return;
        }
        if (strokeToLoad instanceof Array) {
            this.stroke = strokeToLoad.map((s) => {
                const tmp = new Stroke_1.Stroke();
                tmp.load(s);
                return tmp;
            });
        }
        else {
            if (this.stroke instanceof Array) {
                this.stroke = new Stroke_1.Stroke();
            }
            this.stroke.load(strokeToLoad);
        }
    }
}
exports.Particles = Particles;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Rotate/Rotate.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Rotate/Rotate.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Rotate = void 0;
const RotateAnimation_1 = __webpack_require__(/*! ./RotateAnimation */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Rotate/RotateAnimation.js");
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class Rotate extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.animation = new RotateAnimation_1.RotateAnimation();
        this.direction = Enums_1.RotateDirection.clockwise;
        this.path = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        super.load(data);
        if (data.direction !== undefined) {
            this.direction = data.direction;
        }
        this.animation.load(data.animation);
        if (data.path !== undefined) {
            this.path = data.path;
        }
    }
}
exports.Rotate = Rotate;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Rotate/RotateAnimation.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Rotate/RotateAnimation.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RotateAnimation = void 0;
class RotateAnimation {
    constructor() {
        this.enable = false;
        this.speed = 0;
        this.sync = false;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.RotateAnimation = RotateAnimation;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Shadow.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Shadow.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Shadow = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class Shadow {
    constructor() {
        this.blur = 0;
        this.color = new OptionsColor_1.OptionsColor();
        this.enable = false;
        this.offset = {
            x: 0,
            y: 0,
        };
        this.color.value = "#000000";
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.blur !== undefined) {
            this.blur = data.blur;
        }
        this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.offset === undefined) {
            return;
        }
        if (data.offset.x !== undefined) {
            this.offset.x = data.offset.x;
        }
        if (data.offset.y !== undefined) {
            this.offset.y = data.offset.y;
        }
    }
}
exports.Shadow = Shadow;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Shape/Shape.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Shape/Shape.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Shape = void 0;
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Shape {
    constructor() {
        this.options = {};
        this.type = Enums_1.ShapeType.circle;
    }
    get image() {
        var _a;
        return ((_a = this.options[Enums_1.ShapeType.image]) !== null && _a !== void 0 ? _a : this.options[Enums_1.ShapeType.images]);
    }
    set image(value) {
        this.options[Enums_1.ShapeType.image] = value;
        this.options[Enums_1.ShapeType.images] = value;
    }
    get custom() {
        return this.options;
    }
    set custom(value) {
        this.options = value;
    }
    get images() {
        return this.image instanceof Array ? this.image : [this.image];
    }
    set images(value) {
        this.image = value;
    }
    get stroke() {
        return [];
    }
    set stroke(_value) {
    }
    get character() {
        var _a;
        return ((_a = this.options[Enums_1.ShapeType.character]) !== null && _a !== void 0 ? _a : this.options[Enums_1.ShapeType.char]);
    }
    set character(value) {
        this.options[Enums_1.ShapeType.character] = value;
        this.options[Enums_1.ShapeType.char] = value;
    }
    get polygon() {
        var _a;
        return ((_a = this.options[Enums_1.ShapeType.polygon]) !== null && _a !== void 0 ? _a : this.options[Enums_1.ShapeType.star]);
    }
    set polygon(value) {
        this.options[Enums_1.ShapeType.polygon] = value;
        this.options[Enums_1.ShapeType.star] = value;
    }
    load(data) {
        var _a, _b, _c;
        if (data === undefined) {
            return;
        }
        const options = (_a = data.options) !== null && _a !== void 0 ? _a : data.custom;
        if (options !== undefined) {
            for (const shape in options) {
                const item = options[shape];
                if (item !== undefined) {
                    this.options[shape] = Utils_1.Utils.deepExtend((_b = this.options[shape]) !== null && _b !== void 0 ? _b : {}, item);
                }
            }
        }
        this.loadShape(data.character, Enums_1.ShapeType.character, Enums_1.ShapeType.char, true);
        this.loadShape(data.polygon, Enums_1.ShapeType.polygon, Enums_1.ShapeType.star, false);
        this.loadShape((_c = data.image) !== null && _c !== void 0 ? _c : data.images, Enums_1.ShapeType.image, Enums_1.ShapeType.images, true);
        if (data.type !== undefined) {
            this.type = data.type;
        }
    }
    loadShape(item, mainKey, altKey, altOverride) {
        var _a, _b, _c, _d;
        if (item === undefined) {
            return;
        }
        if (item instanceof Array) {
            if (!(this.options[mainKey] instanceof Array)) {
                this.options[mainKey] = [];
                if (!this.options[altKey] || altOverride) {
                    this.options[altKey] = [];
                }
            }
            this.options[mainKey] = Utils_1.Utils.deepExtend((_a = this.options[mainKey]) !== null && _a !== void 0 ? _a : [], item);
            if (!this.options[altKey] || altOverride) {
                this.options[altKey] = Utils_1.Utils.deepExtend((_b = this.options[altKey]) !== null && _b !== void 0 ? _b : [], item);
            }
        }
        else {
            if (this.options[mainKey] instanceof Array) {
                this.options[mainKey] = {};
                if (!this.options[altKey] || altOverride) {
                    this.options[altKey] = {};
                }
            }
            this.options[mainKey] = Utils_1.Utils.deepExtend((_c = this.options[mainKey]) !== null && _c !== void 0 ? _c : {}, item);
            if (!this.options[altKey] || altOverride) {
                this.options[altKey] = Utils_1.Utils.deepExtend((_d = this.options[altKey]) !== null && _d !== void 0 ? _d : {}, item);
            }
        }
    }
}
exports.Shape = Shape;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Size/Size.js":
/*!******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Size/Size.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Size = void 0;
const SizeAnimation_1 = __webpack_require__(/*! ./SizeAnimation */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Size/SizeAnimation.js");
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class Size extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.animation = new SizeAnimation_1.SizeAnimation();
        this.random.minimumValue = 1;
        this.value = 3;
    }
    get anim() {
        return this.animation;
    }
    set anim(value) {
        this.animation = value;
    }
    load(data) {
        var _a;
        if (!data) {
            return;
        }
        super.load(data);
        const animation = (_a = data.animation) !== null && _a !== void 0 ? _a : data.anim;
        if (animation !== undefined) {
            this.animation.load(animation);
        }
    }
}
exports.Size = Size;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Size/SizeAnimation.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Size/SizeAnimation.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SizeAnimation = void 0;
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
class SizeAnimation {
    constructor() {
        this.destroy = Enums_1.DestroyType.none;
        this.enable = false;
        this.minimumValue = 0;
        this.speed = 5;
        this.startValue = Enums_1.StartValueType.random;
        this.sync = false;
    }
    get size_min() {
        return this.minimumValue;
    }
    set size_min(value) {
        this.minimumValue = value;
    }
    load(data) {
        var _a;
        if (data === undefined) {
            return;
        }
        if (data.destroy !== undefined) {
            this.destroy = data.destroy;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        const minimumValue = (_a = data.minimumValue) !== null && _a !== void 0 ? _a : data.size_min;
        if (minimumValue !== undefined) {
            this.minimumValue = minimumValue;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
        if (data.startValue !== undefined) {
            this.startValue = data.startValue;
        }
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.SizeAnimation = SizeAnimation;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Stroke.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Stroke.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Stroke = void 0;
const AnimatableColor_1 = __webpack_require__(/*! ./AnimatableColor */ "./node_modules/tsparticles/dist/Options/Classes/Particles/AnimatableColor.js");
class Stroke {
    constructor() {
        this.width = 0;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = AnimatableColor_1.AnimatableColor.create(this.color, data.color);
        }
        if (data.width !== undefined) {
            this.width = data.width;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}
exports.Stroke = Stroke;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Twinkle/Twinkle.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Twinkle/Twinkle.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Twinkle = void 0;
const TwinkleValues_1 = __webpack_require__(/*! ./TwinkleValues */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Twinkle/TwinkleValues.js");
class Twinkle {
    constructor() {
        this.lines = new TwinkleValues_1.TwinkleValues();
        this.particles = new TwinkleValues_1.TwinkleValues();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.lines.load(data.lines);
        this.particles.load(data.particles);
    }
}
exports.Twinkle = Twinkle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Twinkle/TwinkleValues.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Twinkle/TwinkleValues.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TwinkleValues = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class TwinkleValues {
    constructor() {
        this.enable = false;
        this.frequency = 0.05;
        this.opacity = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.frequency !== undefined) {
            this.frequency = data.frequency;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}
exports.TwinkleValues = TwinkleValues;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Random.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Random.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Random = void 0;
class Random {
    constructor() {
        this.enable = false;
        this.minimumValue = 0;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.minimumValue !== undefined) {
            this.minimumValue = data.minimumValue;
        }
    }
}
exports.Random = Random;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Theme/Theme.js":
/*!**********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Theme/Theme.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Theme = void 0;
const Utils_1 = __webpack_require__(/*! ../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const ThemeDefault_1 = __webpack_require__(/*! ./ThemeDefault */ "./node_modules/tsparticles/dist/Options/Classes/Theme/ThemeDefault.js");
class Theme {
    constructor() {
        this.name = "";
        this.default = new ThemeDefault_1.ThemeDefault();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.name !== undefined) {
            this.name = data.name;
        }
        this.default.load(data.default);
        if (data.options !== undefined) {
            this.options = Utils_1.Utils.deepExtend({}, data.options);
        }
    }
}
exports.Theme = Theme;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Theme/ThemeDefault.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Theme/ThemeDefault.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ThemeDefault = void 0;
const Modes_1 = __webpack_require__(/*! ../../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class ThemeDefault {
    constructor() {
        this.mode = Modes_1.ThemeMode.any;
        this.value = false;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
        if (data.value !== undefined) {
            this.value = data.value;
        }
    }
}
exports.ThemeDefault = ThemeDefault;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueWithRandom = void 0;
const Random_1 = __webpack_require__(/*! ./Random */ "./node_modules/tsparticles/dist/Options/Classes/Random.js");
class ValueWithRandom {
    constructor() {
        this.random = new Random_1.Random();
        this.value = 0;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (typeof data.random === "boolean") {
            this.random.enable = data.random;
        }
        else {
            this.random.load(data.random);
        }
        if (data.value !== undefined) {
            this.value = data.value;
        }
    }
}
exports.ValueWithRandom = ValueWithRandom;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/AbsorberInstance.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/AbsorberInstance.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AbsorberInstance = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class AbsorberInstance {
    constructor(absorbers, container, options, position) {
        var _a, _b;
        this.absorbers = absorbers;
        this.container = container;
        this.initialPosition = position;
        this.options = options;
        this.dragging = false;
        this.opacity = this.options.opacity;
        this.size = Utils_1.NumberUtils.getValue(options.size) * container.retina.pixelRatio;
        this.mass = this.size * options.size.density * container.retina.reduceFactor;
        const limit = options.size.limit;
        this.limit = limit !== undefined ? limit * container.retina.pixelRatio * container.retina.reduceFactor : limit;
        const color = typeof options.color === "string" ? { value: options.color } : options.color;
        this.color = (_a = Utils_1.ColorUtils.colorToRgb(color)) !== null && _a !== void 0 ? _a : {
            b: 0,
            g: 0,
            r: 0,
        };
        this.position = (_b = this.initialPosition) !== null && _b !== void 0 ? _b : this.calcPosition();
    }
    attract(particle) {
        const options = this.options;
        if (options.draggable) {
            const mouse = this.container.interactivity.mouse;
            if (mouse.clicking && mouse.downPosition) {
                const mouseDist = Utils_1.NumberUtils.getDistance(this.position, mouse.downPosition);
                if (mouseDist <= this.size) {
                    this.dragging = true;
                }
            }
            else {
                this.dragging = false;
            }
            if (this.dragging && mouse.position) {
                this.position.x = mouse.position.x;
                this.position.y = mouse.position.y;
            }
        }
        const pos = particle.getPosition();
        const { dx, dy, distance } = Utils_1.NumberUtils.getDistances(this.position, pos);
        const angle = Math.atan2(dx, dy);
        const acceleration = (this.mass / Math.pow(distance, 2)) * this.container.retina.reduceFactor;
        if (distance < this.size + particle.getRadius()) {
            const sizeFactor = particle.getRadius() * 0.033 * this.container.retina.pixelRatio;
            if (this.size > particle.getRadius() && distance < this.size - particle.getRadius()) {
                if (options.destroy) {
                    particle.destroy();
                }
                else {
                    particle.needsNewPosition = true;
                    this.updateParticlePosition(particle, angle, acceleration);
                }
            }
            else {
                if (options.destroy) {
                    particle.size.value -= sizeFactor;
                }
                this.updateParticlePosition(particle, angle, acceleration);
            }
            if (this.limit === undefined || this.size < this.limit) {
                this.size += sizeFactor;
            }
            this.mass += sizeFactor * this.options.size.density * this.container.retina.reduceFactor;
        }
        else {
            this.updateParticlePosition(particle, angle, acceleration);
        }
    }
    resize() {
        const initialPosition = this.initialPosition;
        this.position =
            initialPosition && Utils_1.Utils.isPointInside(initialPosition, this.container.canvas.size)
                ? initialPosition
                : this.calcPosition();
    }
    draw(context) {
        context.translate(this.position.x, this.position.y);
        context.beginPath();
        context.arc(0, 0, this.size, 0, Math.PI * 2, false);
        context.closePath();
        context.fillStyle = Utils_1.ColorUtils.getStyleFromRgb(this.color, this.opacity);
        context.fill();
    }
    calcPosition() {
        var _a, _b;
        const container = this.container;
        const percentPosition = this.options.position;
        return {
            x: (((_a = percentPosition === null || percentPosition === void 0 ? void 0 : percentPosition.x) !== null && _a !== void 0 ? _a : Math.random() * 100) / 100) * container.canvas.size.width,
            y: (((_b = percentPosition === null || percentPosition === void 0 ? void 0 : percentPosition.y) !== null && _b !== void 0 ? _b : Math.random() * 100) / 100) * container.canvas.size.height,
        };
    }
    updateParticlePosition(particle, angle, acceleration) {
        var _a;
        if (particle.destroyed) {
            return;
        }
        const canvasSize = this.container.canvas.size;
        if (particle.needsNewPosition) {
            const pSize = particle.getRadius();
            particle.position.x = Math.random() * (canvasSize.width - pSize * 2) + pSize;
            particle.position.y = Math.random() * (canvasSize.height - pSize * 2) + pSize;
            particle.needsNewPosition = false;
        }
        if (this.options.orbits) {
            if (particle.orbitRadius === undefined) {
                particle.orbitRadius = Utils_1.NumberUtils.getDistance(particle.getPosition(), this.position);
            }
            if (particle.orbitRadius <= this.size && !this.options.destroy) {
                particle.orbitRadius = Math.random() * Math.max(canvasSize.width, canvasSize.height);
            }
            if (particle.orbitAngle === undefined) {
                particle.orbitAngle = Math.random() * Math.PI * 2;
            }
            const orbitRadius = particle.orbitRadius;
            const orbitAngle = particle.orbitAngle;
            particle.velocity.horizontal = 0;
            particle.velocity.vertical = 0;
            particle.position.x = this.position.x + orbitRadius * Math.cos(orbitAngle);
            particle.position.y = this.position.y + orbitRadius * Math.sin(orbitAngle);
            particle.orbitRadius -= acceleration;
            particle.orbitAngle +=
                (((_a = particle.moveSpeed) !== null && _a !== void 0 ? _a : this.container.retina.moveSpeed) / 100) * this.container.retina.reduceFactor;
        }
        else {
            particle.velocity.horizontal += Math.sin(angle) * acceleration;
            particle.velocity.vertical += Math.cos(angle) * acceleration;
        }
    }
}
exports.AbsorberInstance = AbsorberInstance;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/Absorbers.js":
/*!**********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/Absorbers.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Absorbers = void 0;
const AbsorberInstance_1 = __webpack_require__(/*! ./AbsorberInstance */ "./node_modules/tsparticles/dist/Plugins/Absorbers/AbsorberInstance.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Absorber_1 = __webpack_require__(/*! ./Options/Classes/Absorber */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/Absorber.js");
const Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/index.js");
class Absorbers {
    constructor(container) {
        this.container = container;
        this.array = [];
        this.absorbers = [];
        this.interactivityAbsorbers = [];
        const overridableContainer = container;
        overridableContainer.addAbsorber = (options, position) => this.addAbsorber(options, position);
    }
    init(options) {
        var _a, _b;
        if (!options) {
            return;
        }
        if (options.absorbers) {
            if (options.absorbers instanceof Array) {
                this.absorbers = options.absorbers.map((s) => {
                    const tmp = new Absorber_1.Absorber();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                if (this.absorbers instanceof Array) {
                    this.absorbers = new Absorber_1.Absorber();
                }
                this.absorbers.load(options.absorbers);
            }
        }
        const interactivityAbsorbers = (_b = (_a = options.interactivity) === null || _a === void 0 ? void 0 : _a.modes) === null || _b === void 0 ? void 0 : _b.absorbers;
        if (interactivityAbsorbers) {
            if (interactivityAbsorbers instanceof Array) {
                this.interactivityAbsorbers = interactivityAbsorbers.map((s) => {
                    const tmp = new Absorber_1.Absorber();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                if (this.interactivityAbsorbers instanceof Array) {
                    this.interactivityAbsorbers = new Absorber_1.Absorber();
                }
                this.interactivityAbsorbers.load(interactivityAbsorbers);
            }
        }
        if (this.absorbers instanceof Array) {
            for (const absorberOptions of this.absorbers) {
                this.addAbsorber(absorberOptions);
            }
        }
        else {
            this.addAbsorber(this.absorbers);
        }
    }
    particleUpdate(particle) {
        for (const absorber of this.array) {
            absorber.attract(particle);
            if (particle.destroyed) {
                break;
            }
        }
    }
    draw(context) {
        for (const absorber of this.array) {
            context.save();
            absorber.draw(context);
            context.restore();
        }
    }
    stop() {
        this.array = [];
    }
    resize() {
        for (const absorber of this.array) {
            absorber.resize();
        }
    }
    handleClickMode(mode) {
        const container = this.container;
        const absorberOptions = this.absorbers;
        const modeAbsorbers = this.interactivityAbsorbers;
        if (mode === Enums_1.AbsorberClickMode.absorber) {
            let absorbersModeOptions;
            if (modeAbsorbers instanceof Array) {
                if (modeAbsorbers.length > 0) {
                    absorbersModeOptions = Utils_1.Utils.itemFromArray(modeAbsorbers);
                }
            }
            else {
                absorbersModeOptions = modeAbsorbers;
            }
            const absorbersOptions = absorbersModeOptions !== null && absorbersModeOptions !== void 0 ? absorbersModeOptions : (absorberOptions instanceof Array ? Utils_1.Utils.itemFromArray(absorberOptions) : absorberOptions);
            const aPosition = container.interactivity.mouse.clickPosition;
            this.addAbsorber(absorbersOptions, aPosition);
        }
    }
    addAbsorber(options, position) {
        const absorber = new AbsorberInstance_1.AbsorberInstance(this, this.container, options, position);
        this.array.push(absorber);
        return absorber;
    }
    removeAbsorber(absorber) {
        const index = this.array.indexOf(absorber);
        if (index >= 0) {
            this.array.splice(index, 1);
        }
    }
}
exports.Absorbers = Absorbers;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/AbsorbersPlugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/AbsorbersPlugin.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbsorbersPlugin = void 0;
const Absorbers_1 = __webpack_require__(/*! ./Absorbers */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Absorbers.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/index.js");
const Absorber_1 = __webpack_require__(/*! ./Options/Classes/Absorber */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/Absorber.js");
class AbsorbersPlugin {
    constructor() {
        this.id = "absorbers";
    }
    getPlugin(container) {
        return new Absorbers_1.Absorbers(container);
    }
    needsPlugin(options) {
        var _a, _b, _c;
        if (options === undefined) {
            return false;
        }
        const absorbers = options.absorbers;
        let loadAbsorbers = false;
        if (absorbers instanceof Array) {
            if (absorbers.length) {
                loadAbsorbers = true;
            }
        }
        else if (absorbers !== undefined) {
            loadAbsorbers = true;
        }
        else if (((_c = (_b = (_a = options.interactivity) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.onClick) === null || _c === void 0 ? void 0 : _c.mode) &&
            Utils_1.Utils.isInArray(Enums_1.AbsorberClickMode.absorber, options.interactivity.events.onClick.mode)) {
            loadAbsorbers = true;
        }
        return loadAbsorbers;
    }
    loadOptions(options, source) {
        var _a, _b;
        if (!this.needsPlugin(options) && !this.needsPlugin(source)) {
            return;
        }
        const optionsCast = options;
        if (source === null || source === void 0 ? void 0 : source.absorbers) {
            if ((source === null || source === void 0 ? void 0 : source.absorbers) instanceof Array) {
                optionsCast.absorbers = source === null || source === void 0 ? void 0 : source.absorbers.map((s) => {
                    const tmp = new Absorber_1.Absorber();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                let absorberOptions = optionsCast.absorbers;
                if ((absorberOptions === null || absorberOptions === void 0 ? void 0 : absorberOptions.load) === undefined) {
                    optionsCast.absorbers = absorberOptions = new Absorber_1.Absorber();
                }
                absorberOptions.load(source === null || source === void 0 ? void 0 : source.absorbers);
            }
        }
        const interactivityAbsorbers = (_b = (_a = source === null || source === void 0 ? void 0 : source.interactivity) === null || _a === void 0 ? void 0 : _a.modes) === null || _b === void 0 ? void 0 : _b.absorbers;
        if (interactivityAbsorbers) {
            if (interactivityAbsorbers instanceof Array) {
                optionsCast.interactivity.modes.absorbers = interactivityAbsorbers.map((s) => {
                    const tmp = new Absorber_1.Absorber();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                let absorberOptions = optionsCast.interactivity.modes.absorbers;
                if ((absorberOptions === null || absorberOptions === void 0 ? void 0 : absorberOptions.load) === undefined) {
                    optionsCast.interactivity.modes.absorbers = absorberOptions = new Absorber_1.Absorber();
                }
                absorberOptions.load(interactivityAbsorbers);
            }
        }
    }
}
const plugin = new AbsorbersPlugin();
exports.AbsorbersPlugin = plugin;
__exportStar(__webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/AbsorberClickMode.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/AbsorberClickMode.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AbsorberClickMode = void 0;
var AbsorberClickMode;
(function (AbsorberClickMode) {
    AbsorberClickMode["absorber"] = "absorber";
})(AbsorberClickMode = exports.AbsorberClickMode || (exports.AbsorberClickMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./AbsorberClickMode */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/AbsorberClickMode.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/Absorber.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/Absorber.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Absorber = void 0;
const AbsorberSize_1 = __webpack_require__(/*! ./AbsorberSize */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/AbsorberSize.js");
const OptionsColor_1 = __webpack_require__(/*! ../../../../Options/Classes/OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class Absorber {
    constructor() {
        this.color = new OptionsColor_1.OptionsColor();
        this.color.value = "#000000";
        this.draggable = false;
        this.opacity = 1;
        this.destroy = true;
        this.orbits = false;
        this.size = new AbsorberSize_1.AbsorberSize();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        if (data.draggable !== undefined) {
            this.draggable = data.draggable;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
        if (data.position !== undefined) {
            this.position = {
                x: data.position.x,
                y: data.position.y,
            };
        }
        if (data.size !== undefined) {
            this.size.load(data.size);
        }
        if (data.destroy !== undefined) {
            this.destroy = data.destroy;
        }
        if (data.orbits !== undefined) {
            this.orbits = data.orbits;
        }
    }
}
exports.Absorber = Absorber;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/AbsorberSize.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/AbsorberSize.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AbsorberSize = void 0;
const ValueWithRandom_1 = __webpack_require__(/*! ../../../../Options/Classes/ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class AbsorberSize extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.density = 5;
        this.random.minimumValue = 1;
        this.value = 50;
    }
    load(data) {
        if (!data) {
            return;
        }
        super.load(data);
        if (data.density !== undefined) {
            this.density = data.density;
        }
        if (data.limit !== undefined) {
            this.limit = data.limit;
        }
        if (data.limit !== undefined) {
            this.limit = data.limit;
        }
    }
}
exports.AbsorberSize = AbsorberSize;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/EmitterInstance.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/EmitterInstance.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EmitterInstance = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const EmitterSize_1 = __webpack_require__(/*! ./Options/Classes/EmitterSize */ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterSize.js");
function randomCoordinate(position, offset) {
    return position + offset * (Math.random() - 0.5);
}
function randomPosition(position, offset) {
    return {
        x: randomCoordinate(position.x, offset.x),
        y: randomCoordinate(position.y, offset.y),
    };
}
class EmitterInstance {
    constructor(emitters, container, emitterOptions, position) {
        var _a, _b, _c;
        this.emitters = emitters;
        this.container = container;
        this.initialPosition = position;
        this.emitterOptions = Utils_1.Utils.deepExtend({}, emitterOptions);
        this.position = (_a = this.initialPosition) !== null && _a !== void 0 ? _a : this.calcPosition();
        let particlesOptions = Utils_1.Utils.deepExtend({}, this.emitterOptions.particles);
        if (particlesOptions === undefined) {
            particlesOptions = {};
        }
        if (particlesOptions.move === undefined) {
            particlesOptions.move = {};
        }
        if (particlesOptions.move.direction === undefined) {
            particlesOptions.move.direction = this.emitterOptions.direction;
        }
        this.particlesOptions = particlesOptions;
        this.size = (_b = this.emitterOptions.size) !== null && _b !== void 0 ? _b : (() => {
            const size = new EmitterSize_1.EmitterSize();
            size.load({
                height: 0,
                mode: Enums_1.SizeMode.percent,
                width: 0,
            });
            return size;
        })();
        this.lifeCount = (_c = this.emitterOptions.life.count) !== null && _c !== void 0 ? _c : -1;
        this.immortal = this.lifeCount <= 0;
        this.play();
    }
    play() {
        if (this.container.retina.reduceFactor &&
            (this.lifeCount > 0 || this.immortal || !this.emitterOptions.life.count)) {
            if (this.startInterval === undefined) {
                const delay = (1000 * this.emitterOptions.rate.delay) / this.container.retina.reduceFactor;
                this.startInterval = window.setInterval(() => {
                    this.emit();
                }, delay);
            }
            if (this.lifeCount > 0 || this.immortal) {
                this.prepareToDie();
            }
        }
    }
    pause() {
        const interval = this.startInterval;
        if (interval !== undefined) {
            clearInterval(interval);
            delete this.startInterval;
        }
    }
    resize() {
        const initialPosition = this.initialPosition;
        this.position =
            initialPosition && Utils_1.Utils.isPointInside(initialPosition, this.container.canvas.size)
                ? initialPosition
                : this.calcPosition();
    }
    prepareToDie() {
        var _a;
        const duration = (_a = this.emitterOptions.life) === null || _a === void 0 ? void 0 : _a.duration;
        if (this.container.retina.reduceFactor &&
            (this.lifeCount > 0 || this.immortal) &&
            duration !== undefined &&
            duration > 0) {
            setTimeout(() => {
                var _a;
                this.pause();
                if (!this.immortal) {
                    this.lifeCount--;
                }
                if (this.lifeCount > 0 || this.immortal) {
                    this.position = this.calcPosition();
                    setTimeout(() => {
                        this.play();
                    }, (((_a = this.emitterOptions.life.delay) !== null && _a !== void 0 ? _a : 0) * 1000) / this.container.retina.reduceFactor);
                }
                else {
                    this.destroy();
                }
            }, duration * 1000);
        }
    }
    destroy() {
        this.emitters.removeEmitter(this);
    }
    calcPosition() {
        var _a, _b;
        const container = this.container;
        const percentPosition = this.emitterOptions.position;
        return {
            x: (((_a = percentPosition === null || percentPosition === void 0 ? void 0 : percentPosition.x) !== null && _a !== void 0 ? _a : Math.random() * 100) / 100) * container.canvas.size.width,
            y: (((_b = percentPosition === null || percentPosition === void 0 ? void 0 : percentPosition.y) !== null && _b !== void 0 ? _b : Math.random() * 100) / 100) * container.canvas.size.height,
        };
    }
    emit() {
        const container = this.container;
        const position = this.position;
        const offset = {
            x: this.size.mode === Enums_1.SizeMode.percent
                ? (container.canvas.size.width * this.size.width) / 100
                : this.size.width,
            y: this.size.mode === Enums_1.SizeMode.percent
                ? (container.canvas.size.height * this.size.height) / 100
                : this.size.height,
        };
        for (let i = 0; i < this.emitterOptions.rate.quantity; i++) {
            container.particles.addParticle(randomPosition(position, offset), this.particlesOptions);
        }
    }
}
exports.EmitterInstance = EmitterInstance;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Emitters.js":
/*!********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Emitters.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Emitters = void 0;
const EmitterInstance_1 = __webpack_require__(/*! ./EmitterInstance */ "./node_modules/tsparticles/dist/Plugins/Emitters/EmitterInstance.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Emitter_1 = __webpack_require__(/*! ./Options/Classes/Emitter */ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/Emitter.js");
const Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/index.js");
class Emitters {
    constructor(container) {
        this.container = container;
        this.array = [];
        this.emitters = [];
        this.interactivityEmitters = [];
        const overridableContainer = container;
        overridableContainer.addEmitter = (options, position) => this.addEmitter(options, position);
    }
    init(options) {
        var _a, _b;
        if (!options) {
            return;
        }
        if (options.emitters) {
            if (options.emitters instanceof Array) {
                this.emitters = options.emitters.map((s) => {
                    const tmp = new Emitter_1.Emitter();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                if (this.emitters instanceof Array) {
                    this.emitters = new Emitter_1.Emitter();
                }
                this.emitters.load(options.emitters);
            }
        }
        const interactivityEmitters = (_b = (_a = options.interactivity) === null || _a === void 0 ? void 0 : _a.modes) === null || _b === void 0 ? void 0 : _b.emitters;
        if (interactivityEmitters) {
            if (interactivityEmitters instanceof Array) {
                this.interactivityEmitters = interactivityEmitters.map((s) => {
                    const tmp = new Emitter_1.Emitter();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                if (this.interactivityEmitters instanceof Array) {
                    this.interactivityEmitters = new Emitter_1.Emitter();
                }
                this.interactivityEmitters.load(interactivityEmitters);
            }
        }
        if (this.emitters instanceof Array) {
            for (const emitterOptions of this.emitters) {
                this.addEmitter(emitterOptions);
            }
        }
        else {
            this.addEmitter(this.emitters);
        }
    }
    play() {
        for (const emitter of this.array) {
            emitter.play();
        }
    }
    pause() {
        for (const emitter of this.array) {
            emitter.pause();
        }
    }
    stop() {
        this.array = [];
    }
    handleClickMode(mode) {
        const container = this.container;
        const emitterOptions = this.emitters;
        const modeEmitters = this.interactivityEmitters;
        if (mode === Enums_1.EmitterClickMode.emitter) {
            let emitterModeOptions;
            if (modeEmitters instanceof Array) {
                if (modeEmitters.length > 0) {
                    emitterModeOptions = Utils_1.Utils.itemFromArray(modeEmitters);
                }
            }
            else {
                emitterModeOptions = modeEmitters;
            }
            const emittersOptions = emitterModeOptions !== null && emitterModeOptions !== void 0 ? emitterModeOptions : (emitterOptions instanceof Array ? Utils_1.Utils.itemFromArray(emitterOptions) : emitterOptions);
            const ePosition = container.interactivity.mouse.clickPosition;
            this.addEmitter(Utils_1.Utils.deepExtend({}, emittersOptions), ePosition);
        }
    }
    resize() {
        for (const emitter of this.array) {
            emitter.resize();
        }
    }
    addEmitter(options, position) {
        const emitter = new EmitterInstance_1.EmitterInstance(this, this.container, options, position);
        this.array.push(emitter);
        return emitter;
    }
    removeEmitter(emitter) {
        const index = this.array.indexOf(emitter);
        if (index >= 0) {
            this.array.splice(index, 1);
        }
    }
}
exports.Emitters = Emitters;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/EmittersPlugin.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/EmittersPlugin.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmittersPlugin = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Emitters_1 = __webpack_require__(/*! ./Emitters */ "./node_modules/tsparticles/dist/Plugins/Emitters/Emitters.js");
const Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/index.js");
const Emitter_1 = __webpack_require__(/*! ./Options/Classes/Emitter */ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/Emitter.js");
class EmittersPlugin {
    constructor() {
        this.id = "emitters";
    }
    getPlugin(container) {
        return new Emitters_1.Emitters(container);
    }
    needsPlugin(options) {
        var _a, _b, _c;
        if (options === undefined) {
            return false;
        }
        const emitters = options.emitters;
        let loadEmitters = false;
        if (emitters instanceof Array) {
            if (emitters.length) {
                loadEmitters = true;
            }
        }
        else if (emitters !== undefined) {
            loadEmitters = true;
        }
        else if (((_c = (_b = (_a = options.interactivity) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.onClick) === null || _c === void 0 ? void 0 : _c.mode) &&
            Utils_1.Utils.isInArray(Enums_1.EmitterClickMode.emitter, options.interactivity.events.onClick.mode)) {
            loadEmitters = true;
        }
        return loadEmitters;
    }
    loadOptions(options, source) {
        var _a, _b;
        if (!this.needsPlugin(options) && !this.needsPlugin(source)) {
            return;
        }
        const optionsCast = options;
        if (source === null || source === void 0 ? void 0 : source.emitters) {
            if ((source === null || source === void 0 ? void 0 : source.emitters) instanceof Array) {
                optionsCast.emitters = source === null || source === void 0 ? void 0 : source.emitters.map((s) => {
                    const tmp = new Emitter_1.Emitter();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                let emitterOptions = optionsCast.emitters;
                if ((emitterOptions === null || emitterOptions === void 0 ? void 0 : emitterOptions.load) === undefined) {
                    optionsCast.emitters = emitterOptions = new Emitter_1.Emitter();
                }
                emitterOptions.load(source === null || source === void 0 ? void 0 : source.emitters);
            }
        }
        const interactivityEmitters = (_b = (_a = source === null || source === void 0 ? void 0 : source.interactivity) === null || _a === void 0 ? void 0 : _a.modes) === null || _b === void 0 ? void 0 : _b.emitters;
        if (interactivityEmitters) {
            if (interactivityEmitters instanceof Array) {
                optionsCast.interactivity.modes.emitters = interactivityEmitters.map((s) => {
                    const tmp = new Emitter_1.Emitter();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                let emitterOptions = optionsCast.interactivity.modes.emitters;
                if ((emitterOptions === null || emitterOptions === void 0 ? void 0 : emitterOptions.load) === undefined) {
                    optionsCast.interactivity.modes.emitters = emitterOptions = new Emitter_1.Emitter();
                }
                emitterOptions.load(interactivityEmitters);
            }
        }
    }
}
const plugin = new EmittersPlugin();
exports.EmittersPlugin = plugin;
__exportStar(__webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/EmitterClickMode.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Enums/EmitterClickMode.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EmitterClickMode = void 0;
var EmitterClickMode;
(function (EmitterClickMode) {
    EmitterClickMode["emitter"] = "emitter";
})(EmitterClickMode = exports.EmitterClickMode || (exports.EmitterClickMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Enums/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./EmitterClickMode */ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/EmitterClickMode.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/Emitter.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/Emitter.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Emitter = void 0;
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const EmitterRate_1 = __webpack_require__(/*! ./EmitterRate */ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterRate.js");
const EmitterLife_1 = __webpack_require__(/*! ./EmitterLife */ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterLife.js");
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const EmitterSize_1 = __webpack_require__(/*! ./EmitterSize */ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterSize.js");
class Emitter {
    constructor() {
        this.direction = Enums_1.MoveDirection.none;
        this.life = new EmitterLife_1.EmitterLife();
        this.rate = new EmitterRate_1.EmitterRate();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.size !== undefined) {
            if (this.size === undefined) {
                this.size = new EmitterSize_1.EmitterSize();
            }
            this.size.load(data.size);
        }
        if (data.direction !== undefined) {
            this.direction = data.direction;
        }
        this.life.load(data.life);
        if (data.particles !== undefined) {
            this.particles = Utils_1.Utils.deepExtend({}, data.particles);
        }
        this.rate.load(data.rate);
        if (data.position !== undefined) {
            this.position = {
                x: data.position.x,
                y: data.position.y,
            };
        }
    }
}
exports.Emitter = Emitter;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterLife.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterLife.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EmitterLife = void 0;
class EmitterLife {
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.count !== undefined) {
            this.count = data.count;
        }
        if (data.delay !== undefined) {
            this.delay = data.delay;
        }
        if (data.duration !== undefined) {
            this.duration = data.duration;
        }
    }
}
exports.EmitterLife = EmitterLife;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterRate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterRate.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EmitterRate = void 0;
class EmitterRate {
    constructor() {
        this.quantity = 1;
        this.delay = 0.1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.quantity !== undefined) {
            this.quantity = data.quantity;
        }
        if (data.delay !== undefined) {
            this.delay = data.delay;
        }
    }
}
exports.EmitterRate = EmitterRate;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterSize.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterSize.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EmitterSize = void 0;
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
class EmitterSize {
    constructor() {
        this.mode = Enums_1.SizeMode.percent;
        this.height = 0;
        this.width = 0;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
        if (data.height !== undefined) {
            this.height = data.height;
        }
        if (data.width !== undefined) {
            this.width = data.width;
        }
    }
}
exports.EmitterSize = EmitterSize;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/InlineArrangement.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/InlineArrangement.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InlineArrangement = void 0;
var InlineArrangement;
(function (InlineArrangement) {
    InlineArrangement["equidistant"] = "equidistant";
    InlineArrangement["onePerPoint"] = "one-per-point";
    InlineArrangement["perPoint"] = "per-point";
    InlineArrangement["randomLength"] = "random-length";
    InlineArrangement["randomPoint"] = "random-point";
})(InlineArrangement = exports.InlineArrangement || (exports.InlineArrangement = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/MoveType.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/MoveType.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MoveType = void 0;
var MoveType;
(function (MoveType) {
    MoveType["path"] = "path";
    MoveType["radius"] = "radius";
})(MoveType = exports.MoveType || (exports.MoveType = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/Type.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/Type.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = void 0;
var Type;
(function (Type) {
    Type["inline"] = "inline";
    Type["inside"] = "inside";
    Type["outside"] = "outside";
    Type["none"] = "none";
})(Type = exports.Type || (exports.Type = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./InlineArrangement */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/InlineArrangement.js"), exports);
__exportStar(__webpack_require__(/*! ./MoveType */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/MoveType.js"), exports);
__exportStar(__webpack_require__(/*! ./Type */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/Type.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Draw.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Draw.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Draw = void 0;
const DrawStroke_1 = __webpack_require__(/*! ./DrawStroke */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/DrawStroke.js");
const OptionsColor_1 = __webpack_require__(/*! ../../../../Options/Classes/OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class Draw {
    constructor() {
        this.enable = false;
        this.stroke = new DrawStroke_1.DrawStroke();
    }
    get lineWidth() {
        return this.stroke.width;
    }
    set lineWidth(value) {
        this.stroke.width = value;
    }
    get lineColor() {
        return this.stroke.color;
    }
    set lineColor(value) {
        this.stroke.color = OptionsColor_1.OptionsColor.create(this.stroke.color, value);
    }
    load(data) {
        var _a;
        if (data !== undefined) {
            if (data.enable !== undefined) {
                this.enable = data.enable;
            }
            const stroke = (_a = data.stroke) !== null && _a !== void 0 ? _a : {
                color: data.lineColor,
                width: data.lineWidth,
            };
            this.stroke.load(stroke);
        }
    }
}
exports.Draw = Draw;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/DrawStroke.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/DrawStroke.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DrawStroke = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../../../Options/Classes/OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class DrawStroke {
    constructor() {
        this.color = new OptionsColor_1.OptionsColor();
        this.width = 0.5;
        this.opacity = 1;
    }
    load(data) {
        var _a;
        if (data !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
            if (typeof this.color.value === "string") {
                this.opacity = (_a = Utils_1.ColorUtils.stringToAlpha(this.color.value)) !== null && _a !== void 0 ? _a : this.opacity;
            }
            if (data.opacity !== undefined) {
                this.opacity = data.opacity;
            }
            if (data.width !== undefined) {
                this.width = data.width;
            }
        }
    }
}
exports.DrawStroke = DrawStroke;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Inline.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Inline.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Inline = void 0;
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
class Inline {
    constructor() {
        this.arrangement = Enums_1.InlineArrangement.onePerPoint;
    }
    load(data) {
        if (data !== undefined) {
            if (data.arrangement !== undefined) {
                this.arrangement = data.arrangement;
            }
        }
    }
}
exports.Inline = Inline;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/LocalSvg.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/LocalSvg.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalSvg = void 0;
class LocalSvg {
    constructor() {
        this.path = [];
        this.size = {
            height: 0,
            width: 0,
        };
    }
    load(data) {
        if (data !== undefined) {
            if (data.path !== undefined) {
                this.path = data.path;
            }
            if (data.size !== undefined) {
                if (data.size.width !== undefined) {
                    this.size.width = data.size.width;
                }
                if (data.size.height !== undefined) {
                    this.size.height = data.size.height;
                }
            }
        }
    }
}
exports.LocalSvg = LocalSvg;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Move.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Move.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Move = void 0;
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
class Move {
    constructor() {
        this.radius = 10;
        this.type = Enums_1.MoveType.path;
    }
    load(data) {
        if (data !== undefined) {
            if (data.radius !== undefined) {
                this.radius = data.radius;
            }
            if (data.type !== undefined) {
                this.type = data.type;
            }
        }
    }
}
exports.Move = Move;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/PolygonMask.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/PolygonMask.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonMask = void 0;
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
const Draw_1 = __webpack_require__(/*! ./Draw */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Draw.js");
const Move_1 = __webpack_require__(/*! ./Move */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Move.js");
const Inline_1 = __webpack_require__(/*! ./Inline */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Inline.js");
const LocalSvg_1 = __webpack_require__(/*! ./LocalSvg */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/LocalSvg.js");
class PolygonMask {
    constructor() {
        this.draw = new Draw_1.Draw();
        this.enable = false;
        this.inline = new Inline_1.Inline();
        this.move = new Move_1.Move();
        this.scale = 1;
        this.type = Enums_1.Type.none;
    }
    get inlineArrangement() {
        return this.inline.arrangement;
    }
    set inlineArrangement(value) {
        this.inline.arrangement = value;
    }
    load(data) {
        var _a;
        if (data !== undefined) {
            this.draw.load(data.draw);
            const inline = (_a = data.inline) !== null && _a !== void 0 ? _a : {
                arrangement: data.inlineArrangement,
            };
            if (inline !== undefined) {
                this.inline.load(inline);
            }
            this.move.load(data.move);
            if (data.scale !== undefined) {
                this.scale = data.scale;
            }
            if (data.type !== undefined) {
                this.type = data.type;
            }
            if (data.enable !== undefined) {
                this.enable = data.enable;
            }
            else {
                this.enable = this.type !== Enums_1.Type.none;
            }
            if (data.url !== undefined) {
                this.url = data.url;
            }
            if (data.data !== undefined) {
                if (typeof data.data === "string") {
                    this.data = data.data;
                }
                else {
                    this.data = new LocalSvg_1.LocalSvg();
                    this.data.load(data.data);
                }
            }
            if (data.position !== undefined) {
                this.position = {
                    x: data.position.x,
                    y: data.position.y,
                };
            }
        }
    }
}
exports.PolygonMask = PolygonMask;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskInstance.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskInstance.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonMaskInstance = void 0;
const Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const PolygonMask_1 = __webpack_require__(/*! ./Options/Classes/PolygonMask */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/PolygonMask.js");
function polygonBounce(particle) {
    particle.velocity.horizontal = particle.velocity.vertical / 2 - particle.velocity.horizontal;
    particle.velocity.vertical = particle.velocity.horizontal / 2 - particle.velocity.vertical;
}
function drawPolygonMask(context, rawData, stroke) {
    const color = Utils_1.ColorUtils.colorToRgb(stroke.color);
    if (!color) {
        return;
    }
    context.beginPath();
    context.moveTo(rawData[0].x, rawData[0].y);
    for (const item of rawData) {
        context.lineTo(item.x, item.y);
    }
    context.closePath();
    context.strokeStyle = Utils_1.ColorUtils.getStyleFromRgb(color);
    context.lineWidth = stroke.width;
    context.stroke();
}
function drawPolygonMaskPath(context, path, stroke, position) {
    context.translate(position.x, position.y);
    const color = Utils_1.ColorUtils.colorToRgb(stroke.color);
    if (!color) {
        return;
    }
    context.strokeStyle = Utils_1.ColorUtils.getStyleFromRgb(color, stroke.opacity);
    context.lineWidth = stroke.width;
    context.stroke(path);
}
function parsePaths(paths, scale, offset) {
    const res = [];
    for (const path of paths) {
        const segments = path.element.pathSegList;
        const len = segments.numberOfItems;
        const p = {
            x: 0,
            y: 0,
        };
        for (let i = 0; i < len; i++) {
            const segment = segments.getItem(i);
            const svgPathSeg = window.SVGPathSeg;
            switch (segment.pathSegType) {
                case svgPathSeg.PATHSEG_MOVETO_ABS:
                case svgPathSeg.PATHSEG_LINETO_ABS:
                case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:
                case svgPathSeg.PATHSEG_ARC_ABS:
                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:
                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: {
                    const absSeg = segment;
                    p.x = absSeg.x;
                    p.y = absSeg.y;
                    break;
                }
                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:
                    p.x = segment.x;
                    break;
                case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:
                    p.y = segment.y;
                    break;
                case svgPathSeg.PATHSEG_LINETO_REL:
                case svgPathSeg.PATHSEG_MOVETO_REL:
                case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:
                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:
                case svgPathSeg.PATHSEG_ARC_REL:
                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:
                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: {
                    const relSeg = segment;
                    p.x += relSeg.x;
                    p.y += relSeg.y;
                    break;
                }
                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:
                    p.x += segment.x;
                    break;
                case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:
                    p.y += segment.y;
                    break;
                case svgPathSeg.PATHSEG_UNKNOWN:
                case svgPathSeg.PATHSEG_CLOSEPATH:
                    continue;
            }
            res.push({
                x: p.x * scale + offset.x,
                y: p.y * scale + offset.y,
            });
        }
    }
    return res;
}
class PolygonMaskInstance {
    constructor(container) {
        this.container = container;
        this.dimension = {
            height: 0,
            width: 0,
        };
        this.path2DSupported = !!window.Path2D;
        this.options = new PolygonMask_1.PolygonMask();
        this.polygonMaskMoveRadius = this.options.move.radius * container.retina.pixelRatio;
    }
    initAsync(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.options.load(options === null || options === void 0 ? void 0 : options.polygon);
            const polygonMaskOptions = this.options;
            this.polygonMaskMoveRadius = polygonMaskOptions.move.radius * this.container.retina.pixelRatio;
            if (polygonMaskOptions.enable) {
                yield this.initRawData();
            }
        });
    }
    resize() {
        const container = this.container;
        const options = this.options;
        if (!(options.enable && options.type !== Enums_1.Type.none)) {
            return;
        }
        if (this.redrawTimeout) {
            clearTimeout(this.redrawTimeout);
        }
        this.redrawTimeout = window.setTimeout(() => __awaiter(this, void 0, void 0, function* () {
            yield this.initRawData(true);
            container.particles.redraw();
        }), 250);
    }
    stop() {
        delete this.raw;
        delete this.paths;
    }
    particlesInitialization() {
        const options = this.options;
        if (options.enable &&
            options.type === Enums_1.Type.inline &&
            (options.inline.arrangement === Enums_1.InlineArrangement.onePerPoint ||
                options.inline.arrangement === Enums_1.InlineArrangement.perPoint)) {
            this.drawPoints();
            return true;
        }
        return false;
    }
    particlePosition(position) {
        var _a, _b;
        const options = this.options;
        if (!(options.enable && ((_b = (_a = this.raw) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0)) {
            return;
        }
        return Utils_1.Utils.deepExtend({}, position ? position : this.randomPoint());
    }
    particleBounce(particle) {
        const options = this.options;
        if (options.enable && options.type !== Enums_1.Type.none && options.type !== Enums_1.Type.inline) {
            if (!this.checkInsidePolygon(particle.getPosition())) {
                polygonBounce(particle);
                return true;
            }
        }
        else if (options.enable && options.type === Enums_1.Type.inline && particle.initialPosition) {
            const dist = Utils_1.NumberUtils.getDistance(particle.initialPosition, particle.getPosition());
            if (dist > this.polygonMaskMoveRadius) {
                polygonBounce(particle);
                return true;
            }
        }
        return false;
    }
    clickPositionValid(position) {
        const options = this.options;
        return (options.enable &&
            options.type !== Enums_1.Type.none &&
            options.type !== Enums_1.Type.inline &&
            this.checkInsidePolygon(position));
    }
    draw(context) {
        var _a;
        if (!((_a = this.paths) === null || _a === void 0 ? void 0 : _a.length)) {
            return;
        }
        const options = this.options;
        const polygonDraw = options.draw;
        if (!(options.enable && polygonDraw.enable)) {
            return;
        }
        const rawData = this.raw;
        for (const path of this.paths) {
            const path2d = path.path2d;
            const path2dSupported = this.path2DSupported;
            if (!context) {
                continue;
            }
            if (path2dSupported && path2d && this.offset) {
                drawPolygonMaskPath(context, path2d, polygonDraw.stroke, this.offset);
            }
            else if (rawData) {
                drawPolygonMask(context, rawData, polygonDraw.stroke);
            }
        }
    }
    checkInsidePolygon(position) {
        var _a, _b;
        const container = this.container;
        const options = this.options;
        if (!options.enable || options.type === Enums_1.Type.none || options.type === Enums_1.Type.inline) {
            return true;
        }
        if (!this.raw) {
            throw new Error(Utils_1.Constants.noPolygonFound);
        }
        const canvasSize = container.canvas.size;
        const x = (_a = position === null || position === void 0 ? void 0 : position.x) !== null && _a !== void 0 ? _a : Math.random() * canvasSize.width;
        const y = (_b = position === null || position === void 0 ? void 0 : position.y) !== null && _b !== void 0 ? _b : Math.random() * canvasSize.height;
        let inside = false;
        for (let i = 0, j = this.raw.length - 1; i < this.raw.length; j = i++) {
            const pi = this.raw[i];
            const pj = this.raw[j];
            const intersect = pi.y > y !== pj.y > y && x < ((pj.x - pi.x) * (y - pi.y)) / (pj.y - pi.y) + pi.x;
            if (intersect) {
                inside = !inside;
            }
        }
        return options.type === Enums_1.Type.inside ? inside : options.type === Enums_1.Type.outside ? !inside : false;
    }
    parseSvgPath(xml, force) {
        var _a, _b, _c;
        const forceDownload = force !== null && force !== void 0 ? force : false;
        if (this.paths !== undefined && !forceDownload) {
            return this.raw;
        }
        const container = this.container;
        const options = this.options;
        const parser = new DOMParser();
        const doc = parser.parseFromString(xml, "image/svg+xml");
        const svg = doc.getElementsByTagName("svg")[0];
        let svgPaths = svg.getElementsByTagName("path");
        if (!svgPaths.length) {
            svgPaths = doc.getElementsByTagName("path");
        }
        this.paths = [];
        for (let i = 0; i < svgPaths.length; i++) {
            const path = svgPaths.item(i);
            if (path) {
                this.paths.push({
                    element: path,
                    length: path.getTotalLength(),
                });
            }
        }
        const pxRatio = container.retina.pixelRatio;
        const scale = options.scale / pxRatio;
        this.dimension.width = parseFloat((_a = svg.getAttribute("width")) !== null && _a !== void 0 ? _a : "0") * scale;
        this.dimension.height = parseFloat((_b = svg.getAttribute("height")) !== null && _b !== void 0 ? _b : "0") * scale;
        const position = (_c = options.position) !== null && _c !== void 0 ? _c : {
            x: 50,
            y: 50,
        };
        this.offset = {
            x: (container.canvas.size.width * position.x) / (100 * pxRatio) - this.dimension.width / 2,
            y: (container.canvas.size.height * position.y) / (100 * pxRatio) - this.dimension.height / 2,
        };
        return parsePaths(this.paths, scale, this.offset);
    }
    downloadSvgPath(svgUrl, force) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.options;
            const url = svgUrl || options.url;
            const forceDownload = force !== null && force !== void 0 ? force : false;
            if (!url || (this.paths !== undefined && !forceDownload)) {
                return this.raw;
            }
            const req = yield fetch(url);
            if (!req.ok) {
                throw new Error("tsParticles Error - Error occurred during polygon mask download");
            }
            return this.parseSvgPath(yield req.text(), force);
        });
    }
    drawPoints() {
        if (!this.raw) {
            return;
        }
        for (const item of this.raw) {
            this.container.particles.addParticle({
                x: item.x,
                y: item.y,
            });
        }
    }
    randomPoint() {
        const container = this.container;
        const options = this.options;
        let position;
        if (options.type === Enums_1.Type.inline) {
            switch (options.inline.arrangement) {
                case Enums_1.InlineArrangement.randomPoint:
                    position = this.getRandomPoint();
                    break;
                case Enums_1.InlineArrangement.randomLength:
                    position = this.getRandomPointByLength();
                    break;
                case Enums_1.InlineArrangement.equidistant:
                    position = this.getEquidistantPointByIndex(container.particles.count);
                    break;
                case Enums_1.InlineArrangement.onePerPoint:
                case Enums_1.InlineArrangement.perPoint:
                default:
                    position = this.getPointByIndex(container.particles.count);
            }
        }
        else {
            position = {
                x: Math.random() * container.canvas.size.width,
                y: Math.random() * container.canvas.size.height,
            };
        }
        if (this.checkInsidePolygon(position)) {
            return position;
        }
        else {
            return this.randomPoint();
        }
    }
    getRandomPoint() {
        if (!this.raw || !this.raw.length) {
            throw new Error(Utils_1.Constants.noPolygonDataLoaded);
        }
        const coords = Utils_1.Utils.itemFromArray(this.raw);
        return {
            x: coords.x,
            y: coords.y,
        };
    }
    getRandomPointByLength() {
        var _a, _b, _c;
        const options = this.options;
        if (!this.raw || !this.raw.length || !((_a = this.paths) === null || _a === void 0 ? void 0 : _a.length)) {
            throw new Error(Utils_1.Constants.noPolygonDataLoaded);
        }
        const path = Utils_1.Utils.itemFromArray(this.paths);
        const distance = Math.floor(Math.random() * path.length) + 1;
        const point = path.element.getPointAtLength(distance);
        return {
            x: point.x * options.scale + (((_b = this.offset) === null || _b === void 0 ? void 0 : _b.x) || 0),
            y: point.y * options.scale + (((_c = this.offset) === null || _c === void 0 ? void 0 : _c.y) || 0),
        };
    }
    getEquidistantPointByIndex(index) {
        var _a, _b, _c, _d, _e, _f, _g;
        const options = this.container.options;
        const polygonMaskOptions = this.options;
        if (!this.raw || !this.raw.length || !((_a = this.paths) === null || _a === void 0 ? void 0 : _a.length))
            throw new Error(Utils_1.Constants.noPolygonDataLoaded);
        let offset = 0;
        let point;
        const totalLength = this.paths.reduce((tot, path) => tot + path.length, 0);
        const distance = totalLength / options.particles.number.value;
        for (const path of this.paths) {
            const pathDistance = distance * index - offset;
            if (pathDistance <= path.length) {
                point = path.element.getPointAtLength(pathDistance);
                break;
            }
            else {
                offset += path.length;
            }
        }
        return {
            x: ((_b = point === null || point === void 0 ? void 0 : point.x) !== null && _b !== void 0 ? _b : 0) * polygonMaskOptions.scale + ((_d = (_c = this.offset) === null || _c === void 0 ? void 0 : _c.x) !== null && _d !== void 0 ? _d : 0),
            y: ((_e = point === null || point === void 0 ? void 0 : point.y) !== null && _e !== void 0 ? _e : 0) * polygonMaskOptions.scale + ((_g = (_f = this.offset) === null || _f === void 0 ? void 0 : _f.y) !== null && _g !== void 0 ? _g : 0),
        };
    }
    getPointByIndex(index) {
        if (!this.raw || !this.raw.length) {
            throw new Error(Utils_1.Constants.noPolygonDataLoaded);
        }
        const coords = this.raw[index % this.raw.length];
        return {
            x: coords.x,
            y: coords.y,
        };
    }
    createPath2D() {
        var _a, _b;
        const options = this.options;
        if (!this.path2DSupported || !((_a = this.paths) === null || _a === void 0 ? void 0 : _a.length)) {
            return;
        }
        for (const path of this.paths) {
            const pathData = (_b = path.element) === null || _b === void 0 ? void 0 : _b.getAttribute("d");
            if (pathData) {
                const path2d = new Path2D(pathData);
                const matrix = document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGMatrix();
                const finalPath = new Path2D();
                const transform = matrix.scale(options.scale);
                if (finalPath.addPath) {
                    finalPath.addPath(path2d, transform);
                    path.path2d = finalPath;
                }
                else {
                    delete path.path2d;
                }
            }
            else {
                delete path.path2d;
            }
            if (path.path2d || !this.raw) {
                continue;
            }
            path.path2d = new Path2D();
            path.path2d.moveTo(this.raw[0].x, this.raw[0].y);
            this.raw.forEach((pos, i) => {
                var _a;
                if (i > 0) {
                    (_a = path.path2d) === null || _a === void 0 ? void 0 : _a.lineTo(pos.x, pos.y);
                }
            });
            path.path2d.closePath();
        }
    }
    initRawData(force) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.options;
            if (options.url) {
                this.raw = yield this.downloadSvgPath(options.url, force);
            }
            else if (options.data) {
                const data = options.data;
                let svg;
                if (typeof data !== "string") {
                    const path = data.path instanceof Array
                        ? data.path.map((t) => `<path d="${t}" />`).join("")
                        : `<path d="${data.path}" />`;
                    const namespaces = 'xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"';
                    svg = `<svg ${namespaces} width="${data.size.width}" height="${data.size.height}">${path}</svg>`;
                }
                else {
                    svg = data;
                }
                this.raw = this.parseSvgPath(svg, force);
            }
            this.createPath2D();
        });
    }
}
exports.PolygonMaskInstance = PolygonMaskInstance;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskPlugin.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskPlugin.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonMaskPlugin = void 0;
const PolygonMaskInstance_1 = __webpack_require__(/*! ./PolygonMaskInstance */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskInstance.js");
const PolygonMask_1 = __webpack_require__(/*! ./Options/Classes/PolygonMask */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/PolygonMask.js");
const Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
class PolygonMaskPlugin {
    constructor() {
        this.id = "polygonMask";
    }
    getPlugin(container) {
        return new PolygonMaskInstance_1.PolygonMaskInstance(container);
    }
    needsPlugin(options) {
        var _a, _b, _c;
        return (_b = (_a = options === null || options === void 0 ? void 0 : options.polygon) === null || _a === void 0 ? void 0 : _a.enable) !== null && _b !== void 0 ? _b : (((_c = options === null || options === void 0 ? void 0 : options.polygon) === null || _c === void 0 ? void 0 : _c.type) !== undefined && options.polygon.type !== Enums_1.Type.none);
    }
    loadOptions(options, source) {
        if (!this.needsPlugin(source)) {
            return;
        }
        const optionsCast = options;
        let polygonOptions = optionsCast.polygon;
        if ((polygonOptions === null || polygonOptions === void 0 ? void 0 : polygonOptions.load) === undefined) {
            optionsCast.polygon = polygonOptions = new PolygonMask_1.PolygonMask();
        }
        polygonOptions.load(source === null || source === void 0 ? void 0 : source.polygon);
    }
}
const plugin = new PolygonMaskPlugin();
exports.PolygonMaskPlugin = plugin;
__exportStar(__webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/CircleDrawer.js":
/*!********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/CircleDrawer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CircleDrawer = void 0;
class CircleDrawer {
    getSidesCount() {
        return 12;
    }
    draw(context, particle, radius) {
        context.arc(0, 0, radius, 0, Math.PI * 2, false);
    }
}
exports.CircleDrawer = CircleDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/ImageDrawer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/ImageDrawer.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageDrawer = void 0;
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
class ImageDrawer {
    constructor() {
        this.images = [];
    }
    getSidesCount() {
        return 12;
    }
    getImages(container) {
        const containerImages = this.images.filter((t) => t.id === container.id);
        if (!containerImages.length) {
            this.images.push({
                id: container.id,
                images: [],
            });
            return this.getImages(container);
        }
        else {
            return containerImages[0];
        }
    }
    addImage(container, image) {
        const containerImages = this.getImages(container);
        containerImages === null || containerImages === void 0 ? void 0 : containerImages.images.push(image);
    }
    init(container) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const options = container.options;
            const shapeOptions = options.particles.shape;
            if (!Utils_1.Utils.isInArray(Enums_1.ShapeType.image, shapeOptions.type) &&
                !Utils_1.Utils.isInArray(Enums_1.ShapeType.images, shapeOptions.type)) {
                return;
            }
            const imageOptions = (_a = shapeOptions.options[Enums_1.ShapeType.images]) !== null && _a !== void 0 ? _a : shapeOptions.options[Enums_1.ShapeType.image];
            if (imageOptions instanceof Array) {
                for (const optionsImage of imageOptions) {
                    yield this.loadImageShape(container, optionsImage);
                }
            }
            else {
                yield this.loadImageShape(container, imageOptions);
            }
        });
    }
    destroy() {
        this.images = [];
    }
    loadImageShape(container, imageShape) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const image = imageShape.replaceColor
                    ? yield Utils_1.Utils.downloadSvgImage(imageShape.src)
                    : yield Utils_1.Utils.loadImage(imageShape.src);
                this.addImage(container, image);
            }
            catch (_a) {
                console.warn(`tsParticles error - ${imageShape.src} not found`);
            }
        });
    }
    draw(context, particle, radius, opacity) {
        var _a, _b;
        if (!context) {
            return;
        }
        const image = particle.image;
        const element = (_a = image === null || image === void 0 ? void 0 : image.data) === null || _a === void 0 ? void 0 : _a.element;
        if (!element) {
            return;
        }
        const ratio = (_b = image === null || image === void 0 ? void 0 : image.ratio) !== null && _b !== void 0 ? _b : 1;
        const pos = {
            x: -radius,
            y: -radius,
        };
        if (!(image === null || image === void 0 ? void 0 : image.data.svgData) || !(image === null || image === void 0 ? void 0 : image.replaceColor)) {
            context.globalAlpha = opacity;
        }
        context.drawImage(element, pos.x, pos.y, radius * 2, (radius * 2) / ratio);
        if (!(image === null || image === void 0 ? void 0 : image.data.svgData) || !(image === null || image === void 0 ? void 0 : image.replaceColor)) {
            context.globalAlpha = 1;
        }
    }
}
exports.ImageDrawer = ImageDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/LineDrawer.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/LineDrawer.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LineDrawer = void 0;
class LineDrawer {
    getSidesCount() {
        return 1;
    }
    draw(context, particle, radius) {
        context.moveTo(0, -radius / 2);
        context.lineTo(0, radius / 2);
    }
}
exports.LineDrawer = LineDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonDrawer = void 0;
const PolygonDrawerBase_1 = __webpack_require__(/*! ./PolygonDrawerBase */ "./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawerBase.js");
class PolygonDrawer extends PolygonDrawerBase_1.PolygonDrawerBase {
    getSidesData(particle, radius) {
        var _a, _b;
        const polygon = particle.shapeData;
        const sides = (_b = (_a = polygon === null || polygon === void 0 ? void 0 : polygon.sides) !== null && _a !== void 0 ? _a : polygon === null || polygon === void 0 ? void 0 : polygon.nb_sides) !== null && _b !== void 0 ? _b : 5;
        return {
            count: {
                denominator: 1,
                numerator: sides,
            },
            length: (radius * 2.66) / (sides / 3),
        };
    }
    getCenter(particle, radius) {
        const sides = this.getSidesCount(particle);
        return {
            x: -radius / (sides / 3.5),
            y: -radius / (2.66 / 3.5),
        };
    }
}
exports.PolygonDrawer = PolygonDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawerBase.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawerBase.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonDrawerBase = void 0;
class PolygonDrawerBase {
    getSidesCount(particle) {
        var _a, _b;
        const polygon = particle.shapeData;
        return (_b = (_a = polygon === null || polygon === void 0 ? void 0 : polygon.sides) !== null && _a !== void 0 ? _a : polygon === null || polygon === void 0 ? void 0 : polygon.nb_sides) !== null && _b !== void 0 ? _b : 5;
    }
    draw(context, particle, radius) {
        const start = this.getCenter(particle, radius);
        const side = this.getSidesData(particle, radius);
        const sideCount = side.count.numerator * side.count.denominator;
        const decimalSides = side.count.numerator / side.count.denominator;
        const interiorAngleDegrees = (180 * (decimalSides - 2)) / decimalSides;
        const interiorAngle = Math.PI - (Math.PI * interiorAngleDegrees) / 180;
        if (!context) {
            return;
        }
        context.beginPath();
        context.translate(start.x, start.y);
        context.moveTo(0, 0);
        for (let i = 0; i < sideCount; i++) {
            context.lineTo(side.length, 0);
            context.translate(side.length, 0);
            context.rotate(interiorAngle);
        }
    }
}
exports.PolygonDrawerBase = PolygonDrawerBase;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/SquareDrawer.js":
/*!********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/SquareDrawer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SquareDrawer = void 0;
class SquareDrawer {
    getSidesCount() {
        return 4;
    }
    draw(context, particle, radius) {
        context.rect(-radius, -radius, radius * 2, radius * 2);
    }
}
exports.SquareDrawer = SquareDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/StarDrawer.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/StarDrawer.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StarDrawer = void 0;
class StarDrawer {
    getSidesCount(particle) {
        var _a, _b;
        const star = particle.shapeData;
        return (_b = (_a = star === null || star === void 0 ? void 0 : star.sides) !== null && _a !== void 0 ? _a : star === null || star === void 0 ? void 0 : star.nb_sides) !== null && _b !== void 0 ? _b : 5;
    }
    draw(context, particle, radius) {
        var _a;
        const star = particle.shapeData;
        const sides = this.getSidesCount(particle);
        const inset = (_a = star === null || star === void 0 ? void 0 : star.inset) !== null && _a !== void 0 ? _a : 2;
        context.moveTo(0, 0 - radius);
        for (let i = 0; i < sides; i++) {
            context.rotate(Math.PI / sides);
            context.lineTo(0, 0 - radius * inset);
            context.rotate(Math.PI / sides);
            context.lineTo(0, 0 - radius);
        }
    }
}
exports.StarDrawer = StarDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/TextDrawer.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/TextDrawer.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextDrawer = void 0;
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
class TextDrawer {
    getSidesCount() {
        return 12;
    }
    init(container) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const options = container.options;
            if (Utils_1.Utils.isInArray(Enums_1.ShapeType.char, options.particles.shape.type) ||
                Utils_1.Utils.isInArray(Enums_1.ShapeType.character, options.particles.shape.type)) {
                const shapeOptions = ((_a = options.particles.shape.options[Enums_1.ShapeType.character]) !== null && _a !== void 0 ? _a : options.particles.shape.options[Enums_1.ShapeType.char]);
                if (shapeOptions instanceof Array) {
                    for (const character of shapeOptions) {
                        yield Utils_1.Utils.loadFont(character);
                    }
                }
                else {
                    if (shapeOptions !== undefined) {
                        yield Utils_1.Utils.loadFont(shapeOptions);
                    }
                }
            }
        });
    }
    draw(context, particle, radius) {
        const character = particle.shapeData;
        if (character === undefined) {
            return;
        }
        const textData = character.value;
        if (textData === undefined) {
            return;
        }
        const textParticle = particle;
        if (textParticle.text === undefined) {
            textParticle.text =
                textData instanceof Array ? Utils_1.Utils.itemFromArray(textData, particle.randomIndexData) : textData;
        }
        const text = textParticle.text;
        const style = character.style;
        const weight = character.weight;
        const size = Math.round(radius) * 2;
        const font = character.font;
        const fill = particle.fill;
        const offsetX = (text.length * radius) / 2;
        context.font = `${style} ${weight} ${size}px "${font}"`;
        const pos = {
            x: -offsetX,
            y: radius / 2,
        };
        if (fill) {
            context.fillText(text, pos.x, pos.y);
        }
        else {
            context.strokeText(text, pos.x, pos.y);
        }
    }
}
exports.TextDrawer = TextDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/TriangleDrawer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/TriangleDrawer.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TriangleDrawer = void 0;
const PolygonDrawerBase_1 = __webpack_require__(/*! ./PolygonDrawerBase */ "./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawerBase.js");
class TriangleDrawer extends PolygonDrawerBase_1.PolygonDrawerBase {
    getSidesCount() {
        return 3;
    }
    getSidesData(particle, radius) {
        return {
            count: {
                denominator: 2,
                numerator: 3,
            },
            length: radius * 2,
        };
    }
    getCenter(particle, radius) {
        return {
            x: -radius,
            y: radius / 1.66,
        };
    }
}
exports.TriangleDrawer = TriangleDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Types/RecursivePartial.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Types/RecursivePartial.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Types/ShapeData.js":
/*!**********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Types/ShapeData.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Types/ShapeDrawerFunctions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Types/ShapeDrawerFunctions.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Types/SingleOrMultiple.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Types/SingleOrMultiple.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Types/index.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Types/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./RecursivePartial */ "./node_modules/tsparticles/dist/Types/RecursivePartial.js"), exports);
__exportStar(__webpack_require__(/*! ./ShapeData */ "./node_modules/tsparticles/dist/Types/ShapeData.js"), exports);
__exportStar(__webpack_require__(/*! ./ShapeDrawerFunctions */ "./node_modules/tsparticles/dist/Types/ShapeDrawerFunctions.js"), exports);
__exportStar(__webpack_require__(/*! ./SingleOrMultiple */ "./node_modules/tsparticles/dist/Types/SingleOrMultiple.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/CanvasUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/CanvasUtils.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CanvasUtils = void 0;
const ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ "./node_modules/tsparticles/dist/Utils/ColorUtils.js");
const NumberUtils_1 = __webpack_require__(/*! ./NumberUtils */ "./node_modules/tsparticles/dist/Utils/NumberUtils.js");
function drawLine(context, begin, end) {
    context.beginPath();
    context.moveTo(begin.x, begin.y);
    context.lineTo(end.x, end.y);
    context.closePath();
}
function drawTriangle(context, p1, p2, p3) {
    context.beginPath();
    context.moveTo(p1.x, p1.y);
    context.lineTo(p2.x, p2.y);
    context.lineTo(p3.x, p3.y);
    context.closePath();
}
class CanvasUtils {
    static paintBase(context, dimension, baseColor) {
        context.save();
        context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : "rgba(0,0,0,0)";
        context.fillRect(0, 0, dimension.width, dimension.height);
        context.restore();
    }
    static clear(context, dimension) {
        context.clearRect(0, 0, dimension.width, dimension.height);
    }
    static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {
        let drawn = false;
        if (NumberUtils_1.NumberUtils.getDistance(begin, end) <= maxDistance) {
            drawLine(context, begin, end);
            drawn = true;
        }
        else if (warp) {
            let pi1;
            let pi2;
            const endNE = {
                x: end.x - canvasSize.width,
                y: end.y,
            };
            const d1 = NumberUtils_1.NumberUtils.getDistances(begin, endNE);
            if (d1.distance <= maxDistance) {
                const yi = begin.y - (d1.dy / d1.dx) * begin.x;
                pi1 = { x: 0, y: yi };
                pi2 = { x: canvasSize.width, y: yi };
            }
            else {
                const endSW = {
                    x: end.x,
                    y: end.y - canvasSize.height,
                };
                const d2 = NumberUtils_1.NumberUtils.getDistances(begin, endSW);
                if (d2.distance <= maxDistance) {
                    const yi = begin.y - (d2.dy / d2.dx) * begin.x;
                    const xi = -yi / (d2.dy / d2.dx);
                    pi1 = { x: xi, y: 0 };
                    pi2 = { x: xi, y: canvasSize.height };
                }
                else {
                    const endSE = {
                        x: end.x - canvasSize.width,
                        y: end.y - canvasSize.height,
                    };
                    const d3 = NumberUtils_1.NumberUtils.getDistances(begin, endSE);
                    if (d3.distance <= maxDistance) {
                        const yi = begin.y - (d3.dy / d3.dx) * begin.x;
                        const xi = -yi / (d3.dy / d3.dx);
                        pi1 = { x: xi, y: yi };
                        pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };
                    }
                }
            }
            if (pi1 && pi2) {
                drawLine(context, begin, pi1);
                drawLine(context, end, pi2);
                drawn = true;
            }
        }
        if (!drawn) {
            return;
        }
        context.lineWidth = width;
        if (backgroundMask) {
            context.globalCompositeOperation = composite;
        }
        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);
        if (shadow.enable) {
            const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);
            if (shadowColor) {
                context.shadowBlur = shadow.blur;
                context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);
            }
        }
        context.stroke();
    }
    static drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {
        drawTriangle(context, pos1, pos2, pos3);
        if (backgroundMask) {
            context.globalCompositeOperation = composite;
        }
        context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);
        context.fill();
    }
    static drawConnectLine(context, width, lineStyle, begin, end) {
        context.save();
        drawLine(context, begin, end);
        context.lineWidth = width;
        context.strokeStyle = lineStyle;
        context.stroke();
        context.restore();
    }
    static gradient(context, p1, p2, opacity) {
        const gradStop = Math.floor(p2.getRadius() / p1.getRadius());
        const color1 = p1.getFillColor();
        const color2 = p2.getFillColor();
        if (!color1 || !color2) {
            return;
        }
        const sourcePos = p1.getPosition();
        const destPos = p2.getPosition();
        const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.getRadius(), p2.getRadius());
        const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);
        grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));
        grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));
        grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));
        return grad;
    }
    static drawGrabLine(context, width, begin, end, colorLine, opacity) {
        context.save();
        drawLine(context, begin, end);
        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);
        context.lineWidth = width;
        context.stroke();
        context.restore();
    }
    static drawLight(container, context, mousePos) {
        const lightOptions = container.options.interactivity.modes.light.area;
        context.beginPath();
        context.arc(mousePos.x, mousePos.y, lightOptions.radius, 0, 2 * Math.PI);
        const gradientAmbientLight = context.createRadialGradient(mousePos.x, mousePos.y, 0, mousePos.x, mousePos.y, lightOptions.radius);
        const gradient = lightOptions.gradient;
        const gradientRgb = {
            start: ColorUtils_1.ColorUtils.colorToRgb(gradient.start),
            stop: ColorUtils_1.ColorUtils.colorToRgb(gradient.stop),
        };
        if (!gradientRgb.start || !gradientRgb.stop) {
            return;
        }
        gradientAmbientLight.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.start));
        gradientAmbientLight.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.stop));
        context.fillStyle = gradientAmbientLight;
        context.fill();
    }
    static drawParticleShadow(container, context, particle, mousePos) {
        const pos = particle.getPosition();
        const shadowOptions = container.options.interactivity.modes.light.shadow;
        context.save();
        const radius = particle.getRadius();
        const sides = particle.sides;
        const full = (Math.PI * 2) / sides;
        const angle = -particle.rotate.value + Math.PI / 4;
        const factor = 1;
        const dots = [];
        for (let i = 0; i < sides; i++) {
            dots.push({
                x: pos.x + radius * Math.sin(angle + full * i) * factor,
                y: pos.y + radius * Math.cos(angle + full * i) * factor,
            });
        }
        const points = [];
        const shadowLength = shadowOptions.length;
        for (const dot of dots) {
            const dotAngle = Math.atan2(mousePos.y - dot.y, mousePos.x - dot.x);
            const endX = dot.x + shadowLength * Math.sin(-dotAngle - Math.PI / 2);
            const endY = dot.y + shadowLength * Math.cos(-dotAngle - Math.PI / 2);
            points.push({
                endX: endX,
                endY: endY,
                startX: dot.x,
                startY: dot.y,
            });
        }
        const shadowRgb = ColorUtils_1.ColorUtils.colorToRgb(shadowOptions.color);
        if (!shadowRgb) {
            return;
        }
        const shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowRgb);
        for (let i = points.length - 1; i >= 0; i--) {
            const n = i == points.length - 1 ? 0 : i + 1;
            context.beginPath();
            context.moveTo(points[i].startX, points[i].startY);
            context.lineTo(points[n].startX, points[n].startY);
            context.lineTo(points[n].endX, points[n].endY);
            context.lineTo(points[i].endX, points[i].endY);
            context.fillStyle = shadowColor;
            context.fill();
        }
        context.restore();
    }
    static drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow) {
        const pos = particle.getPosition();
        context.save();
        context.translate(pos.x, pos.y);
        context.beginPath();
        const angle = particle.rotate.value + (particle.particlesOptions.rotate.path ? particle.pathAngle : 0);
        if (angle !== 0) {
            context.rotate(angle);
        }
        if (backgroundMask) {
            context.globalCompositeOperation = composite;
        }
        const shadowColor = particle.shadowColor;
        if (shadow.enable && shadowColor) {
            context.shadowBlur = shadow.blur;
            context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);
            context.shadowOffsetX = shadow.offset.x;
            context.shadowOffsetY = shadow.offset.y;
        }
        if (fillColorValue) {
            context.fillStyle = fillColorValue;
        }
        const stroke = particle.stroke;
        context.lineWidth = particle.strokeWidth;
        if (strokeColorValue) {
            context.strokeStyle = strokeColorValue;
        }
        CanvasUtils.drawShape(container, context, particle, radius, opacity, delta);
        if (stroke.width > 0) {
            context.stroke();
        }
        if (particle.close) {
            context.closePath();
        }
        if (particle.fill) {
            context.fill();
        }
        context.restore();
        context.save();
        context.translate(pos.x, pos.y);
        if (angle !== 0) {
            context.rotate(angle);
        }
        if (backgroundMask) {
            context.globalCompositeOperation = composite;
        }
        CanvasUtils.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);
        context.restore();
    }
    static drawShape(container, context, particle, radius, opacity, delta) {
        if (!particle.shape) {
            return;
        }
        const drawer = container.drawers.get(particle.shape);
        if (!drawer) {
            return;
        }
        drawer.draw(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);
    }
    static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {
        if (!particle.shape) {
            return;
        }
        const drawer = container.drawers.get(particle.shape);
        if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {
            return;
        }
        drawer.afterEffect(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);
    }
    static drawPlugin(context, plugin, delta) {
        if (plugin.draw !== undefined) {
            context.save();
            plugin.draw(context, delta);
            context.restore();
        }
    }
}
exports.CanvasUtils = CanvasUtils;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Circle.js":
/*!*******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Circle.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Circle = void 0;
const Range_1 = __webpack_require__(/*! ./Range */ "./node_modules/tsparticles/dist/Utils/Range.js");
class Circle extends Range_1.Range {
    constructor(x, y, radius) {
        super(x, y);
        this.radius = radius;
    }
    contains(point) {
        const d = Math.pow(point.x - this.position.x, 2) + Math.pow(point.y - this.position.y, 2);
        return d <= this.radius * this.radius;
    }
    intersects(range) {
        const rect = range;
        const circle = range;
        const pos1 = this.position;
        const pos2 = range.position;
        const xDist = Math.abs(pos2.x - pos1.x);
        const yDist = Math.abs(pos2.y - pos1.y);
        const r = this.radius;
        if (circle.radius !== undefined) {
            const rSum = r + circle.radius;
            const dist = Math.sqrt(xDist * xDist + yDist + yDist);
            return rSum > dist;
        }
        else if (rect.size !== undefined) {
            const w = rect.size.width;
            const h = rect.size.height;
            const edges = Math.pow(xDist - w, 2) + Math.pow(yDist - h, 2);
            if (xDist > r + w || yDist > r + h) {
                return false;
            }
            if (xDist <= w || yDist <= h) {
                return true;
            }
            return edges <= r * r;
        }
        return false;
    }
}
exports.Circle = Circle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/CircleWarp.js":
/*!***********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/CircleWarp.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CircleWarp = void 0;
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./node_modules/tsparticles/dist/Utils/Rectangle.js");
const Circle_1 = __webpack_require__(/*! ./Circle */ "./node_modules/tsparticles/dist/Utils/Circle.js");
class CircleWarp extends Circle_1.Circle {
    constructor(x, y, radius, canvasSize) {
        super(x, y, radius);
        this.canvasSize = canvasSize;
        this.canvasSize = {
            height: canvasSize.height,
            width: canvasSize.width,
        };
    }
    contains(point) {
        if (super.contains(point)) {
            return true;
        }
        const posNE = {
            x: point.x - this.canvasSize.width,
            y: point.y,
        };
        if (super.contains(posNE)) {
            return true;
        }
        const posSE = {
            x: point.x - this.canvasSize.width,
            y: point.y - this.canvasSize.height,
        };
        if (super.contains(posSE)) {
            return true;
        }
        const posSW = {
            x: point.x,
            y: point.y - this.canvasSize.height,
        };
        return super.contains(posSW);
    }
    intersects(range) {
        if (super.intersects(range)) {
            return true;
        }
        const rect = range;
        const circle = range;
        const newPos = {
            x: range.position.x - this.canvasSize.width,
            y: range.position.y - this.canvasSize.height,
        };
        if (circle.radius !== undefined) {
            const biggerCircle = new Circle_1.Circle(newPos.x, newPos.y, circle.radius * 2);
            return super.intersects(biggerCircle);
        }
        else if (rect.size !== undefined) {
            const rectSW = new Rectangle_1.Rectangle(newPos.x, newPos.y, rect.size.width * 2, rect.size.height * 2);
            return super.intersects(rectSW);
        }
        return false;
    }
}
exports.CircleWarp = CircleWarp;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/ColorUtils.js":
/*!***********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/ColorUtils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorUtils = void 0;
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/tsparticles/dist/Utils/Utils.js");
const Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/tsparticles/dist/Utils/Constants.js");
const NumberUtils_1 = __webpack_require__(/*! ./NumberUtils */ "./node_modules/tsparticles/dist/Utils/NumberUtils.js");
function hue2rgb(p, q, t) {
    let tCalc = t;
    if (tCalc < 0) {
        tCalc += 1;
    }
    if (tCalc > 1) {
        tCalc -= 1;
    }
    if (tCalc < 1 / 6) {
        return p + (q - p) * 6 * tCalc;
    }
    if (tCalc < 1 / 2) {
        return q;
    }
    if (tCalc < 2 / 3) {
        return p + (q - p) * (2 / 3 - tCalc) * 6;
    }
    return p;
}
function stringToRgba(input) {
    if (input.startsWith("rgb")) {
        const regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.]+)\s*)?\)/i;
        const result = regex.exec(input);
        return result
            ? {
                a: result.length > 4 ? parseFloat(result[5]) : 1,
                b: parseInt(result[3], 10),
                g: parseInt(result[2], 10),
                r: parseInt(result[1], 10),
            }
            : undefined;
    }
    else if (input.startsWith("hsl")) {
        const regex = /hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.]+)\s*)?\)/i;
        const result = regex.exec(input);
        return result
            ? ColorUtils.hslaToRgba({
                a: result.length > 4 ? parseFloat(result[5]) : 1,
                h: parseInt(result[1], 10),
                l: parseInt(result[3], 10),
                s: parseInt(result[2], 10),
            })
            : undefined;
    }
    else if (input.startsWith("hsv")) {
        const regex = /hsva?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.]+)\s*)?\)/i;
        const result = regex.exec(input);
        return result
            ? ColorUtils.hsvaToRgba({
                a: result.length > 4 ? parseFloat(result[5]) : 1,
                h: parseInt(result[1], 10),
                s: parseInt(result[2], 10),
                v: parseInt(result[3], 10),
            })
            : undefined;
    }
    else {
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
        const hexFixed = input.replace(shorthandRegex, (_m, r, g, b, a) => {
            return r + r + g + g + b + b + (a !== undefined ? a + a : "");
        });
        const regex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
        const result = regex.exec(hexFixed);
        return result
            ? {
                a: result[4] !== undefined ? parseInt(result[4], 16) / 0xff : 1,
                b: parseInt(result[3], 16),
                g: parseInt(result[2], 16),
                r: parseInt(result[1], 16),
            }
            : undefined;
    }
}
class ColorUtils {
    static colorToRgb(input, index, useIndex = true) {
        var _a, _b, _c;
        if (input === undefined) {
            return;
        }
        const color = typeof input === "string" ? { value: input } : input;
        let res;
        if (typeof color.value === "string") {
            if (color.value === Constants_1.Constants.randomColorValue) {
                res = ColorUtils.getRandomRgbColor();
            }
            else {
                res = ColorUtils.stringToRgb(color.value);
            }
        }
        else {
            if (color.value instanceof Array) {
                const colorSelected = Utils_1.Utils.itemFromArray(color.value, index, useIndex);
                res = ColorUtils.colorToRgb({ value: colorSelected });
            }
            else {
                const colorValue = color.value;
                const rgbColor = (_a = colorValue.rgb) !== null && _a !== void 0 ? _a : color.value;
                if (rgbColor.r !== undefined) {
                    res = rgbColor;
                }
                else {
                    const hslColor = (_b = colorValue.hsl) !== null && _b !== void 0 ? _b : color.value;
                    if (hslColor.h !== undefined && hslColor.l !== undefined) {
                        res = ColorUtils.hslToRgb(hslColor);
                    }
                    else {
                        const hsvColor = (_c = colorValue.hsv) !== null && _c !== void 0 ? _c : color.value;
                        if (hsvColor.h !== undefined && hsvColor.v !== undefined) {
                            res = ColorUtils.hsvToRgb(hsvColor);
                        }
                    }
                }
            }
        }
        return res;
    }
    static colorToHsl(color, index, useIndex = true) {
        const rgb = ColorUtils.colorToRgb(color, index, useIndex);
        return rgb !== undefined ? ColorUtils.rgbToHsl(rgb) : undefined;
    }
    static rgbToHsl(color) {
        const r1 = color.r / 255;
        const g1 = color.g / 255;
        const b1 = color.b / 255;
        const max = Math.max(r1, g1, b1);
        const min = Math.min(r1, g1, b1);
        const res = {
            h: 0,
            l: (max + min) / 2,
            s: 0,
        };
        if (max != min) {
            res.s = res.l < 0.5 ? (max - min) / (max + min) : (max - min) / (2.0 - max - min);
            res.h =
                r1 === max
                    ? (g1 - b1) / (max - min)
                    : (res.h = g1 === max ? 2.0 + (b1 - r1) / (max - min) : 4.0 + (r1 - g1) / (max - min));
        }
        res.l *= 100;
        res.s *= 100;
        res.h *= 60;
        if (res.h < 0) {
            res.h += 360;
        }
        return res;
    }
    static stringToAlpha(input) {
        var _a;
        return (_a = stringToRgba(input)) === null || _a === void 0 ? void 0 : _a.a;
    }
    static stringToRgb(input) {
        return stringToRgba(input);
    }
    static hslToRgb(hsl) {
        const result = { b: 0, g: 0, r: 0 };
        const hslPercent = {
            h: hsl.h / 360,
            l: hsl.l / 100,
            s: hsl.s / 100,
        };
        if (hslPercent.s === 0) {
            result.b = hslPercent.l;
            result.g = hslPercent.l;
            result.r = hslPercent.l;
        }
        else {
            const q = hslPercent.l < 0.5
                ? hslPercent.l * (1 + hslPercent.s)
                : hslPercent.l + hslPercent.s - hslPercent.l * hslPercent.s;
            const p = 2 * hslPercent.l - q;
            result.r = hue2rgb(p, q, hslPercent.h + 1 / 3);
            result.g = hue2rgb(p, q, hslPercent.h);
            result.b = hue2rgb(p, q, hslPercent.h - 1 / 3);
        }
        result.r = Math.floor(result.r * 255);
        result.g = Math.floor(result.g * 255);
        result.b = Math.floor(result.b * 255);
        return result;
    }
    static hslaToRgba(hsla) {
        const rgbResult = ColorUtils.hslToRgb(hsla);
        return {
            a: hsla.a,
            b: rgbResult.b,
            g: rgbResult.g,
            r: rgbResult.r,
        };
    }
    static hslToHsv(hsl) {
        const l = hsl.l / 100, sl = hsl.s / 100;
        const v = l + sl * Math.min(l, 1 - l), sv = !v ? 0 : 2 * (1 - l / v);
        return {
            h: hsl.h,
            s: sv * 100,
            v: v * 100,
        };
    }
    static hslaToHsva(hsla) {
        const hsvResult = ColorUtils.hslToHsv(hsla);
        return {
            a: hsla.a,
            h: hsvResult.h,
            s: hsvResult.s,
            v: hsvResult.v,
        };
    }
    static hsvToHsl(hsv) {
        const v = hsv.v / 100, sv = hsv.s / 100;
        const l = v * (1 - sv / 2), sl = l === 0 || l === 1 ? 0 : (v - l) / Math.min(l, 1 - l);
        return {
            h: hsv.h,
            l: l * 100,
            s: sl * 100,
        };
    }
    static hsvaToHsla(hsva) {
        const hslResult = ColorUtils.hsvToHsl(hsva);
        return {
            a: hsva.a,
            h: hslResult.h,
            l: hslResult.l,
            s: hslResult.s,
        };
    }
    static hsvToRgb(hsv) {
        const result = { b: 0, g: 0, r: 0 };
        const hsvPercent = {
            h: hsv.h / 60,
            s: hsv.s / 100,
            v: hsv.v / 100,
        };
        const c = hsvPercent.v * hsvPercent.s, x = c * (1 - Math.abs((hsvPercent.h % 2) - 1));
        let tempRgb;
        if (hsvPercent.h >= 0 && hsvPercent.h <= 1) {
            tempRgb = {
                r: c,
                g: x,
                b: 0,
            };
        }
        else if (hsvPercent.h > 1 && hsvPercent.h <= 2) {
            tempRgb = {
                r: x,
                g: c,
                b: 0,
            };
        }
        else if (hsvPercent.h > 2 && hsvPercent.h <= 3) {
            tempRgb = {
                r: 0,
                g: c,
                b: x,
            };
        }
        else if (hsvPercent.h > 3 && hsvPercent.h <= 4) {
            tempRgb = {
                r: 0,
                g: x,
                b: c,
            };
        }
        else if (hsvPercent.h > 4 && hsvPercent.h <= 5) {
            tempRgb = {
                r: x,
                g: 0,
                b: c,
            };
        }
        else if (hsvPercent.h > 5 && hsvPercent.h <= 6) {
            tempRgb = {
                r: c,
                g: 0,
                b: x,
            };
        }
        if (tempRgb) {
            const m = hsvPercent.v - c;
            result.r = Math.floor((tempRgb.r + m) * 255);
            result.g = Math.floor((tempRgb.g + m) * 255);
            result.b = Math.floor((tempRgb.b + m) * 255);
        }
        return result;
    }
    static hsvaToRgba(hsva) {
        const rgbResult = ColorUtils.hsvToRgb(hsva);
        return {
            a: hsva.a,
            b: rgbResult.b,
            g: rgbResult.g,
            r: rgbResult.r,
        };
    }
    static rgbToHsv(rgb) {
        const rgbPercent = {
            r: rgb.r / 255,
            g: rgb.g / 255,
            b: rgb.b / 255,
        }, xMax = Math.max(rgbPercent.r, rgbPercent.g, rgbPercent.b), xMin = Math.min(rgbPercent.r, rgbPercent.g, rgbPercent.b), v = xMax, c = xMax - xMin;
        let h = 0;
        if (v === rgbPercent.r) {
            h = 60 * ((rgbPercent.g - rgbPercent.b) / c);
        }
        else if (v === rgbPercent.g) {
            h = 60 * (2 + (rgbPercent.b - rgbPercent.r) / c);
        }
        else if (v === rgbPercent.b) {
            h = 60 * (4 + (rgbPercent.r - rgbPercent.g) / c);
        }
        const s = !v ? 0 : c / v;
        return {
            h,
            s: s * 100,
            v: v * 100,
        };
    }
    static rgbaToHsva(rgba) {
        const hsvResult = ColorUtils.rgbToHsv(rgba);
        return {
            a: rgba.a,
            h: hsvResult.h,
            s: hsvResult.s,
            v: hsvResult.v,
        };
    }
    static getRandomRgbColor(min) {
        const fixedMin = min !== null && min !== void 0 ? min : 0;
        return {
            b: Math.floor(NumberUtils_1.NumberUtils.randomInRange(fixedMin, 256)),
            g: Math.floor(NumberUtils_1.NumberUtils.randomInRange(fixedMin, 256)),
            r: Math.floor(NumberUtils_1.NumberUtils.randomInRange(fixedMin, 256)),
        };
    }
    static getStyleFromRgb(color, opacity) {
        return `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity !== null && opacity !== void 0 ? opacity : 1})`;
    }
    static getStyleFromHsl(color, opacity) {
        return `hsla(${color.h}, ${color.s}%, ${color.l}%, ${opacity !== null && opacity !== void 0 ? opacity : 1})`;
    }
    static getStyleFromHsv(color, opacity) {
        return ColorUtils.getStyleFromHsl(ColorUtils.hsvToHsl(color), opacity);
    }
    static mix(color1, color2, size1, size2) {
        let rgb1 = color1;
        let rgb2 = color2;
        if (rgb1.r === undefined) {
            rgb1 = ColorUtils.hslToRgb(color1);
        }
        if (rgb2.r === undefined) {
            rgb2 = ColorUtils.hslToRgb(color2);
        }
        return {
            b: NumberUtils_1.NumberUtils.mix(rgb1.b, rgb2.b, size1, size2),
            g: NumberUtils_1.NumberUtils.mix(rgb1.g, rgb2.g, size1, size2),
            r: NumberUtils_1.NumberUtils.mix(rgb1.r, rgb2.r, size1, size2),
        };
    }
    static replaceColorSvg(image, color, opacity) {
        if (!image.svgData) {
            return "";
        }
        const svgXml = image.svgData;
        const rgbHex = /#([0-9A-F]{3,6})/gi;
        return svgXml.replace(rgbHex, () => ColorUtils.getStyleFromHsl(color, opacity));
    }
    static getLinkColor(p1, p2, linkColor) {
        var _a, _b;
        if (linkColor === Constants_1.Constants.randomColorValue) {
            return ColorUtils.getRandomRgbColor();
        }
        else if (linkColor === "mid") {
            const sourceColor = (_a = p1.getFillColor()) !== null && _a !== void 0 ? _a : p1.getStrokeColor();
            const destColor = (_b = p2 === null || p2 === void 0 ? void 0 : p2.getFillColor()) !== null && _b !== void 0 ? _b : p2 === null || p2 === void 0 ? void 0 : p2.getStrokeColor();
            if (sourceColor && destColor && p2) {
                return ColorUtils.mix(sourceColor, destColor, p1.getRadius(), p2.getRadius());
            }
            else {
                const hslColor = sourceColor !== null && sourceColor !== void 0 ? sourceColor : destColor;
                if (hslColor) {
                    return ColorUtils.hslToRgb(hslColor);
                }
            }
        }
        else {
            return linkColor;
        }
    }
    static getLinkRandomColor(optColor, blink, consent) {
        const color = typeof optColor === "string" ? optColor : optColor.value;
        if (color === Constants_1.Constants.randomColorValue) {
            if (consent) {
                return ColorUtils.colorToRgb({
                    value: color,
                });
            }
            else if (blink) {
                return Constants_1.Constants.randomColorValue;
            }
            else {
                return Constants_1.Constants.midColorValue;
            }
        }
        else {
            return ColorUtils.colorToRgb({
                value: color,
            });
        }
    }
}
exports.ColorUtils = ColorUtils;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Constants.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Constants = void 0;
class Constants {
}
exports.Constants = Constants;
Constants.canvasClass = "tsparticles-canvas-el";
Constants.randomColorValue = "random";
Constants.midColorValue = "mid";
Constants.touchEndEvent = "touchend";
Constants.mouseDownEvent = "mousedown";
Constants.mouseUpEvent = "mouseup";
Constants.mouseMoveEvent = "mousemove";
Constants.touchStartEvent = "touchstart";
Constants.touchMoveEvent = "touchmove";
Constants.mouseLeaveEvent = "mouseleave";
Constants.mouseOutEvent = "mouseout";
Constants.touchCancelEvent = "touchcancel";
Constants.resizeEvent = "resize";
Constants.visibilityChangeEvent = "visibilitychange";
Constants.noPolygonDataLoaded = "No polygon data loaded.";
Constants.noPolygonFound = "No polygon found, you need to specify SVG url in config.";


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/EventListeners.js":
/*!***************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/EventListeners.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EventListeners = void 0;
const Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/tsparticles/dist/Utils/Constants.js");
function manageListener(element, event, handler, add, options) {
    if (add) {
        let addOptions = { passive: true };
        if (typeof options === "boolean") {
            addOptions.capture = options;
        }
        else if (options !== undefined) {
            addOptions = options;
        }
        element.addEventListener(event, handler, addOptions);
    }
    else {
        const removeOptions = options;
        element.removeEventListener(event, handler, removeOptions);
    }
}
class EventListeners {
    constructor(container) {
        this.container = container;
        this.canPush = true;
        this.mouseMoveHandler = (e) => this.mouseTouchMove(e);
        this.touchStartHandler = (e) => this.mouseTouchMove(e);
        this.touchMoveHandler = (e) => this.mouseTouchMove(e);
        this.touchEndHandler = () => this.mouseTouchFinish();
        this.mouseLeaveHandler = () => this.mouseTouchFinish();
        this.touchCancelHandler = () => this.mouseTouchFinish();
        this.touchEndClickHandler = (e) => this.mouseTouchClick(e);
        this.mouseUpHandler = (e) => this.mouseTouchClick(e);
        this.mouseDownHandler = () => this.mouseDown();
        this.visibilityChangeHandler = () => this.handleVisibilityChange();
        this.resizeHandler = () => this.handleWindowResize();
    }
    addListeners() {
        this.manageListeners(true);
    }
    removeListeners() {
        this.manageListeners(false);
    }
    manageListeners(add) {
        var _a;
        const container = this.container;
        const options = container.options;
        const detectType = options.interactivity.detectsOn;
        let mouseLeaveEvent = Constants_1.Constants.mouseLeaveEvent;
        if (detectType === Enums_1.InteractivityDetect.window) {
            container.interactivity.element = window;
            mouseLeaveEvent = Constants_1.Constants.mouseOutEvent;
        }
        else if (detectType === Enums_1.InteractivityDetect.parent && container.canvas.element) {
            const canvasEl = container.canvas.element;
            container.interactivity.element = (_a = canvasEl.parentElement) !== null && _a !== void 0 ? _a : canvasEl.parentNode;
        }
        else {
            container.interactivity.element = container.canvas.element;
        }
        const interactivityEl = container.interactivity.element;
        if (!interactivityEl) {
            return;
        }
        const html = interactivityEl;
        if (options.interactivity.events.onHover.enable || options.interactivity.events.onClick.enable) {
            manageListener(interactivityEl, Constants_1.Constants.mouseMoveEvent, this.mouseMoveHandler, add);
            manageListener(interactivityEl, Constants_1.Constants.touchStartEvent, this.touchStartHandler, add);
            manageListener(interactivityEl, Constants_1.Constants.touchMoveEvent, this.touchMoveHandler, add);
            if (!options.interactivity.events.onClick.enable) {
                manageListener(interactivityEl, Constants_1.Constants.touchEndEvent, this.touchEndHandler, add);
            }
            else {
                manageListener(interactivityEl, Constants_1.Constants.touchEndEvent, this.touchEndClickHandler, add);
                manageListener(interactivityEl, Constants_1.Constants.mouseUpEvent, this.mouseUpHandler, add);
                manageListener(interactivityEl, Constants_1.Constants.mouseDownEvent, this.mouseDownHandler, add);
            }
            manageListener(interactivityEl, mouseLeaveEvent, this.mouseLeaveHandler, add);
            manageListener(interactivityEl, Constants_1.Constants.touchCancelEvent, this.touchCancelHandler, add);
        }
        if (container.canvas.element) {
            container.canvas.element.style.pointerEvents = html === container.canvas.element ? "initial" : "none";
        }
        if (options.interactivity.events.resize) {
            manageListener(window, Constants_1.Constants.resizeEvent, this.resizeHandler, add);
        }
        if (document) {
            manageListener(document, Constants_1.Constants.visibilityChangeEvent, this.visibilityChangeHandler, add, false);
        }
    }
    handleWindowResize() {
        var _a;
        (_a = this.container.canvas) === null || _a === void 0 ? void 0 : _a.windowResize();
    }
    handleVisibilityChange() {
        const container = this.container;
        const options = container.options;
        this.mouseTouchFinish();
        if (!options.pauseOnBlur) {
            return;
        }
        if (document === null || document === void 0 ? void 0 : document.hidden) {
            container.pageHidden = true;
            container.pause();
        }
        else {
            container.pageHidden = false;
            if (container.getAnimationStatus()) {
                container.play(true);
            }
            else {
                container.draw();
            }
        }
    }
    mouseDown() {
        const interactivity = this.container.interactivity;
        if (interactivity) {
            const mouse = interactivity.mouse;
            mouse.clicking = true;
            mouse.downPosition = mouse.position;
        }
    }
    mouseTouchMove(e) {
        var _a, _b, _c, _d, _e, _f, _g;
        const container = this.container;
        const options = container.options;
        if (((_a = container.interactivity) === null || _a === void 0 ? void 0 : _a.element) === undefined) {
            return;
        }
        container.interactivity.mouse.inside = true;
        let pos;
        const canvas = container.canvas.element;
        if (e.type.startsWith("mouse")) {
            this.canPush = true;
            const mouseEvent = e;
            if (container.interactivity.element === window) {
                if (canvas) {
                    const clientRect = canvas.getBoundingClientRect();
                    pos = {
                        x: mouseEvent.clientX - clientRect.left,
                        y: mouseEvent.clientY - clientRect.top,
                    };
                }
            }
            else if (options.interactivity.detectsOn === Enums_1.InteractivityDetect.parent) {
                const source = mouseEvent.target;
                const target = mouseEvent.currentTarget;
                const canvasEl = container.canvas.element;
                if (source && target && canvasEl) {
                    const sourceRect = source.getBoundingClientRect();
                    const targetRect = target.getBoundingClientRect();
                    const canvasRect = canvasEl.getBoundingClientRect();
                    pos = {
                        x: mouseEvent.offsetX + 2 * sourceRect.left - (targetRect.left + canvasRect.left),
                        y: mouseEvent.offsetY + 2 * sourceRect.top - (targetRect.top + canvasRect.top),
                    };
                }
                else {
                    pos = {
                        x: (_b = mouseEvent.offsetX) !== null && _b !== void 0 ? _b : mouseEvent.clientX,
                        y: (_c = mouseEvent.offsetY) !== null && _c !== void 0 ? _c : mouseEvent.clientY,
                    };
                }
            }
            else {
                if (mouseEvent.target === container.canvas.element) {
                    pos = {
                        x: (_d = mouseEvent.offsetX) !== null && _d !== void 0 ? _d : mouseEvent.clientX,
                        y: (_e = mouseEvent.offsetY) !== null && _e !== void 0 ? _e : mouseEvent.clientY,
                    };
                }
            }
        }
        else {
            this.canPush = e.type !== "touchmove";
            const touchEvent = e;
            const lastTouch = touchEvent.touches[touchEvent.touches.length - 1];
            const canvasRect = canvas === null || canvas === void 0 ? void 0 : canvas.getBoundingClientRect();
            pos = {
                x: lastTouch.clientX - ((_f = canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.left) !== null && _f !== void 0 ? _f : 0),
                y: lastTouch.clientY - ((_g = canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.top) !== null && _g !== void 0 ? _g : 0),
            };
        }
        const pxRatio = container.retina.pixelRatio;
        if (pos) {
            pos.x *= pxRatio;
            pos.y *= pxRatio;
        }
        container.interactivity.mouse.position = pos;
        container.interactivity.status = Constants_1.Constants.mouseMoveEvent;
    }
    mouseTouchFinish() {
        const interactivity = this.container.interactivity;
        if (interactivity === undefined) {
            return;
        }
        const mouse = interactivity.mouse;
        delete mouse.position;
        delete mouse.clickPosition;
        delete mouse.downPosition;
        interactivity.status = Constants_1.Constants.mouseLeaveEvent;
        mouse.inside = false;
        mouse.clicking = false;
    }
    mouseTouchClick(e) {
        const container = this.container;
        const options = container.options;
        const mouse = container.interactivity.mouse;
        mouse.inside = true;
        let handled = false;
        const mousePosition = mouse.position;
        if (mousePosition === undefined || !options.interactivity.events.onClick.enable) {
            return;
        }
        for (const [, plugin] of container.plugins) {
            if (plugin.clickPositionValid !== undefined) {
                handled = plugin.clickPositionValid(mousePosition);
                if (handled) {
                    break;
                }
            }
        }
        if (!handled) {
            this.doMouseTouchClick(e);
        }
        mouse.clicking = false;
    }
    doMouseTouchClick(e) {
        const container = this.container;
        const options = container.options;
        if (this.canPush) {
            const mousePos = container.interactivity.mouse.position;
            if (mousePos) {
                container.interactivity.mouse.clickPosition = {
                    x: mousePos.x,
                    y: mousePos.y,
                };
            }
            else {
                return;
            }
            container.interactivity.mouse.clickTime = new Date().getTime();
            const onClick = options.interactivity.events.onClick;
            if (onClick.mode instanceof Array) {
                for (const mode of onClick.mode) {
                    this.handleClickMode(mode);
                }
            }
            else {
                this.handleClickMode(onClick.mode);
            }
        }
        if (e.type === "touchend") {
            setTimeout(() => this.mouseTouchFinish(), 500);
        }
    }
    handleClickMode(mode) {
        const container = this.container;
        const options = container.options;
        const pushNb = options.interactivity.modes.push.quantity;
        const removeNb = options.interactivity.modes.remove.quantity;
        switch (mode) {
            case Enums_1.ClickMode.push: {
                if (pushNb > 0) {
                    container.particles.push(pushNb, container.interactivity.mouse);
                }
                break;
            }
            case Enums_1.ClickMode.remove:
                container.particles.removeQuantity(removeNb);
                break;
            case Enums_1.ClickMode.bubble:
                container.bubble.clicking = true;
                break;
            case Enums_1.ClickMode.repulse:
                container.repulse.clicking = true;
                container.repulse.count = 0;
                for (const particle of container.repulse.particles) {
                    particle.velocity.horizontal = particle.initialVelocity.horizontal;
                    particle.velocity.vertical = particle.initialVelocity.vertical;
                }
                container.repulse.particles = [];
                container.repulse.finish = false;
                setTimeout(() => {
                    if (!container.destroyed) {
                        container.repulse.clicking = false;
                    }
                }, options.interactivity.modes.repulse.duration * 1000);
                break;
            case Enums_1.ClickMode.attract:
                container.attract.clicking = true;
                container.attract.count = 0;
                for (const particle of container.attract.particles) {
                    particle.velocity.horizontal = particle.initialVelocity.horizontal;
                    particle.velocity.vertical = particle.initialVelocity.vertical;
                }
                container.attract.particles = [];
                container.attract.finish = false;
                setTimeout(() => {
                    if (!container.destroyed) {
                        container.attract.clicking = false;
                    }
                }, options.interactivity.modes.attract.duration * 1000);
                break;
            case Enums_1.ClickMode.pause:
                if (container.getAnimationStatus()) {
                    container.pause();
                }
                else {
                    container.play();
                }
                break;
        }
        for (const [, plugin] of container.plugins) {
            if (plugin.handleClickMode) {
                plugin.handleClickMode(mode);
            }
        }
    }
}
exports.EventListeners = EventListeners;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/NumberUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/NumberUtils.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NumberUtils = void 0;
const Directions_1 = __webpack_require__(/*! ../Enums/Directions */ "./node_modules/tsparticles/dist/Enums/Directions/index.js");
class NumberUtils {
    static clamp(num, min, max) {
        return Math.min(Math.max(num, min), max);
    }
    static mix(comp1, comp2, weight1, weight2) {
        return Math.floor((comp1 * weight1 + comp2 * weight2) / (weight1 + weight2));
    }
    static randomInRange(r1, r2) {
        const max = Math.max(r1, r2), min = Math.min(r1, r2);
        return Math.random() * (max - min) + min;
    }
    static getValue(options) {
        const random = options.random;
        const { enable, minimumValue } = typeof random === "boolean" ? { enable: random, minimumValue: 0 } : random;
        return enable ? NumberUtils.randomInRange(minimumValue, options.value) : options.value;
    }
    static getDistances(pointA, pointB) {
        const dx = pointA.x - pointB.x;
        const dy = pointA.y - pointB.y;
        return { dx: dx, dy: dy, distance: Math.sqrt(dx * dx + dy * dy) };
    }
    static getDistance(pointA, pointB) {
        return NumberUtils.getDistances(pointA, pointB).distance;
    }
    static getParticleBaseVelocity(particle) {
        let velocityBase;
        switch (particle.direction) {
            case Directions_1.MoveDirection.top:
                velocityBase = { x: 0, y: -1 };
                break;
            case Directions_1.MoveDirection.topRight:
                velocityBase = { x: 0.5, y: -0.5 };
                break;
            case Directions_1.MoveDirection.right:
                velocityBase = { x: 1, y: -0 };
                break;
            case Directions_1.MoveDirection.bottomRight:
                velocityBase = { x: 0.5, y: 0.5 };
                break;
            case Directions_1.MoveDirection.bottom:
                velocityBase = { x: 0, y: 1 };
                break;
            case Directions_1.MoveDirection.bottomLeft:
                velocityBase = { x: -0.5, y: 1 };
                break;
            case Directions_1.MoveDirection.left:
                velocityBase = { x: -1, y: 0 };
                break;
            case Directions_1.MoveDirection.topLeft:
                velocityBase = { x: -0.5, y: -0.5 };
                break;
            default:
                velocityBase = { x: 0, y: 0 };
                break;
        }
        return velocityBase;
    }
    static rotateVelocity(velocity, angle) {
        return {
            horizontal: velocity.horizontal * Math.cos(angle) - velocity.vertical * Math.sin(angle),
            vertical: velocity.horizontal * Math.sin(angle) + velocity.vertical * Math.cos(angle),
        };
    }
    static collisionVelocity(v1, v2, m1, m2) {
        return {
            horizontal: (v1.horizontal * (m1 - m2)) / (m1 + m2) + (v2.horizontal * 2 * m2) / (m1 + m2),
            vertical: v1.vertical,
        };
    }
}
exports.NumberUtils = NumberUtils;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Plugins.js":
/*!********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Plugins.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Plugins = void 0;
const plugins = [];
const presets = new Map();
const drawers = new Map();
class Plugins {
    static getPlugin(plugin) {
        return plugins.find((t) => t.id === plugin);
    }
    static addPlugin(plugin) {
        if (!Plugins.getPlugin(plugin.id)) {
            plugins.push(plugin);
        }
    }
    static getAvailablePlugins(container) {
        const res = new Map();
        for (const plugin of plugins) {
            if (!plugin.needsPlugin(container.options)) {
                continue;
            }
            res.set(plugin.id, plugin.getPlugin(container));
        }
        return res;
    }
    static loadOptions(options, sourceOptions) {
        for (const plugin of plugins) {
            plugin.loadOptions(options, sourceOptions);
        }
    }
    static getPreset(preset) {
        return presets.get(preset);
    }
    static addPreset(presetKey, options) {
        if (!Plugins.getPreset(presetKey)) {
            presets.set(presetKey, options);
        }
    }
    static addShapeDrawer(type, drawer) {
        if (!Plugins.getShapeDrawer(type)) {
            drawers.set(type, drawer);
        }
    }
    static getShapeDrawer(type) {
        return drawers.get(type);
    }
    static getSupportedShapes() {
        return drawers.keys();
    }
}
exports.Plugins = Plugins;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Point.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Point.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Point = void 0;
class Point {
    constructor(position, particle) {
        this.position = position;
        this.particle = particle;
    }
}
exports.Point = Point;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/QuadTree.js":
/*!*********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/QuadTree.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.QuadTree = void 0;
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./node_modules/tsparticles/dist/Utils/Rectangle.js");
const Circle_1 = __webpack_require__(/*! ./Circle */ "./node_modules/tsparticles/dist/Utils/Circle.js");
const CircleWarp_1 = __webpack_require__(/*! ./CircleWarp */ "./node_modules/tsparticles/dist/Utils/CircleWarp.js");
class QuadTree {
    constructor(rectangle, capacity) {
        this.rectangle = rectangle;
        this.capacity = capacity;
        this.points = [];
        this.divided = false;
    }
    subdivide() {
        const x = this.rectangle.position.x;
        const y = this.rectangle.position.y;
        const w = this.rectangle.size.width;
        const h = this.rectangle.size.height;
        const capacity = this.capacity;
        this.northEast = new QuadTree(new Rectangle_1.Rectangle(x, y, w / 2, h / 2), capacity);
        this.northWest = new QuadTree(new Rectangle_1.Rectangle(x + w / 2, y, w / 2, h / 2), capacity);
        this.southEast = new QuadTree(new Rectangle_1.Rectangle(x, y + h / 2, w / 2, h / 2), capacity);
        this.southWest = new QuadTree(new Rectangle_1.Rectangle(x + w / 2, y + h / 2, w / 2, h / 2), capacity);
        this.divided = true;
    }
    insert(point) {
        var _a, _b, _c, _d, _e;
        if (!this.rectangle.contains(point.position)) {
            return false;
        }
        if (this.points.length < this.capacity) {
            this.points.push(point);
            return true;
        }
        if (!this.divided) {
            this.subdivide();
        }
        return ((_e = (((_a = this.northEast) === null || _a === void 0 ? void 0 : _a.insert(point)) || ((_b = this.northWest) === null || _b === void 0 ? void 0 : _b.insert(point)) || ((_c = this.southEast) === null || _c === void 0 ? void 0 : _c.insert(point)) || ((_d = this.southWest) === null || _d === void 0 ? void 0 : _d.insert(point)))) !== null && _e !== void 0 ? _e : false);
    }
    queryCircle(position, radius) {
        return this.query(new Circle_1.Circle(position.x, position.y, radius));
    }
    queryCircleWarp(position, radius, containerOrSize) {
        const container = containerOrSize;
        const size = containerOrSize;
        return this.query(new CircleWarp_1.CircleWarp(position.x, position.y, radius, container.canvas !== undefined ? container.canvas.size : size));
    }
    queryRectangle(position, size) {
        return this.query(new Rectangle_1.Rectangle(position.x, position.y, size.width, size.height));
    }
    query(range, found) {
        var _a, _b, _c, _d;
        const res = found !== null && found !== void 0 ? found : [];
        if (!range.intersects(this.rectangle)) {
            return [];
        }
        else {
            for (const p of this.points) {
                if (!range.contains(p.position)) {
                    continue;
                }
                res.push(p.particle);
            }
            if (this.divided) {
                (_a = this.northEast) === null || _a === void 0 ? void 0 : _a.query(range, res);
                (_b = this.northWest) === null || _b === void 0 ? void 0 : _b.query(range, res);
                (_c = this.southEast) === null || _c === void 0 ? void 0 : _c.query(range, res);
                (_d = this.southWest) === null || _d === void 0 ? void 0 : _d.query(range, res);
            }
        }
        return res;
    }
}
exports.QuadTree = QuadTree;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Range.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Range.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Range = void 0;
class Range {
    constructor(x, y) {
        this.position = {
            x: x,
            y: y,
        };
    }
}
exports.Range = Range;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Rectangle.js":
/*!**********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Rectangle.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Rectangle = void 0;
const Range_1 = __webpack_require__(/*! ./Range */ "./node_modules/tsparticles/dist/Utils/Range.js");
class Rectangle extends Range_1.Range {
    constructor(x, y, width, height) {
        super(x, y);
        this.size = {
            height: height,
            width: width,
        };
    }
    contains(point) {
        const w = this.size.width;
        const h = this.size.height;
        const pos = this.position;
        return point.x >= pos.x && point.x <= pos.x + w && point.y >= pos.y && point.y <= pos.y + h;
    }
    intersects(range) {
        const rect = range;
        const circle = range;
        const w = this.size.width;
        const h = this.size.height;
        const pos1 = this.position;
        const pos2 = range.position;
        if (circle.radius !== undefined) {
            return circle.intersects(this);
        }
        else if (rect.size !== undefined) {
            const size2 = rect.size;
            const w2 = size2.width;
            const h2 = size2.height;
            return pos2.x < pos1.x + w && pos2.x + w2 > pos1.x && pos2.y < pos1.y + h && pos2.y + h2 > pos1.y;
        }
        return false;
    }
}
exports.Rectangle = Rectangle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Utils.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Utils.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
const OutModeDirection_1 = __webpack_require__(/*! ../Enums/Directions/OutModeDirection */ "./node_modules/tsparticles/dist/Enums/Directions/OutModeDirection.js");
const NumberUtils_1 = __webpack_require__(/*! ./NumberUtils */ "./node_modules/tsparticles/dist/Utils/NumberUtils.js");
function rectSideBounce(pSide, pOtherSide, rectSide, rectOtherSide, velocity, factor) {
    const res = { bounced: false };
    if (pOtherSide.min >= rectOtherSide.min &&
        pOtherSide.min <= rectOtherSide.max &&
        pOtherSide.max >= rectOtherSide.min &&
        pOtherSide.max <= rectOtherSide.max) {
        if ((pSide.max >= rectSide.min && pSide.max <= (rectSide.max + rectSide.min) / 2 && velocity > 0) ||
            (pSide.min <= rectSide.max && pSide.min > (rectSide.max + rectSide.min) / 2 && velocity < 0)) {
            res.velocity = velocity * -factor;
            res.bounced = true;
        }
    }
    return res;
}
function checkSelector(element, selectors) {
    if (selectors instanceof Array) {
        for (const selector of selectors) {
            if (element.matches(selector)) {
                return true;
            }
        }
        return false;
    }
    else {
        return element.matches(selectors);
    }
}
class Utils {
    static isSsr() {
        return typeof window === "undefined" || !window;
    }
    static get animate() {
        return Utils.isSsr()
            ? (callback) => setTimeout(callback)
            : (callback) => (window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                window.setTimeout)(callback);
    }
    static get cancelAnimation() {
        return Utils.isSsr()
            ? (handle) => clearTimeout(handle)
            : (handle) => (window.cancelAnimationFrame ||
                window.webkitCancelRequestAnimationFrame ||
                window.mozCancelRequestAnimationFrame ||
                window.oCancelRequestAnimationFrame ||
                window.msCancelRequestAnimationFrame ||
                window.clearTimeout)(handle);
    }
    static isInArray(value, array) {
        return value === array || (array instanceof Array && array.indexOf(value) > -1);
    }
    static loadFont(character) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield document.fonts.load(`${character.weight} 36px '${character.font}'`);
            }
            catch (_a) {
            }
        });
    }
    static arrayRandomIndex(array) {
        return Math.floor(Math.random() * array.length);
    }
    static itemFromArray(array, index, useIndex = true) {
        const fixedIndex = index !== undefined && useIndex ? index % array.length : Utils.arrayRandomIndex(array);
        return array[fixedIndex];
    }
    static isPointInside(point, size, radius, direction) {
        return Utils.areBoundsInside(Utils.calculateBounds(point, radius !== null && radius !== void 0 ? radius : 0), size, direction);
    }
    static areBoundsInside(bounds, size, direction) {
        let inside = true;
        if (!direction || direction === OutModeDirection_1.OutModeDirection.bottom) {
            inside = bounds.top < size.height;
        }
        if (inside && (!direction || direction === OutModeDirection_1.OutModeDirection.left)) {
            inside = bounds.right > 0;
        }
        if (inside && (!direction || direction === OutModeDirection_1.OutModeDirection.right)) {
            inside = bounds.left < size.width;
        }
        if (inside && (!direction || direction === OutModeDirection_1.OutModeDirection.top)) {
            inside = bounds.bottom > 0;
        }
        return inside;
    }
    static calculateBounds(point, radius) {
        return {
            bottom: point.y + radius,
            left: point.x - radius,
            right: point.x + radius,
            top: point.y - radius,
        };
    }
    static loadImage(source) {
        return new Promise((resolve, reject) => {
            if (!source) {
                reject("Error tsParticles - No image.src");
                return;
            }
            const image = {
                source: source,
                type: source.substr(source.length - 3),
            };
            const img = new Image();
            img.addEventListener("load", () => {
                image.element = img;
                resolve(image);
            });
            img.addEventListener("error", () => {
                reject(`Error tsParticles - loading image: ${source}`);
            });
            img.src = source;
        });
    }
    static downloadSvgImage(source) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!source) {
                throw new Error("Error tsParticles - No image.src");
            }
            const image = {
                source: source,
                type: source.substr(source.length - 3),
            };
            if (image.type !== "svg") {
                return Utils.loadImage(source);
            }
            const response = yield fetch(image.source);
            if (!response.ok) {
                throw new Error("Error tsParticles - Image not found");
            }
            image.svgData = yield response.text();
            return image;
        });
    }
    static deepExtend(destination, ...sources) {
        for (const source of sources) {
            if (source === undefined || source === null) {
                continue;
            }
            if (typeof source !== "object") {
                destination = source;
                continue;
            }
            const sourceIsArray = Array.isArray(source);
            if (sourceIsArray && (typeof destination !== "object" || !destination || !Array.isArray(destination))) {
                destination = [];
            }
            else if (!sourceIsArray &&
                (typeof destination !== "object" || !destination || Array.isArray(destination))) {
                destination = {};
            }
            for (const key in source) {
                if (key === "__proto__") {
                    continue;
                }
                const sourceDict = source;
                const value = sourceDict[key];
                const isObject = typeof value === "object";
                const destDict = destination;
                destDict[key] =
                    isObject && Array.isArray(value)
                        ? value.map((v) => Utils.deepExtend(destDict[key], v))
                        : Utils.deepExtend(destDict[key], value);
            }
        }
        return destination;
    }
    static isDivModeEnabled(mode, divs) {
        return divs instanceof Array
            ? !!divs.find((t) => t.enable && Utils.isInArray(mode, t.mode))
            : Utils.isInArray(mode, divs.mode);
    }
    static divModeExecute(mode, divs, callback) {
        if (divs instanceof Array) {
            for (const div of divs) {
                const divMode = div.mode;
                const divEnabled = div.enable;
                if (divEnabled && Utils.isInArray(mode, divMode)) {
                    Utils.singleDivModeExecute(div, callback);
                }
            }
        }
        else {
            const divMode = divs.mode;
            const divEnabled = divs.enable;
            if (divEnabled && Utils.isInArray(mode, divMode)) {
                Utils.singleDivModeExecute(divs, callback);
            }
        }
    }
    static singleDivModeExecute(div, callback) {
        const selectors = div.selectors;
        if (selectors instanceof Array) {
            for (const selector of selectors) {
                callback(selector, div);
            }
        }
        else {
            callback(selectors, div);
        }
    }
    static divMode(divs, element) {
        if (!element || !divs) {
            return;
        }
        if (divs instanceof Array) {
            return divs.find((d) => checkSelector(element, d.selectors));
        }
        else if (checkSelector(element, divs.selectors)) {
            return divs;
        }
    }
    static circleBounceDataFromParticle(p) {
        return {
            position: p.getPosition(),
            radius: p.getRadius(),
            velocity: p.velocity,
            factor: {
                horizontal: NumberUtils_1.NumberUtils.getValue(p.particlesOptions.bounce.horizontal),
                vertical: NumberUtils_1.NumberUtils.getValue(p.particlesOptions.bounce.vertical),
            },
        };
    }
    static circleBounce(p1, p2) {
        const xVelocityDiff = p1.velocity.horizontal;
        const yVelocityDiff = p1.velocity.vertical;
        const pos1 = p1.position;
        const pos2 = p2.position;
        const xDist = pos2.x - pos1.x;
        const yDist = pos2.y - pos1.y;
        if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {
            const angle = -Math.atan2(pos2.y - pos1.y, pos2.x - pos1.x);
            const m1 = p1.radius;
            const m2 = p2.radius;
            const u1 = NumberUtils_1.NumberUtils.rotateVelocity(p1.velocity, angle);
            const u2 = NumberUtils_1.NumberUtils.rotateVelocity(p2.velocity, angle);
            const v1 = NumberUtils_1.NumberUtils.collisionVelocity(u1, u2, m1, m2);
            const v2 = NumberUtils_1.NumberUtils.collisionVelocity(u2, u1, m1, m2);
            const vFinal1 = NumberUtils_1.NumberUtils.rotateVelocity(v1, -angle);
            const vFinal2 = NumberUtils_1.NumberUtils.rotateVelocity(v2, -angle);
            p1.velocity.horizontal = vFinal1.horizontal * p1.factor.horizontal;
            p1.velocity.vertical = vFinal1.vertical * p1.factor.vertical;
            p2.velocity.horizontal = vFinal2.horizontal * p2.factor.horizontal;
            p2.velocity.vertical = vFinal2.vertical * p2.factor.vertical;
        }
    }
    static rectBounce(particle, divBounds) {
        const pPos = particle.getPosition();
        const size = particle.getRadius();
        const bounds = Utils.calculateBounds(pPos, size);
        const resH = rectSideBounce({
            min: bounds.left,
            max: bounds.right,
        }, {
            min: bounds.top,
            max: bounds.bottom,
        }, {
            min: divBounds.left,
            max: divBounds.right,
        }, {
            min: divBounds.top,
            max: divBounds.bottom,
        }, particle.velocity.horizontal, NumberUtils_1.NumberUtils.getValue(particle.particlesOptions.bounce.horizontal));
        if (resH.bounced) {
            if (resH.velocity !== undefined) {
                particle.velocity.horizontal = resH.velocity;
            }
            if (resH.position !== undefined) {
                particle.position.x = resH.position;
            }
        }
        const resV = rectSideBounce({
            min: bounds.top,
            max: bounds.bottom,
        }, {
            min: bounds.left,
            max: bounds.right,
        }, {
            min: divBounds.top,
            max: divBounds.bottom,
        }, {
            min: divBounds.left,
            max: divBounds.right,
        }, particle.velocity.vertical, NumberUtils_1.NumberUtils.getValue(particle.particlesOptions.bounce.vertical));
        if (resV.bounced) {
            if (resV.velocity !== undefined) {
                particle.velocity.vertical = resV.velocity;
            }
            if (resV.position !== undefined) {
                particle.position.y = resV.position;
            }
        }
    }
}
exports.Utils = Utils;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/index.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./CanvasUtils */ "./node_modules/tsparticles/dist/Utils/CanvasUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./Circle */ "./node_modules/tsparticles/dist/Utils/Circle.js"), exports);
__exportStar(__webpack_require__(/*! ./CircleWarp */ "./node_modules/tsparticles/dist/Utils/CircleWarp.js"), exports);
__exportStar(__webpack_require__(/*! ./ColorUtils */ "./node_modules/tsparticles/dist/Utils/ColorUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./Constants */ "./node_modules/tsparticles/dist/Utils/Constants.js"), exports);
__exportStar(__webpack_require__(/*! ./EventListeners */ "./node_modules/tsparticles/dist/Utils/EventListeners.js"), exports);
__exportStar(__webpack_require__(/*! ./NumberUtils */ "./node_modules/tsparticles/dist/Utils/NumberUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./Plugins */ "./node_modules/tsparticles/dist/Utils/Plugins.js"), exports);
__exportStar(__webpack_require__(/*! ./Point */ "./node_modules/tsparticles/dist/Utils/Point.js"), exports);
__exportStar(__webpack_require__(/*! ./QuadTree */ "./node_modules/tsparticles/dist/Utils/QuadTree.js"), exports);
__exportStar(__webpack_require__(/*! ./Range */ "./node_modules/tsparticles/dist/Utils/Range.js"), exports);
__exportStar(__webpack_require__(/*! ./Rectangle */ "./node_modules/tsparticles/dist/Utils/Rectangle.js"), exports);
__exportStar(__webpack_require__(/*! ./Utils */ "./node_modules/tsparticles/dist/Utils/Utils.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/tsparticles/dist/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tsParticles = exports.pJSDom = exports.particlesJS = exports.Utils = exports.Constants = exports.ColorUtils = exports.CanvasUtils = void 0;
const pjs_1 = __webpack_require__(/*! ./pjs */ "./node_modules/tsparticles/dist/pjs.js");
const main_1 = __webpack_require__(/*! ./main */ "./node_modules/tsparticles/dist/main.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
Object.defineProperty(exports, "CanvasUtils", { enumerable: true, get: function () { return Utils_1.CanvasUtils; } });
Object.defineProperty(exports, "ColorUtils", { enumerable: true, get: function () { return Utils_1.ColorUtils; } });
Object.defineProperty(exports, "Constants", { enumerable: true, get: function () { return Utils_1.Constants; } });
Object.defineProperty(exports, "Utils", { enumerable: true, get: function () { return Utils_1.Utils; } });
const tsParticles = new main_1.Main();
exports.tsParticles = tsParticles;
tsParticles.init();
const { particlesJS, pJSDom } = pjs_1.initPjs(tsParticles);
exports.particlesJS = particlesJS;
exports.pJSDom = pJSDom;
__exportStar(__webpack_require__(/*! ./Core/Container */ "./node_modules/tsparticles/dist/Core/Container.js"), exports);
__exportStar(__webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Enums/index.js"), exports);
__exportStar(__webpack_require__(/*! ./Plugins/Absorbers/Enums */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/index.js"), exports);
__exportStar(__webpack_require__(/*! ./Plugins/Emitters/Enums */ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/index.js"), exports);
__exportStar(__webpack_require__(/*! ./Plugins/PolygonMask/Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js"), exports);
__exportStar(__webpack_require__(/*! ./Types */ "./node_modules/tsparticles/dist/Types/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/main.js":
/*!***********************************************!*\
  !*** ./node_modules/tsparticles/dist/main.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const main_slim_1 = __webpack_require__(/*! ./main.slim */ "./node_modules/tsparticles/dist/main.slim.js");
const AbsorbersPlugin_1 = __webpack_require__(/*! ./Plugins/Absorbers/AbsorbersPlugin */ "./node_modules/tsparticles/dist/Plugins/Absorbers/AbsorbersPlugin.js");
const EmittersPlugin_1 = __webpack_require__(/*! ./Plugins/Emitters/EmittersPlugin */ "./node_modules/tsparticles/dist/Plugins/Emitters/EmittersPlugin.js");
const PolygonMaskPlugin_1 = __webpack_require__(/*! ./Plugins/PolygonMask/PolygonMaskPlugin */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskPlugin.js");
class Main extends main_slim_1.MainSlim {
    constructor() {
        super();
        this.addPlugin(AbsorbersPlugin_1.AbsorbersPlugin);
        this.addPlugin(EmittersPlugin_1.EmittersPlugin);
        this.addPlugin(PolygonMaskPlugin_1.PolygonMaskPlugin);
    }
}
exports.Main = Main;


/***/ }),

/***/ "./node_modules/tsparticles/dist/main.slim.js":
/*!****************************************************!*\
  !*** ./node_modules/tsparticles/dist/main.slim.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MainSlim = void 0;
const SquareDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/SquareDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/SquareDrawer.js");
const TextDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/TextDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/TextDrawer.js");
const ImageDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/ImageDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/ImageDrawer.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Types_1 = __webpack_require__(/*! ./Enums/Types */ "./node_modules/tsparticles/dist/Enums/Types/index.js");
const LineDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/LineDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/LineDrawer.js");
const CircleDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/CircleDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/CircleDrawer.js");
const TriangleDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/TriangleDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/TriangleDrawer.js");
const StarDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/StarDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/StarDrawer.js");
const PolygonDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/PolygonDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawer.js");
const Loader_1 = __webpack_require__(/*! ./Core/Loader */ "./node_modules/tsparticles/dist/Core/Loader.js");
class MainSlim {
    constructor() {
        this.initialized = false;
        const squareDrawer = new SquareDrawer_1.SquareDrawer();
        const textDrawer = new TextDrawer_1.TextDrawer();
        const imageDrawer = new ImageDrawer_1.ImageDrawer();
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.line, new LineDrawer_1.LineDrawer());
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.circle, new CircleDrawer_1.CircleDrawer());
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.edge, squareDrawer);
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.square, squareDrawer);
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.triangle, new TriangleDrawer_1.TriangleDrawer());
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.star, new StarDrawer_1.StarDrawer());
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.polygon, new PolygonDrawer_1.PolygonDrawer());
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.char, textDrawer);
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.character, textDrawer);
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.image, imageDrawer);
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.images, imageDrawer);
    }
    init() {
        if (!this.initialized) {
            this.initialized = true;
        }
    }
    loadFromArray(tagId, options, index) {
        return __awaiter(this, void 0, void 0, function* () {
            return Loader_1.Loader.load(tagId, options, index);
        });
    }
    load(tagId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return Loader_1.Loader.load(tagId, options);
        });
    }
    set(id, element, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return Loader_1.Loader.set(id, element, options);
        });
    }
    loadJSON(tagId, pathConfigJson, index) {
        return Loader_1.Loader.loadJSON(tagId, pathConfigJson, index);
    }
    setOnClickHandler(callback) {
        Loader_1.Loader.setOnClickHandler(callback);
    }
    dom() {
        return Loader_1.Loader.dom();
    }
    domItem(index) {
        return Loader_1.Loader.domItem(index);
    }
    addShape(shape, drawer, init, afterEffect, destroy) {
        let customDrawer;
        if (typeof drawer === "function") {
            customDrawer = {
                afterEffect: afterEffect,
                destroy: destroy,
                draw: drawer,
                init: init,
            };
        }
        else {
            customDrawer = drawer;
        }
        Utils_1.Plugins.addShapeDrawer(shape, customDrawer);
    }
    addPreset(preset, options) {
        Utils_1.Plugins.addPreset(preset, options);
    }
    addPlugin(plugin) {
        Utils_1.Plugins.addPlugin(plugin);
    }
}
exports.MainSlim = MainSlim;


/***/ }),

/***/ "./node_modules/tsparticles/dist/pjs.js":
/*!**********************************************!*\
  !*** ./node_modules/tsparticles/dist/pjs.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.initPjs = void 0;
const initPjs = (main) => {
    const particlesJS = (tagId, options) => {
        return main.load(tagId, options);
    };
    particlesJS.load = (tagId, pathConfigJson, callback) => {
        main.loadJSON(tagId, pathConfigJson).then((container) => {
            if (container) {
                callback(container);
            }
        });
    };
    particlesJS.setOnClickHandler = (callback) => {
        main.setOnClickHandler(callback);
    };
    const pJSDom = main.dom();
    return { particlesJS, pJSDom };
};
exports.initPjs = initPjs;


/***/ }),

/***/ "./src/pages/_app.tsx":
/*!****************************!*\
  !*** ./src/pages/_app.tsx ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var react_notifications_component_dist_theme_css__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-notifications-component/dist/theme.css */ "./node_modules/react-notifications-component/dist/theme.css");
/* harmony import */ var react_notifications_component_dist_theme_css__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react_notifications_component_dist_theme_css__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var react_notifications_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-notifications-component */ "./node_modules/react-notifications-component/dist/index.js");
/* harmony import */ var react_notifications_component__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(react_notifications_component__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _subcomponents_Navbar_Navbar__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../subcomponents/Navbar/Navbar */ "./src/subcomponents/Navbar/Navbar.tsx");
/* harmony import */ var _subcomponents_Main_Main__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../subcomponents/Main/Main */ "./src/subcomponents/Main/Main.tsx");
/* harmony import */ var src_services_Environment_service__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! src/services/Environment.service */ "./src/services/Environment.service.ts");
/* harmony import */ var src_services_Blockchain_service__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! src/services/Blockchain.service */ "./src/services/Blockchain.service.ts");
/* harmony import */ var src_services_Event_service__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! src/services/Event.service */ "./src/services/Event.service.ts");
/* harmony import */ var _styles_index_css__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../styles/index.css */ "./src/styles/index.css");
/* harmony import */ var _styles_index_css__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_styles_index_css__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! next/head */ "./node_modules/next/dist/next-server/lib/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var src_subcomponents_BgParticles_BgParticles__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! src/subcomponents/BgParticles/BgParticles */ "./src/subcomponents/BgParticles/BgParticles.tsx");










var _jsxFileName = "C:\\Users\\WSDT\\Desktop\\Wavect.io\\wavect.io\\token\\src\\pages\\_app.tsx";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Object(C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Object(C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }













var App = /*#__PURE__*/function (_Component) {
  Object(C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__["default"])(App, _Component);

  var _super = _createSuper(App);

  Object(C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(App, [{
    key: "componentDidMount",
    value: function () {
      var _componentDidMount = Object(C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])( /*#__PURE__*/C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2() {
        var _this2 = this;

        return C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return src_services_Blockchain_service__WEBPACK_IMPORTED_MODULE_15__["BlockchainService"].connectToBlockchain();

              case 3:
                _context2.prev = 3;
                // also stop loading in case blockchain network is down (e.g. local ganache)
                this.setState(_objectSpread(_objectSpread({}, this.state), {}, {
                  isConnectingToBlockchain: false
                }));
                return _context2.finish(3);

              case 6:
                src_services_Event_service__WEBPACK_IMPORTED_MODULE_16__["default"].on(src_services_Event_service__WEBPACK_IMPORTED_MODULE_16__["EVENT_BLOCKCHAIN_DATA_CHANGED"], /*#__PURE__*/Object(C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])( /*#__PURE__*/C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {
                  return C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.t0 = _this2;
                          _context.t1 = _objectSpread;
                          _context.t2 = _objectSpread({}, _this2.state);
                          _context.t3 = {};
                          _context.next = 6;
                          return src_services_Blockchain_service__WEBPACK_IMPORTED_MODULE_15__["BlockchainService"].getCurrentAccount();

                        case 6:
                          _context.t4 = _context.sent;
                          _context.t5 = {
                            account: _context.t4
                          };
                          _context.t6 = (0, _context.t1)(_context.t2, _context.t3, _context.t5);

                          _context.t0.setState.call(_context.t0, _context.t6);

                        case 10:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                })));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0,, 3, 6]]);
      }));

      function componentDidMount() {
        return _componentDidMount.apply(this, arguments);
      }

      return componentDidMount;
    }()
  }]);

  function App(props) {
    var _this;

    Object(C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__["default"])(this, App);

    _this = _super.call(this, props);
    _this.state = {
      account: '0x0',
      isConnectingToBlockchain: true
    };
    return _this;
  }

  Object(C_Users_WSDT_Desktop_Wavect_io_wavect_io_token_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(App, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["Fragment"], {
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])(next_head__WEBPACK_IMPORTED_MODULE_18___default.a, {
          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])("title", {
            children: "Wavect\xAE Token - Pay in Crypto & Save Money"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 47,
            columnNumber: 9
          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])("meta", {
            property: "og:title",
            content: "Wavect\xAE Token - Pay in Crypto & Save Money"
          }, "title", false, {
            fileName: _jsxFileName,
            lineNumber: 48,
            columnNumber: 9
          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])("script", {
            src: "https://cdn.rawgit.com/progers/pathseg/master/pathseg.js"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 49,
            columnNumber: 9
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 46,
          columnNumber: 7
        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])("div", {
          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])(react_notifications_component__WEBPACK_IMPORTED_MODULE_10___default.a, {}, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 52,
            columnNumber: 9
          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])(src_subcomponents_BgParticles_BgParticles__WEBPACK_IMPORTED_MODULE_19__["BgParticles"], {}, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 53,
            columnNumber: 9
          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])(_subcomponents_Navbar_Navbar__WEBPACK_IMPORTED_MODULE_12__["default"], {
            account: this.state.account
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 54,
            columnNumber: 9
          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])("div", {
            className: "container-fluid mt-5",
            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])("div", {
              className: "row",
              children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])("main", {
                role: "main",
                className: "col-lg-12 ml-auto mr-auto",
                style: {
                  maxWidth: '85%'
                },
                children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])("div", {
                  className: "content mr-auto ml-auto",
                  children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_8__["jsxDEV"])(_subcomponents_Main_Main__WEBPACK_IMPORTED_MODULE_13__["default"], {
                    showMaintenanceMode: src_services_Environment_service__WEBPACK_IMPORTED_MODULE_14__["EnvironmentService"].isProductionEnv(),
                    isConnectingToBlockchain: this.state.isConnectingToBlockchain
                  }, void 0, false, {
                    fileName: _jsxFileName,
                    lineNumber: 60,
                    columnNumber: 15
                  }, this)
                }, void 0, false, {
                  fileName: _jsxFileName,
                  lineNumber: 58,
                  columnNumber: 15
                }, this)
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 57,
                columnNumber: 13
              }, this)
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 56,
              columnNumber: 11
            }, this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 55,
            columnNumber: 9
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 51,
          columnNumber: 7
        }, this)]
      }, void 0, true);
    }
  }]);

  return App;
}(react__WEBPACK_IMPORTED_MODULE_11__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (App);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/subcomponents/BgParticles/BgParticles.module.css":
/*!**************************************************************!*\
  !*** ./src/subcomponents/BgParticles/BgParticles.module.css ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./BgParticles.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./src/subcomponents/BgParticles/BgParticles.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b) {
  if (!a && b || a && !b) {
    return false;
  }

  var p;

  for (p in a) {
    if (a[p] !== b[p]) {
      return false;
    }
  }

  for (p in b) {
    if (!a[p]) {
      return false;
    }
  }

  return true;
};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./BgParticles.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./src/subcomponents/BgParticles/BgParticles.module.css",
      function () {
        content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-2-2!./BgParticles.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./src/subcomponents/BgParticles/BgParticles.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./src/subcomponents/BgParticles/BgParticles.tsx":
/*!*******************************************************!*\
  !*** ./src/subcomponents/BgParticles/BgParticles.tsx ***!
  \*******************************************************/
/*! exports provided: BgParticles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BgParticles", function() { return BgParticles; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_particles_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-particles-js */ "./node_modules/react-particles-js/index.js");
/* harmony import */ var react_particles_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_particles_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _BgParticles_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BgParticles.module.css */ "./src/subcomponents/BgParticles/BgParticles.module.css");
/* harmony import */ var _BgParticles_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_BgParticles_module_css__WEBPACK_IMPORTED_MODULE_2__);


var _jsxFileName = "C:\\Users\\WSDT\\Desktop\\Wavect.io\\wavect.io\\token\\src\\subcomponents\\BgParticles\\BgParticles.tsx",
    _this = undefined;



var BgParticles = function BgParticles(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_particles_js__WEBPACK_IMPORTED_MODULE_1___default.a, {
    canvasClassName: _BgParticles_module_css__WEBPACK_IMPORTED_MODULE_2___default.a.particlesBg,
    params: {
      "particles": {
        "number": {
          "value": 60
        },
        "size": {
          "value": 2
        }
      },
      "interactivity": {
        "events": {
          "onhover": {
            "enable": true,
            "mode": "repulse"
          }
        }
      },
      "retina_detect": true
    }
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 6,
    columnNumber: 12
  }, _this);
};
/*
  polygon: {
            enable: true,
            type: 'inside',
            move: {
                radius: 10
            },
            url: AssetService.getPath('Logo_WAVECT_color_sym.svg'),
        }
*/

_c = BgParticles;

var _c;

$RefreshReg$(_c, "BgParticles");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ })

})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N1YmNvbXBvbmVudHMvQmdQYXJ0aWNsZXMvQmdQYXJ0aWNsZXMubW9kdWxlLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTb21lLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0VxdWFsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wYXJ0aWNsZXMtanMvY2pzL3BhcnRpY2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBhcnRpY2xlcy1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvQ29yZS9DYW52YXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0NvcmUvQ29udGFpbmVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9Db3JlL0ZyYW1lTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvQ29yZS9Mb2FkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0NvcmUvUGFydGljbGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0NvcmUvUGFydGljbGUvSW5mZWN0ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0NvcmUvUGFydGljbGUvSW50ZXJhY3Rpb25NYW5hZ2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9Db3JlL1BhcnRpY2xlL01vdmVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9Db3JlL1BhcnRpY2xlL1VwZGF0ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0NvcmUvUGFydGljbGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9Db3JlL1JldGluYS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvQW5pbWF0aW9uU3RhdHVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9EaXJlY3Rpb25zL01vdmVEaXJlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL0RpcmVjdGlvbnMvT3V0TW9kZURpcmVjdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvRGlyZWN0aW9ucy9Sb3RhdGVEaXJlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL0RpcmVjdGlvbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL0ludGVyYWN0aXZpdHlEZXRlY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL01vZGVzL0NsaWNrTW9kZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvTW9kZXMvQ29sbGlzaW9uTW9kZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvTW9kZXMvRGl2TW9kZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvTW9kZXMvSG92ZXJNb2RlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Nb2Rlcy9PdXRNb2RlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Nb2Rlcy9TaXplTW9kZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvTW9kZXMvVGhlbWVNb2RlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Nb2Rlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvTW92ZURpcmVjdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvT3V0TW9kZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvUG9seWdvbk1hc2tJbmxpbmVBcnJhbmdlbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvUG9seWdvbk1hc2tNb3ZlVHlwZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvUG9seWdvbk1hc2tUeXBlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Qcm9jZXNzQnViYmxlVHlwZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvUm90YXRlRGlyZWN0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9TaGFwZVR5cGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL1R5cGVzL0Rlc3Ryb3lUeXBlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9UeXBlcy9EaXZUeXBlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9UeXBlcy9Qcm9jZXNzQnViYmxlVHlwZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvVHlwZXMvU2hhcGVUeXBlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9UeXBlcy9TdGFydFZhbHVlVHlwZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvVHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9JbnRlcmFjdGlvbnMvRXh0ZXJuYWwvQXR0cmFjdG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9JbnRlcmFjdGlvbnMvRXh0ZXJuYWwvQm91bmNlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvSW50ZXJhY3Rpb25zL0V4dGVybmFsL0J1YmJsZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0ludGVyYWN0aW9ucy9FeHRlcm5hbC9Db25uZWN0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0ludGVyYWN0aW9ucy9FeHRlcm5hbC9HcmFiYmVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9JbnRlcmFjdGlvbnMvRXh0ZXJuYWwvTGlnaHRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvSW50ZXJhY3Rpb25zL0V4dGVybmFsL1JlcHVsc2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9JbnRlcmFjdGlvbnMvRXh0ZXJuYWwvVHJhaWxNYWtlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvSW50ZXJhY3Rpb25zL1BhcnRpY2xlcy9BdHRyYWN0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0ludGVyYWN0aW9ucy9QYXJ0aWNsZXMvQ29sbGlkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0ludGVyYWN0aW9ucy9QYXJ0aWNsZXMvSW5mZWN0ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0ludGVyYWN0aW9ucy9QYXJ0aWNsZXMvTGlnaHRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvSW50ZXJhY3Rpb25zL1BhcnRpY2xlcy9MaW5rZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9CYWNrZ3JvdW5kL0JhY2tncm91bmQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9CYWNrZ3JvdW5kTWFzay9CYWNrZ3JvdW5kTWFzay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0JhY2tncm91bmRNYXNrL0JhY2tncm91bmRNYXNrQ292ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9CYWNrZ3JvdW5kTW9kZS9CYWNrZ3JvdW5kTW9kZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0luZmVjdGlvbi9JbmZlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbmZlY3Rpb24vSW5mZWN0aW9uU3RhZ2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L0V2ZW50cy9DbGlja0V2ZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9FdmVudHMvRGl2RXZlbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L0V2ZW50cy9FdmVudHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L0V2ZW50cy9Ib3ZlckV2ZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9FdmVudHMvUGFyYWxsYXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L0ludGVyYWN0aXZpdHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL0F0dHJhY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL0JvdW5jZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvQnViYmxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9Nb2Rlcy9CdWJibGVCYXNlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9Nb2Rlcy9CdWJibGVEaXYuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL0Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL0Nvbm5lY3RMaW5rcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvR3JhYi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvR3JhYkxpbmtzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9Nb2Rlcy9MaWdodC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvTGlnaHRBcmVhLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9Nb2Rlcy9MaWdodEdyYWRpZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9Nb2Rlcy9MaWdodFNoYWRvdy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvTW9kZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL1B1c2guanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL1JlbW92ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvUmVwdWxzZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvUmVwdWxzZUJhc2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL1JlcHVsc2VEaXYuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL1Nsb3cuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL1RyYWlsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvTWFudWFsUGFydGljbGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9Nb3Rpb24vTW90aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvTW90aW9uL01vdGlvblJlZHVjZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL09wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9PcHRpb25zQ29sb3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvQW5pbWF0YWJsZUNvbG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL0JvdW5jZS9Cb3VuY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvQm91bmNlL0JvdW5jZUZhY3Rvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9Db2xsaXNpb25zLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL0NvbG9yQW5pbWF0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL0xpZmUvTGlmZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9MaWZlL0xpZmVEZWxheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9MaWZlL0xpZmVEdXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9MaW5rcy9MaW5rcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9MaW5rcy9MaW5rc1NoYWRvdy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9MaW5rcy9MaW5rc1RyaWFuZ2xlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL01vdmUvQXR0cmFjdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9Nb3ZlL01vdmUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTW92ZS9Nb3ZlQW5nbGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTW92ZS9Nb3ZlR3Jhdml0eS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9Nb3ZlL05vaXNlL05vaXNlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL01vdmUvTm9pc2UvTm9pc2VEZWxheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9Nb3ZlL091dE1vZGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL01vdmUvVHJhaWwuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTnVtYmVyL0RlbnNpdHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTnVtYmVyL1BhcnRpY2xlc051bWJlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9PcGFjaXR5L09wYWNpdHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvT3BhY2l0eS9PcGFjaXR5QW5pbWF0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL1BhcnRpY2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9Sb3RhdGUvUm90YXRlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL1JvdGF0ZS9Sb3RhdGVBbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvU2hhZG93LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL1NoYXBlL1NoYXBlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL1NpemUvU2l6ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9TaXplL1NpemVBbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvU3Ryb2tlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL1R3aW5rbGUvVHdpbmtsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9Ud2lua2xlL1R3aW5rbGVWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9SYW5kb20uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9UaGVtZS9UaGVtZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1RoZW1lL1RoZW1lRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1ZhbHVlV2l0aFJhbmRvbS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9BYnNvcmJlcnMvQWJzb3JiZXJJbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9BYnNvcmJlcnMvQWJzb3JiZXJzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0Fic29yYmVycy9BYnNvcmJlcnNQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvQWJzb3JiZXJzL0VudW1zL0Fic29yYmVyQ2xpY2tNb2RlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0Fic29yYmVycy9FbnVtcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9BYnNvcmJlcnMvT3B0aW9ucy9DbGFzc2VzL0Fic29yYmVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0Fic29yYmVycy9PcHRpb25zL0NsYXNzZXMvQWJzb3JiZXJTaXplLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0VtaXR0ZXJzL0VtaXR0ZXJJbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9FbWl0dGVycy9FbWl0dGVycy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9FbWl0dGVycy9FbWl0dGVyc1BsdWdpbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9FbWl0dGVycy9FbnVtcy9FbWl0dGVyQ2xpY2tNb2RlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0VtaXR0ZXJzL0VudW1zL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0VtaXR0ZXJzL09wdGlvbnMvQ2xhc3Nlcy9FbWl0dGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0VtaXR0ZXJzL09wdGlvbnMvQ2xhc3Nlcy9FbWl0dGVyTGlmZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9FbWl0dGVycy9PcHRpb25zL0NsYXNzZXMvRW1pdHRlclJhdGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvRW1pdHRlcnMvT3B0aW9ucy9DbGFzc2VzL0VtaXR0ZXJTaXplLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL1BvbHlnb25NYXNrL0VudW1zL0lubGluZUFycmFuZ2VtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL1BvbHlnb25NYXNrL0VudW1zL01vdmVUeXBlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL1BvbHlnb25NYXNrL0VudW1zL1R5cGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvUG9seWdvbk1hc2svRW51bXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvUG9seWdvbk1hc2svT3B0aW9ucy9DbGFzc2VzL0RyYXcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvUG9seWdvbk1hc2svT3B0aW9ucy9DbGFzc2VzL0RyYXdTdHJva2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvUG9seWdvbk1hc2svT3B0aW9ucy9DbGFzc2VzL0lubGluZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9Qb2x5Z29uTWFzay9PcHRpb25zL0NsYXNzZXMvTG9jYWxTdmcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvUG9seWdvbk1hc2svT3B0aW9ucy9DbGFzc2VzL01vdmUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvUG9seWdvbk1hc2svT3B0aW9ucy9DbGFzc2VzL1BvbHlnb25NYXNrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL1BvbHlnb25NYXNrL1BvbHlnb25NYXNrSW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvUG9seWdvbk1hc2svUG9seWdvbk1hc2tQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1NoYXBlRHJhd2Vycy9DaXJjbGVEcmF3ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1NoYXBlRHJhd2Vycy9JbWFnZURyYXdlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvU2hhcGVEcmF3ZXJzL0xpbmVEcmF3ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1NoYXBlRHJhd2Vycy9Qb2x5Z29uRHJhd2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9TaGFwZURyYXdlcnMvUG9seWdvbkRyYXdlckJhc2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1NoYXBlRHJhd2Vycy9TcXVhcmVEcmF3ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1NoYXBlRHJhd2Vycy9TdGFyRHJhd2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9TaGFwZURyYXdlcnMvVGV4dERyYXdlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvU2hhcGVEcmF3ZXJzL1RyaWFuZ2xlRHJhd2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9UeXBlcy9SZWN1cnNpdmVQYXJ0aWFsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9UeXBlcy9TaGFwZURhdGEuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1R5cGVzL1NoYXBlRHJhd2VyRnVuY3Rpb25zLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9UeXBlcy9TaW5nbGVPck11bHRpcGxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9UeXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVXRpbHMvQ2FudmFzVXRpbHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1V0aWxzL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVXRpbHMvQ2lyY2xlV2FycC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVXRpbHMvQ29sb3JVdGlscy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVXRpbHMvQ29uc3RhbnRzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9VdGlscy9FdmVudExpc3RlbmVycy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVXRpbHMvTnVtYmVyVXRpbHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1V0aWxzL1BsdWdpbnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1V0aWxzL1BvaW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9VdGlscy9RdWFkVHJlZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVXRpbHMvUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1V0aWxzL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVXRpbHMvVXRpbHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1V0aWxzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvbWFpbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvbWFpbi5zbGltLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9wanMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9wYWdlcy9fYXBwLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N1YmNvbXBvbmVudHMvQmdQYXJ0aWNsZXMvQmdQYXJ0aWNsZXMubW9kdWxlLmNzcz82ZmVmIiwid2VicGFjazovL19OX0UvLi9zcmMvc3ViY29tcG9uZW50cy9CZ1BhcnRpY2xlcy9CZ1BhcnRpY2xlcy50c3giXSwibmFtZXMiOlsiQXBwIiwiQmxvY2tjaGFpblNlcnZpY2UiLCJjb25uZWN0VG9CbG9ja2NoYWluIiwic2V0U3RhdGUiLCJzdGF0ZSIsImlzQ29ubmVjdGluZ1RvQmxvY2tjaGFpbiIsIkVtaXR0ZXIiLCJvbiIsIkVWRU5UX0JMT0NLQ0hBSU5fREFUQV9DSEFOR0VEIiwiZ2V0Q3VycmVudEFjY291bnQiLCJhY2NvdW50IiwicHJvcHMiLCJtYXhXaWR0aCIsIkVudmlyb25tZW50U2VydmljZSIsImlzUHJvZHVjdGlvbkVudiIsIkNvbXBvbmVudCIsIkJnUGFydGljbGVzIiwic3R5bGVzIiwicGFydGljbGVzQmciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsMkdBQXNEO0FBQ2hHO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUyxvQ0FBb0MsdUVBQXVFLHFCQUFxQixvQkFBb0IscUJBQXFCLG9IQUFvSCxpQkFBaUIsaURBQWlELGFBQWEsY0FBYyxvQ0FBb0MseUJBQXlCLHlCQUF5QixxQkFBcUIsbUJBQW1CLDJCQUEyQixHQUFHLE9BQU8scUhBQXFILFlBQVksV0FBVyxZQUFZLFdBQVcsWUFBWSxhQUFhLFdBQVcsVUFBVSxZQUFZLGFBQWEsV0FBVyxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsV0FBVyxZQUFZLHdDQUF3Qyw0RUFBNEUsdUJBQXVCLHNCQUFzQixzQkFBc0IsMEhBQTBILGtCQUFrQix1REFBdUQs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOVFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0JhO0FBQ2I7QUFDQSwyQkFBMkIsK0RBQStELGdCQUFnQixFQUFFLEVBQUU7QUFDOUc7QUFDQSxtQ0FBbUMsTUFBTSw2QkFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZaYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekZhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyw2R0FBcUM7QUFDL0QsbUJBQW1CLG1CQUFPLENBQUMsK0dBQXNDO0FBQ2pFLGtCQUFrQixtQkFBTyxDQUFDLDZHQUFxQztBQUMvRCxvQkFBb0IsbUJBQU8sQ0FBQyxpSEFBdUM7QUFDbkUsaUJBQWlCLG1CQUFPLENBQUMsNkdBQXFDO0FBQzlELG9CQUFvQixtQkFBTyxDQUFDLG1IQUF3QztBQUNwRSxtQkFBbUIsbUJBQU8sQ0FBQyxpSEFBdUM7QUFDbEUsbUJBQW1CLG1CQUFPLENBQUMsaUhBQXVDO0FBQ2xFLHFCQUFxQixtQkFBTyxDQUFDLG1IQUF3QztBQUNyRSxvQkFBb0IsbUJBQU8sQ0FBQyxpSEFBdUM7QUFDbkUsa0JBQWtCLG1CQUFPLENBQUMsK0dBQXNDO0FBQ2hFLGtCQUFrQixtQkFBTyxDQUFDLDZHQUFxQztBQUMvRCxrQkFBa0IsbUJBQU8sQ0FBQyw2R0FBcUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekRhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEphO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQywyQkFBMkIsbUJBQU8sQ0FBQyxxSEFBeUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0R2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekRhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQ2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEZhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsOEJBQThCLG1CQUFPLENBQUMsb0hBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakYsaUVBQWlFLGVBQWU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLHdGQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMscUdBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5RGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHdHQUFjO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLG9HQUFZO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLHdHQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6RGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLG9HQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMsdUdBQWlCO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLG1HQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHFHQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLHVHQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJGQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyx1R0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0Q2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJHQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQ2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2RhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxxR0FBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQywyRkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHFHQUFhO0FBQ3pDLHNCQUFzQixtQkFBTyxDQUFDLHlHQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDZHQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25CYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsMkZBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQywyRkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsK0ZBQVU7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMsaUdBQVc7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDJGQUFRO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLCtGQUFVO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQywyRkFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyxpR0FBVztBQUNyQyxlQUFlLG1CQUFPLENBQUMsMkZBQVE7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsNkZBQVM7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsaUdBQVc7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsNkZBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsK0ZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1Q2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsdUdBQWM7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMseUdBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHlHQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMseUVBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsOEZBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLHFIQUErQjtBQUMvRCxvQkFBb0IsbUJBQU8sQ0FBQyxxR0FBdUI7QUFDbkQseUJBQXlCLG1CQUFPLENBQUMseUhBQWlDO0FBQ2xFLHFCQUFxQixtQkFBTyxDQUFDLHlHQUF5QjtBQUN0RCxvQkFBb0IsbUJBQU8sQ0FBQyxxR0FBdUI7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMscUZBQWU7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQW1CO0FBQzNDLHlCQUF5QixtQkFBTyxDQUFDLHlIQUFpQztBQUNsRSxpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDMUMseUJBQXlCLG1CQUFPLENBQUMsMkZBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxSGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQWlCO0FBQ2hELHlCQUF5QixtQkFBTyxDQUFDLHFHQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyx3R0FBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsaUdBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNYYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQWdCO0FBQ3hDLGlCQUFpQixtQkFBTyxDQUFDLG1HQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsZ0dBQWE7QUFDekMsdUJBQXVCLG1CQUFPLENBQUMsc0dBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsaUdBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxpR0FBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMscUdBQWU7QUFDN0Msd0JBQXdCLG1CQUFPLENBQUMseUdBQWlCO0FBQ2pELHVCQUF1QixtQkFBTyxDQUFDLDJGQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4RGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJGQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJGQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNEZBQVc7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMseUVBQW1CO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLHdGQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLG9HQUFlO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLGdHQUFhO0FBQ3pDLHNCQUFzQixtQkFBTyxDQUFDLG9HQUFlO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDhGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUdhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyx3R0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25CYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsb0dBQTBCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1RhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJGQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsOEZBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLDJCQUEyQixtQkFBTyxDQUFDLGlIQUFvQjtBQUN2RCwwQkFBMEIsbUJBQU8sQ0FBQyxpR0FBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMscUZBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsK0ZBQWU7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLDJGQUFhO0FBQ3BDLDBCQUEwQixtQkFBTyxDQUFDLHFIQUEwQjtBQUM1RCxrQkFBa0IsbUJBQU8sQ0FBQyx1R0FBbUI7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsK0ZBQWU7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLDJGQUFhO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLG1HQUFpQjtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxxQkFBcUIsbUJBQU8sQ0FBQyw2RkFBYztBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyx1R0FBbUI7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsdUdBQW1CO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQywyRkFBYTtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxtR0FBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5RmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLDhHQUFtQjtBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDM0MsMEJBQTBCLG1CQUFPLENBQUMsaUdBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0JhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckNhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMseUVBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSUFBaUk7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQSwrSEFBK0g7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZHYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsd0dBQWlCO0FBQ2pELDBCQUEwQixtQkFBTyxDQUFDLGlHQUF1QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0NhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsMkdBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJGQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDeEMsdUJBQXVCLG1CQUFPLENBQUMsNkZBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDJFQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsdUJBQXVCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZJYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsaUdBQW9CO0FBQ3ZELGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLGlIQUE0QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuSGE7QUFDYjtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQyxhQUFhLEVBQUUsRUFBRTtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLG1GQUFhO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLGlGQUFTO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLGlIQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxpRkFBUzs7Ozs7Ozs7Ozs7OztBQ3hGakI7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0ZBQWtGOzs7Ozs7Ozs7Ozs7O0FDTnRFO0FBQ2I7QUFDQTtBQUNBLGtDQUFrQyxvQ0FBb0MsYUFBYSxFQUFFLEVBQUU7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsYUFBYSxtQkFBTyxDQUFDLHlHQUFxQjs7Ozs7Ozs7Ozs7OztBQ1o3QjtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMseUdBQWdCO0FBQy9DLHVCQUF1QixtQkFBTyxDQUFDLGlIQUEwQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0NhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyx1SEFBNkM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0JhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQyxzSEFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQXVDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoSWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLDhGQUFtQjtBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQyxrQkFBa0IsbUJBQU8sQ0FBQyw4R0FBMkI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlHYTtBQUNiO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DLGFBQWEsRUFBRSxFQUFFO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQVM7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsOEdBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGdGQUFTOzs7Ozs7Ozs7Ozs7O0FDeEZqQjtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywrRUFBK0U7Ozs7Ozs7Ozs7Ozs7QUNObkU7QUFDYjtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQyxhQUFhLEVBQUUsRUFBRTtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCxhQUFhLG1CQUFPLENBQUMsc0dBQW9COzs7Ozs7Ozs7Ozs7O0FDWjVCO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsc0dBQWU7QUFDN0Msc0JBQXNCLG1CQUFPLENBQUMsc0dBQWU7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMseUVBQW1CO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLHNHQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtGQUFrRjs7Ozs7Ozs7Ozs7OztBQ1Z0RTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVEQUF1RDs7Ozs7Ozs7Ozs7OztBQ1AzQztBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQ0FBMkM7Ozs7Ozs7Ozs7Ozs7QUNUL0I7QUFDYjtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQyxhQUFhLEVBQUUsRUFBRTtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCxhQUFhLG1CQUFPLENBQUMsMkdBQXFCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyx5RkFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsaUZBQVE7Ozs7Ozs7Ozs7Ozs7QUNkaEI7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHVHQUFjO0FBQzNDLHVCQUF1QixtQkFBTyxDQUFDLGlIQUEwQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxpSEFBMEM7QUFDekUsZ0JBQWdCLG1CQUFPLENBQUMseUVBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHVGQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsdUZBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsdUZBQWE7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDJGQUFRO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQywyRkFBUTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQywrRkFBVTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyxtR0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRWE7QUFDYjtBQUNBLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLHlIQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxQkFBcUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRLElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxxREFBcUQ7QUFDaEg7QUFDQTtBQUNBLHVCQUF1QixRQUFRLElBQUksUUFBUSxLQUFLLFFBQVEsS0FBSyxxREFBcUQ7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5WmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBVTtBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBYTtBQUN6QztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDalVhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxxQkFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hUYTtBQUNiO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DLGFBQWEsRUFBRSxFQUFFO0FBQ3ZGLENBQUM7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QyxzQkFBTyxxRUFBQyx5REFBRDtBQUFXLG1CQUFlLEVBQUVNLDhEQUFNLENBQUNDLFdBQW5DO0FBQWdELFVBQU0sRUFBRTtBQUMzRCxtQkFBYTtBQUNaLGtCQUFVO0FBQ04sbUJBQVM7QUFESCxTQURFO0FBSVosZ0JBQVE7QUFDSixtQkFBUztBQURMO0FBSkksT0FEOEM7QUFTOUQsdUJBQWlCO0FBQ2Isa0JBQVU7QUFDTixxQkFBVztBQUNQLHNCQUFVLElBREg7QUFFUCxvQkFBUTtBQUZEO0FBREw7QUFERyxPQVQ2QztBQWlCM0QsdUJBQWlCO0FBakIwQztBQUF4RDtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBQVA7QUFtQkgsQ0FwQk07QUFzQlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0tBL0JhRixXIiwiZmlsZSI6InN0YXRpYy93ZWJwYWNrL3BhZ2VzL19hcHAuYmY1N2Q2ZmJhZjgwMWMxNmY2OTAuaG90LXVwZGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5CZ1BhcnRpY2xlc19wYXJ0aWNsZXNCZ19fMVFZdkMge1xcbiAgLyogTWFrZSB2aWRlbyB0byBhdCBsZWFzdCAxMDAlIHdpZGUgYW5kIHRhbGwgKi9cXG4gIG1pbi13aWR0aDogMTAwJTtcXG4gIG1pbi1oZWlnaHQ6IDEwMCU7XFxuICBtYXgtd2lkdGg6IDEwMCU7XFxuICBtYXgtaGVpZ2h0OiAxMDAlO1xcbiAgLyogU2V0dGluZyB3aWR0aCAmIGhlaWdodCB0byBhdXRvIHByZXZlbnRzIHRoZSBicm93c2VyIGZyb20gc3RyZXRjaGluZyBvciBzcXVpc2hpbmcgdGhlIHZpZGVvICovXFxuICB3aWR0aDogYXV0bztcXG4gIGhlaWdodDogYXV0bztcXG4gIC8qIENlbnRlciB0aGUgdmlkZW8gKi9cXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTAlO1xcbiAgbGVmdDogNTAlO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwtNTAlKTtcXG4gIC1vLW9iamVjdC1maXQ6IGNvdmVyO1xcbiAgICAgb2JqZWN0LWZpdDogY292ZXI7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgei1pbmRleDogLTk5OTk7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTExO1xcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3JjL3N1YmNvbXBvbmVudHMvQmdQYXJ0aWNsZXMvQmdQYXJ0aWNsZXMubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNJLDhDQUE4QztFQUNqRCxlQUFlO0VBQ2YsZ0JBQWdCO0VBQ2hCLGVBQWU7RUFDZixnQkFBZ0I7RUFFaEIsK0ZBQStGO0VBQy9GLFdBQVc7RUFDWCxZQUFZO0VBRVoscUJBQXFCO0VBQ3JCLGtCQUFrQjtFQUNsQixRQUFRO0VBQ1IsU0FBUztFQUNULCtCQUErQjtFQUUvQixvQkFBaUI7S0FBakIsaUJBQWlCO0VBQ2pCLGdCQUFnQjtFQUNoQixjQUFjO0VBRWQsc0JBQXNCO0FBQ3ZCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5wYXJ0aWNsZXNCZyB7XFxyXFxuICAgIC8qIE1ha2UgdmlkZW8gdG8gYXQgbGVhc3QgMTAwJSB3aWRlIGFuZCB0YWxsICovXFxyXFxuIG1pbi13aWR0aDogMTAwJTsgXFxyXFxuIG1pbi1oZWlnaHQ6IDEwMCU7IFxcclxcbiBtYXgtd2lkdGg6IDEwMCU7XFxyXFxuIG1heC1oZWlnaHQ6IDEwMCU7XFxyXFxuXFxyXFxuIC8qIFNldHRpbmcgd2lkdGggJiBoZWlnaHQgdG8gYXV0byBwcmV2ZW50cyB0aGUgYnJvd3NlciBmcm9tIHN0cmV0Y2hpbmcgb3Igc3F1aXNoaW5nIHRoZSB2aWRlbyAqL1xcclxcbiB3aWR0aDogYXV0bztcXHJcXG4gaGVpZ2h0OiBhdXRvO1xcclxcblxcclxcbiAvKiBDZW50ZXIgdGhlIHZpZGVvICovXFxyXFxuIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gdG9wOiA1MCU7XFxyXFxuIGxlZnQ6IDUwJTtcXHJcXG4gdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwtNTAlKTtcXHJcXG5cXHJcXG4gb2JqZWN0LWZpdDogY292ZXI7XFxyXFxuIG92ZXJmbG93OiBoaWRkZW47IFxcclxcbiB6LWluZGV4OiAtOTk5OTtcXHJcXG5cXHJcXG4gYmFja2dyb3VuZC1jb2xvcjogIzExMTtcXHJcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwicGFydGljbGVzQmdcIjogXCJCZ1BhcnRpY2xlc19wYXJ0aWNsZXNCZ19fMVFZdkNcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgaWYgKGFyclN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQXJyYXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwidmFyIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBvYmpTdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgaWYgKG9ialN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgIHJldHVybiBvYmpTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gb2JqZWN0O1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCIhZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdCllW3JdPXRbcl19KGV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIGk9dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsciksaS5sPSEwLGkuZXhwb3J0c31yZXR1cm4gci5tPWUsci5jPXQsci5kPWZ1bmN0aW9uKGUsdCxuKXtyLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxyLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1yKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoci5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgaSBpbiBlKXIuZChuLGksZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxpKSk7cmV0dXJuIG59LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxyLnA9XCJcIixyKHIucz0xKX0oW2Z1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXJlcXVpcmUoXCJyZWFjdFwiKX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixuKXt2b2lkIDA9PT1uJiYobj1yKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pfTpmdW5jdGlvbihlLHQscixuKXt2b2lkIDA9PT1uJiYobj1yKSxlW25dPXRbcl19KSxpPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiBlKVwiZGVmYXVsdFwiPT09cnx8dC5oYXNPd25Qcm9wZXJ0eShyKXx8bih0LGUscil9LG89dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5QYXJ0aWNsZXM9dm9pZCAwO3ZhciBhPW8ocigyKSk7dC5QYXJ0aWNsZXM9YS5kZWZhdWx0LGkocigxMCksdCksaShyKDExKSx0KSxpKHIoMTIpLHQpLGkocigxMyksdCksaShyKDE0KSx0KSxpKHIoMTUpLHQpLGkocigxNiksdCksaShyKDE3KSx0KSxpKHIoMTgpLHQpLGkocigxOSksdCksaShyKDIwKSx0KSxpKHIoMjEpLHQpLHQuZGVmYXVsdD1hLmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUpe3JldHVybihuPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1mdW5jdGlvbiBvKGUsdCxyKXtyZXR1cm4obz1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5nZXQ/UmVmbGVjdC5nZXQ6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWZ1bmN0aW9uKGUsdCl7Zm9yKDshT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkmJm51bGwhPT0oZT1sKGUpKTspO3JldHVybiBlfShlLHQpO2lmKG4pe3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtyZXR1cm4gaS5nZXQ/aS5nZXQuY2FsbChyKTppLnZhbHVlfX0pKGUsdCxyfHxlKX1mdW5jdGlvbiBhKGUsdCl7cmV0dXJuKGE9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfWZ1bmN0aW9uIHMoZSl7dmFyIHQ9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaChlKXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHIsbj1sKGUpO2lmKHQpe3ZhciBpPWwodGhpcykuY29uc3RydWN0b3I7cj1SZWZsZWN0LmNvbnN0cnVjdChuLGFyZ3VtZW50cyxpKX1lbHNlIHI9bi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHUodGhpcyxyKX19ZnVuY3Rpb24gdShlLHQpe3JldHVybiF0fHxcIm9iamVjdFwiIT09bih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9jKGUpOnR9ZnVuY3Rpb24gYyhlKXtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gZX1mdW5jdGlvbiBsKGUpe3JldHVybihsPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX12YXIgZj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsbil7dm9pZCAwPT09biYmKG49ciksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtyXX19KX06ZnVuY3Rpb24oZSx0LHIsbil7dm9pZCAwPT09biYmKG49ciksZVtuXT10W3JdfSkscD10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSl9OmZ1bmN0aW9uKGUsdCl7ZS5kZWZhdWx0PXR9KSxkPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlcImRlZmF1bHRcIiE9PXImJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJmYodCxlLHIpO3JldHVybiBwKHQsZSksdH0seT10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgdj1kKHIoMCkpLGI9cigwKSxoPXkocigzKSksbT1yKDQpLGc9cig1KSxQPXIoNiksTz1yKDkpLF89ZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiZhKGUsdCl9KGYsZSk7dmFyIHQscixuLHU9cyhmKTtmdW5jdGlvbiBmKGUpe3ZhciB0O3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZiksKHQ9dS5jYWxsKHRoaXMsZSkpLnN0YXRlPXtjYW52YXM6dm9pZCAwLGxpYnJhcnk6dm9pZCAwfSx0LmxvYWRDYW52YXM9dC5sb2FkQ2FudmFzLmJpbmQoYyh0KSksdH1yZXR1cm4gdD1mLChyPVt7a2V5OlwiYnVpbGRQYXJ0aWNsZXNMaWJyYXJ5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0cnl7aWYodm9pZCAwPT09d2luZG93KXJldHVybiBudWxsfWNhdGNoKGUpe3JldHVybiBudWxsfU8udHNQYXJ0aWNsZXMuaW5pdCgpO3ZhciByPW5ldyBtLk9wdGlvbnM7ci5sb2FkKFAuZGVmYXVsdFBhcmFtcyksci5sb2FkKHQpO3ZhciBuPW5ldyBnLkNvbnRhaW5lcihlLHIpO3JldHVybiB0aGlzLnByb3BzLnBhcnRpY2xlc1JlZiYmKHRoaXMucHJvcHMucGFydGljbGVzUmVmLmN1cnJlbnQ9biksbn19LHtrZXk6XCJyZWZyZXNoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPXRoaXMuc3RhdGUuY2FudmFzO3ImJih0aGlzLmRlc3Ryb3koKSx0aGlzLnNldFN0YXRlKHtsaWJyYXJ5OnRoaXMuYnVpbGRQYXJ0aWNsZXNMaWJyYXJ5KGUuaWQsZS5wYXJhbXMpfSwoZnVuY3Rpb24oKXt0LmxvYWRDYW52YXMocil9KSkpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc3RhdGUubGlicmFyeSYmdGhpcy5zdGF0ZS5saWJyYXJ5LmRlc3Ryb3koKX19LHtrZXk6XCJsb2FkQ2FudmFzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztlJiZ0aGlzLnNldFN0YXRlKHtjYW52YXM6ZX0sKGZ1bmN0aW9uKCl7dmFyIHI9dC5zdGF0ZS5saWJyYXJ5O3ImJihyLmNhbnZhcy5sb2FkQ2FudmFzKGUpLHIuc3RhcnQoKSl9KSl9fSx7a2V5Olwic2hvdWxkQ29tcG9uZW50VXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIWguZGVmYXVsdChlLHRoaXMucHJvcHMpfX0se2tleTpcImNvbXBvbmVudERpZFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5yZWZyZXNoKHRoaXMucHJvcHMpfX0se2tleTpcImZvcmNlVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnJlZnJlc2godGhpcy5wcm9wcyksbyhsKGYucHJvdG90eXBlKSxcImZvcmNlVXBkYXRlXCIsdGhpcykuY2FsbCh0aGlzKX19LHtrZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zZXRTdGF0ZSh7bGlicmFyeTp0aGlzLmJ1aWxkUGFydGljbGVzTGlicmFyeSh0aGlzLnByb3BzLmlkLHRoaXMucHJvcHMucGFyYW1zKX0pfX0se2tleTpcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmRlc3Ryb3koKSx0aGlzLnNldFN0YXRlKHtsaWJyYXJ5OnZvaWQgMH0pfX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PWUud2lkdGgscj1lLmhlaWdodCxuPWUuY2xhc3NOYW1lLGk9ZS5jYW52YXNDbGFzc05hbWUsbz1lLmlkO3JldHVybiB2LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOm4saWQ6b30sdi5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIse3JlZjp0aGlzLmxvYWRDYW52YXMsY2xhc3NOYW1lOmksc3R5bGU6T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMucHJvcHMuc3R5bGUpLHt3aWR0aDp0LGhlaWdodDpyfSl9KSl9fV0pJiZpKHQucHJvdG90eXBlLHIpLG4mJmkodCxuKSxmfShiLkNvbXBvbmVudCk7dC5kZWZhdWx0PV8sXy5kZWZhdWx0UHJvcHM9e3dpZHRoOlwiMTAwJVwiLGhlaWdodDpcIjEwMCVcIixwYXJhbXM6UC5kZWZhdWx0UGFyYW1zLHN0eWxlOnt9LGlkOlwidHNwYXJ0aWNsZXNcIn19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXJlcXVpcmUoXCJsb2Rhc2gvaXNFcXVhbFwiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL09wdGlvbnNcIil9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXJlcXVpcmUoXCJ0c3BhcnRpY2xlcy9kaXN0L0NvcmUvQ29udGFpbmVyXCIpfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0UGFyYW1zPXZvaWQgMDt2YXIgbj1yKDcpLGk9cig4KTt0LmRlZmF1bHRQYXJhbXM9e3BhcnRpY2xlczp7bnVtYmVyOnt2YWx1ZTo0MCxtYXg6LTEsZGVuc2l0eTp7ZW5hYmxlOiExLGFyZWE6MTIwMH19LGNvbG9yOnt2YWx1ZTpcIiNGRkZcIn0sc2hhcGU6e3R5cGU6bi5TaGFwZVR5cGUuY2lyY2xlLHBvbHlnb246e3NpZGVzOjV9LGltYWdlOntzcmM6XCJcIix3aWR0aDoxMDAsaGVpZ2h0OjEwMH19LHN0cm9rZTp7d2lkdGg6MCxjb2xvcjpcIiMwMDAwMDBcIn0sb3BhY2l0eTp7dmFsdWU6LjUscmFuZG9tOiExLGFuaW06e2VuYWJsZTohMCxzcGVlZDoxLG1pbmltdW1WYWx1ZTouMSxzeW5jOiExfX0sc2l6ZTp7dmFsdWU6MSxyYW5kb206ITEsYW5pbTp7ZW5hYmxlOiExLHNwZWVkOjQwLG1pbmltdW1WYWx1ZTowLHN5bmM6ITF9fSxsaW5rczp7ZW5hYmxlOiEwLGRpc3RhbmNlOjE1MCxjb2xvcjpcIiNGRkZcIixvcGFjaXR5Oi42LHdpZHRoOjEsc2hhZG93OntlbmFibGU6ITEsYmx1cjo1LGNvbG9yOlwibGltZVwifX0sbW92ZTp7ZW5hYmxlOiEwLHNwZWVkOjMsZGlyZWN0aW9uOm4uTW92ZURpcmVjdGlvbi5ub25lLHJhbmRvbTohMSxzdHJhaWdodDohMSxvdXRNb2RlOm4uT3V0TW9kZS5ib3VuY2UsYm91bmNlOiEwLGF0dHJhY3Q6e2VuYWJsZTohMSxyb3RhdGVYOjNlMyxyb3RhdGVZOjNlM319fSxpbnRlcmFjdGl2aXR5OntkZXRlY3RzT246bi5JbnRlcmFjdGl2aXR5RGV0ZWN0LmNhbnZhcyxldmVudHM6e29uSG92ZXI6e2VuYWJsZTohMSxtb2RlOm4uSG92ZXJNb2RlLmdyYWJ9LG9uQ2xpY2s6e2VuYWJsZTohMSxtb2RlOm4uQ2xpY2tNb2RlLnJlcHVsc2V9LHJlc2l6ZTohMH0sbW9kZXM6e2dyYWI6e2Rpc3RhbmNlOjE4MCxsaW5rczp7b3BhY2l0eTouMzV9fSxidWJibGU6e2Rpc3RhbmNlOjIwMCxzaXplOjgwLGR1cmF0aW9uOi40fSxyZXB1bHNlOntkaXN0YW5jZToxMDAsZHVyYXRpb246NX0scHVzaDp7cXVhbnRpdHk6NH0scmVtb3ZlOntxdWFudGl0eToyfX19LGRldGVjdFJldGluYTohMCxmcHNMaW1pdDo5OTkscG9seWdvbjp7ZW5hYmxlOiExLHNjYWxlOjEsdHlwZTppLlR5cGUuaW5saW5lLGlubGluZTp7YXJyYW5nZW1lbnQ6aS5JbmxpbmVBcnJhbmdlbWVudC5vbmVQZXJQb2ludH0sZHJhdzp7ZW5hYmxlOiExLHN0cm9rZTp7d2lkdGg6LjUsY29sb3I6XCJyZ2JhKDI1NSwgMjU1LCAyNTUsIC4xKVwifX0sbW92ZTp7cmFkaXVzOjEwLHR5cGU6aS5Nb3ZlVHlwZS5wYXRofSx1cmw6XCJcIn19fSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9FbnVtc1wiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9Qb2x5Z29uTWFzay9Qb2x5Z29uTWFza1BsdWdpblwiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzXCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9JbnRlcmFjdGl2aXR5RGV0ZWN0XCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Nb3ZlRGlyZWN0aW9uXCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9PdXRNb2RlXCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Qb2x5Z29uTWFza0lubGluZUFycmFuZ2VtZW50XCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Qb2x5Z29uTWFza01vdmVUeXBlXCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Qb2x5Z29uTWFza1R5cGVcIil9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXJlcXVpcmUoXCJ0c3BhcnRpY2xlcy9kaXN0L0VudW1zL1Byb2Nlc3NCdWJibGVUeXBlXCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Sb3RhdGVEaXJlY3Rpb25cIil9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXJlcXVpcmUoXCJ0c3BhcnRpY2xlcy9kaXN0L0VudW1zL1NoYXBlVHlwZVwiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvRW51bXMvTW9kZXMvQ2xpY2tNb2RlXCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Nb2Rlcy9EaXZNb2RlXCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Nb2Rlcy9Ib3Zlck1vZGVcIil9XSkpOyIsImNvbnN0IFJlYWN0UGFydGljbGVzID0gcmVxdWlyZSgnLi9janMvcGFydGljbGVzJyk7XG5mb3IgKGxldCBrZXkgaW4gUmVhY3RQYXJ0aWNsZXMpIHtcbiAgICBSZWFjdFBhcnRpY2xlcy5kZWZhdWx0W2tleV0gPSBSZWFjdFBhcnRpY2xlc1trZXldO1xufVxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFBhcnRpY2xlcy5kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYW52YXMgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpO1xuY2xhc3MgQ2FudmFzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLmdlbmVyYXRlZENhbnZhcyA9IGZhbHNlO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbTtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuY29udGFpbmVyLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kTW9kZS5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbmFsU3R5bGUgPSBVdGlsc18xLlV0aWxzLmRlZXBFeHRlbmQoe30sIGVsZW1lbnQuc3R5bGUpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS56SW5kZXggPSBvcHRpb25zLmJhY2tncm91bmRNb2RlLnpJbmRleC50b1N0cmluZygxMCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAoX2IgPSAoX2EgPSB0aGlzLm9yaWdpbmFsU3R5bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3NpdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnpJbmRleCA9IChfZCA9IChfYyA9IHRoaXMub3JpZ2luYWxTdHlsZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnpJbmRleCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogXCJcIjtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IChfZiA9IChfZSA9IHRoaXMub3JpZ2luYWxTdHlsZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRvcCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogXCJcIjtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSAoX2ggPSAoX2cgPSB0aGlzLm9yaWdpbmFsU3R5bGUpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5sZWZ0KSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBcIlwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSAoX2sgPSAoX2ogPSB0aGlzLm9yaWdpbmFsU3R5bGUpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai53aWR0aCkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogXCJcIjtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IChfbSA9IChfbCA9IHRoaXMub3JpZ2luYWxTdHlsZSkgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLmhlaWdodCkgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb3ZlciA9IG9wdGlvbnMuYmFja2dyb3VuZE1hc2suY292ZXI7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gY292ZXIuY29sb3I7XG4gICAgICAgIGNvbnN0IHRyYWlsID0gb3B0aW9ucy5wYXJ0aWNsZXMubW92ZS50cmFpbDtcbiAgICAgICAgY29uc3QgY292ZXJSZ2IgPSBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb1JnYihjb2xvcik7XG4gICAgICAgIHRoaXMuY292ZXJDb2xvciA9XG4gICAgICAgICAgICBjb3ZlclJnYiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHI6IGNvdmVyUmdiLnIsXG4gICAgICAgICAgICAgICAgICAgIGc6IGNvdmVyUmdiLmcsXG4gICAgICAgICAgICAgICAgICAgIGI6IGNvdmVyUmdiLmIsXG4gICAgICAgICAgICAgICAgICAgIGE6IGNvdmVyLm9wYWNpdHksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRyYWlsRmlsbENvbG9yID0gVXRpbHNfMS5Db2xvclV0aWxzLmNvbG9yVG9SZ2IodHJhaWwuZmlsbENvbG9yKTtcbiAgICAgICAgdGhpcy5pbml0QmFja2dyb3VuZCgpO1xuICAgICAgICB0aGlzLnBhaW50KCk7XG4gICAgfVxuICAgIGxvYWRDYW52YXMoY2FudmFzLCBnZW5lcmF0ZWRDYW52YXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWNhbnZhcy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBVdGlsc18xLkNvbnN0YW50cy5jYW52YXNDbGFzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZW5lcmF0ZWRDYW52YXMpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuZWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVkQ2FudmFzID0gZ2VuZXJhdGVkQ2FudmFzICE9PSBudWxsICYmIGdlbmVyYXRlZENhbnZhcyAhPT0gdm9pZCAwID8gZ2VuZXJhdGVkQ2FudmFzIDogdGhpcy5nZW5lcmF0ZWRDYW52YXM7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5vcmlnaW5hbFN0eWxlID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCB0aGlzLmVsZW1lbnQuc3R5bGUpO1xuICAgICAgICB0aGlzLnNpemUuaGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodDtcbiAgICAgICAgdGhpcy5zaXplLndpZHRoID0gY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmVsZW1lbnQuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZXRpbmEuaW5pdCgpO1xuICAgICAgICB0aGlzLmluaXRCYWNrZ3JvdW5kKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdGVkQ2FudmFzKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICBVdGlsc18xLkNhbnZhc1V0aWxzLmNsZWFyKHRoaXMuY29udGV4dCwgdGhpcy5zaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LndpZHRoID0gdGhpcy5zaXplLndpZHRoO1xuICAgICAgICB0aGlzLmVsZW1lbnQuaGVpZ2h0ID0gdGhpcy5zaXplLmhlaWdodDtcbiAgICB9XG4gICAgcGFpbnQoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRNYXNrLmVuYWJsZSAmJiBvcHRpb25zLmJhY2tncm91bmRNYXNrLmNvdmVyICYmIHRoaXMuY292ZXJDb2xvcikge1xuICAgICAgICAgICAgVXRpbHNfMS5DYW52YXNVdGlscy5jbGVhcih0aGlzLmNvbnRleHQsIHRoaXMuc2l6ZSk7XG4gICAgICAgICAgICB0aGlzLnBhaW50QmFzZShVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKHRoaXMuY292ZXJDb2xvciwgdGhpcy5jb3ZlckNvbG9yLmEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnRCYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCB0cmFpbCA9IG9wdGlvbnMucGFydGljbGVzLm1vdmUudHJhaWw7XG4gICAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRNYXNrLmVuYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5wYWludCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyYWlsLmVuYWJsZSAmJiB0cmFpbC5sZW5ndGggPiAwICYmIHRoaXMudHJhaWxGaWxsQ29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnRCYXNlKFV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21SZ2IodGhpcy50cmFpbEZpbGxDb2xvciwgMSAvIHRyYWlsLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgVXRpbHNfMS5DYW52YXNVdGlscy5jbGVhcih0aGlzLmNvbnRleHQsIHRoaXMuc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2luZG93UmVzaXplKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb250YWluZXIuY2FudmFzLmluaXRTaXplKCk7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWNsZXMuc2V0RGVuc2l0eSgpO1xuICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgY29udGFpbmVyLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4ucmVzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4ucmVzaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdFNpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHB4UmF0aW8gPSBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgIGNvbnRhaW5lci5jYW52YXMuc2l6ZS53aWR0aCA9IHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aCAqIHB4UmF0aW87XG4gICAgICAgIGNvbnRhaW5lci5jYW52YXMuc2l6ZS5oZWlnaHQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0ICogcHhSYXRpbztcbiAgICAgICAgdGhpcy5lbGVtZW50LndpZHRoID0gY29udGFpbmVyLmNhbnZhcy5zaXplLndpZHRoO1xuICAgICAgICB0aGlzLmVsZW1lbnQuaGVpZ2h0ID0gY29udGFpbmVyLmNhbnZhcy5zaXplLmhlaWdodDtcbiAgICB9XG4gICAgZHJhd0Nvbm5lY3RMaW5lKHAxLCBwMikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGxpbmVTdHlsZSA9IHRoaXMubGluZVN0eWxlKHAxLCBwMik7XG4gICAgICAgIGlmICghbGluZVN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvczEgPSBwMS5nZXRQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBwb3MyID0gcDIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgVXRpbHNfMS5DYW52YXNVdGlscy5kcmF3Q29ubmVjdExpbmUoY3R4LCAoX2EgPSBwMS5saW5rc1dpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbnRhaW5lci5yZXRpbmEubGlua3NXaWR0aCwgbGluZVN0eWxlLCBwb3MxLCBwb3MyKTtcbiAgICB9XG4gICAgZHJhd0dyYWJMaW5lKHBhcnRpY2xlLCBsaW5lQ29sb3IsIG9wYWNpdHksIG1vdXNlUG9zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNvbnRhaW5lci5jYW52YXMuY29udGV4dDtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiZWdpblBvcyA9IHBhcnRpY2xlLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIFV0aWxzXzEuQ2FudmFzVXRpbHMuZHJhd0dyYWJMaW5lKGN0eCwgKF9hID0gcGFydGljbGUubGlua3NXaWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29udGFpbmVyLnJldGluYS5saW5rc1dpZHRoLCBiZWdpblBvcywgbW91c2VQb3MsIGxpbmVDb2xvciwgb3BhY2l0eSk7XG4gICAgfVxuICAgIGRyYXdQYXJ0aWNsZVNoYWRvdyhwYXJ0aWNsZSwgbW91c2VQb3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBVdGlsc18xLkNhbnZhc1V0aWxzLmRyYXdQYXJ0aWNsZVNoYWRvdyh0aGlzLmNvbnRhaW5lciwgdGhpcy5jb250ZXh0LCBwYXJ0aWNsZSwgbW91c2VQb3MpO1xuICAgIH1cbiAgICBkcmF3TGlua1RyaWFuZ2xlKHAxLCBsaW5rMSwgbGluazIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCBwMiA9IGxpbmsxLmRlc3RpbmF0aW9uO1xuICAgICAgICBjb25zdCBwMyA9IGxpbmsyLmRlc3RpbmF0aW9uO1xuICAgICAgICBjb25zdCB0cmlhbmdsZU9wdGlvbnMgPSBwMS5wYXJ0aWNsZXNPcHRpb25zLmxpbmtzLnRyaWFuZ2xlcztcbiAgICAgICAgY29uc3Qgb3BhY2l0eVRyaWFuZ2xlID0gKF9hID0gdHJpYW5nbGVPcHRpb25zLm9wYWNpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChsaW5rMS5vcGFjaXR5ICsgbGluazIub3BhY2l0eSkgLyAyO1xuICAgICAgICBpZiAob3BhY2l0eVRyaWFuZ2xlIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3MxID0gcDEuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgY29uc3QgcG9zMiA9IHAyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IHBvczMgPSBwMy5nZXRQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2UocG9zMSwgcG9zMikgPiBjb250YWluZXIucmV0aW5hLmxpbmtzRGlzdGFuY2UgfHxcbiAgICAgICAgICAgIFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2UocG9zMywgcG9zMikgPiBjb250YWluZXIucmV0aW5hLmxpbmtzRGlzdGFuY2UgfHxcbiAgICAgICAgICAgIFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2UocG9zMywgcG9zMSkgPiBjb250YWluZXIucmV0aW5hLmxpbmtzRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29sb3JUcmlhbmdsZSA9IFV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvUmdiKHRyaWFuZ2xlT3B0aW9ucy5jb2xvcik7XG4gICAgICAgIGlmICghY29sb3JUcmlhbmdsZSkge1xuICAgICAgICAgICAgY29uc3QgbGlua3NPcHRpb25zID0gcDEucGFydGljbGVzT3B0aW9ucy5saW5rcztcbiAgICAgICAgICAgIGNvbnN0IGxpbmtDb2xvciA9IGxpbmtzT3B0aW9ucy5pZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBjb250YWluZXIucGFydGljbGVzLmxpbmtzQ29sb3JzLmdldChsaW5rc09wdGlvbnMuaWQpXG4gICAgICAgICAgICAgICAgOiBjb250YWluZXIucGFydGljbGVzLmxpbmtzQ29sb3I7XG4gICAgICAgICAgICBjb2xvclRyaWFuZ2xlID0gVXRpbHNfMS5Db2xvclV0aWxzLmdldExpbmtDb2xvcihwMSwgcDIsIGxpbmtDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2xvclRyaWFuZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgVXRpbHNfMS5DYW52YXNVdGlscy5kcmF3TGlua1RyaWFuZ2xlKGN0eCwgcG9zMSwgcG9zMiwgcG9zMywgb3B0aW9ucy5iYWNrZ3JvdW5kTWFzay5lbmFibGUsIG9wdGlvbnMuYmFja2dyb3VuZE1hc2suY29tcG9zaXRlLCBjb2xvclRyaWFuZ2xlLCBvcGFjaXR5VHJpYW5nbGUpO1xuICAgIH1cbiAgICBkcmF3TGlua0xpbmUocDEsIGxpbmspIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIub3B0aW9ucztcbiAgICAgICAgY29uc3QgcDIgPSBsaW5rLmRlc3RpbmF0aW9uO1xuICAgICAgICBsZXQgb3BhY2l0eSA9IGxpbmsub3BhY2l0eTtcbiAgICAgICAgY29uc3QgcG9zMSA9IHAxLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IHBvczIgPSBwMi5nZXRQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbG9yTGluZTtcbiAgICAgICAgY29uc3QgdHdpbmtsZSA9IHAxLnBhcnRpY2xlc09wdGlvbnMudHdpbmtsZS5saW5lcztcbiAgICAgICAgaWYgKHR3aW5rbGUuZW5hYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB0d2lua2xlRnJlcSA9IHR3aW5rbGUuZnJlcXVlbmN5O1xuICAgICAgICAgICAgY29uc3QgdHdpbmtsZVJnYiA9IFV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvUmdiKHR3aW5rbGUuY29sb3IpO1xuICAgICAgICAgICAgY29uc3QgdHdpbmtsaW5nID0gTWF0aC5yYW5kb20oKSA8IHR3aW5rbGVGcmVxO1xuICAgICAgICAgICAgaWYgKHR3aW5rbGluZyAmJiB0d2lua2xlUmdiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb2xvckxpbmUgPSB0d2lua2xlUmdiO1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSB0d2lua2xlLm9wYWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2xvckxpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzT3B0aW9ucyA9IHAxLnBhcnRpY2xlc09wdGlvbnMubGlua3M7XG4gICAgICAgICAgICBjb25zdCBsaW5rQ29sb3IgPSBsaW5rc09wdGlvbnMuaWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gY29udGFpbmVyLnBhcnRpY2xlcy5saW5rc0NvbG9ycy5nZXQobGlua3NPcHRpb25zLmlkKVxuICAgICAgICAgICAgICAgIDogY29udGFpbmVyLnBhcnRpY2xlcy5saW5rc0NvbG9yO1xuICAgICAgICAgICAgY29sb3JMaW5lID0gVXRpbHNfMS5Db2xvclV0aWxzLmdldExpbmtDb2xvcihwMSwgcDIsIGxpbmtDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2xvckxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aWR0aCA9IChfYSA9IHAxLmxpbmtzV2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnRhaW5lci5yZXRpbmEubGlua3NXaWR0aDtcbiAgICAgICAgY29uc3QgbWF4RGlzdGFuY2UgPSAoX2IgPSBwMS5saW5rc0Rpc3RhbmNlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb250YWluZXIucmV0aW5hLmxpbmtzRGlzdGFuY2U7XG4gICAgICAgIFV0aWxzXzEuQ2FudmFzVXRpbHMuZHJhd0xpbmtMaW5lKGN0eCwgd2lkdGgsIHBvczEsIHBvczIsIG1heERpc3RhbmNlLCBjb250YWluZXIuY2FudmFzLnNpemUsIHAxLnBhcnRpY2xlc09wdGlvbnMubGlua3Mud2FycCwgb3B0aW9ucy5iYWNrZ3JvdW5kTWFzay5lbmFibGUsIG9wdGlvbnMuYmFja2dyb3VuZE1hc2suY29tcG9zaXRlLCBjb2xvckxpbmUsIG9wYWNpdHksIHAxLnBhcnRpY2xlc09wdGlvbnMubGlua3Muc2hhZG93KTtcbiAgICB9XG4gICAgZHJhd1BhcnRpY2xlKHBhcnRpY2xlLCBkZWx0YSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmICgoKF9hID0gcGFydGljbGUuaW1hZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2FkZWQpID09PSBmYWxzZSB8fCBwYXJ0aWNsZS5zcGF3bmluZyB8fCBwYXJ0aWNsZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwZkNvbG9yID0gcGFydGljbGUuZ2V0RmlsbENvbG9yKCk7XG4gICAgICAgIGNvbnN0IHBzQ29sb3IgPSAoX2IgPSBwYXJ0aWNsZS5nZXRTdHJva2VDb2xvcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBwZkNvbG9yO1xuICAgICAgICBpZiAoIXBmQ29sb3IgJiYgIXBzQ29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb250YWluZXIub3B0aW9ucztcbiAgICAgICAgY29uc3QgcE9wdGlvbnMgPSBwYXJ0aWNsZS5wYXJ0aWNsZXNPcHRpb25zO1xuICAgICAgICBjb25zdCB0d2lua2xlID0gcE9wdGlvbnMudHdpbmtsZS5wYXJ0aWNsZXM7XG4gICAgICAgIGNvbnN0IHR3aW5rbGVGcmVxID0gdHdpbmtsZS5mcmVxdWVuY3k7XG4gICAgICAgIGNvbnN0IHR3aW5rbGVSZ2IgPSBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb1JnYih0d2lua2xlLmNvbG9yKTtcbiAgICAgICAgY29uc3QgdHdpbmtsaW5nID0gdHdpbmtsZS5lbmFibGUgJiYgTWF0aC5yYW5kb20oKSA8IHR3aW5rbGVGcmVxO1xuICAgICAgICBjb25zdCByYWRpdXMgPSBwYXJ0aWNsZS5nZXRSYWRpdXMoKTtcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHR3aW5rbGluZyA/IHR3aW5rbGUub3BhY2l0eSA6IChfYyA9IHBhcnRpY2xlLmJ1YmJsZS5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBwYXJ0aWNsZS5vcGFjaXR5LnZhbHVlO1xuICAgICAgICBjb25zdCBpbmZlY3Rpb25TdGFnZSA9IHBhcnRpY2xlLmluZmVjdGVyLmluZmVjdGlvblN0YWdlO1xuICAgICAgICBjb25zdCBpbmZlY3Rpb24gPSBvcHRpb25zLmluZmVjdGlvbjtcbiAgICAgICAgY29uc3QgaW5mZWN0aW9uU3RhZ2VzID0gaW5mZWN0aW9uLnN0YWdlcztcbiAgICAgICAgY29uc3QgaW5mZWN0aW9uQ29sb3IgPSBpbmZlY3Rpb25TdGFnZSAhPT0gdW5kZWZpbmVkID8gaW5mZWN0aW9uU3RhZ2VzW2luZmVjdGlvblN0YWdlXS5jb2xvciA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaW5mZWN0aW9uUmdiID0gVXRpbHNfMS5Db2xvclV0aWxzLmNvbG9yVG9SZ2IoaW5mZWN0aW9uQ29sb3IpO1xuICAgICAgICBjb25zdCBmQ29sb3IgPSB0d2lua2xpbmcgJiYgdHdpbmtsZVJnYiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHR3aW5rbGVSZ2JcbiAgICAgICAgICAgIDogaW5mZWN0aW9uUmdiICE9PSBudWxsICYmIGluZmVjdGlvblJnYiAhPT0gdm9pZCAwID8gaW5mZWN0aW9uUmdiIDogKHBmQ29sb3IgPyBVdGlsc18xLkNvbG9yVXRpbHMuaHNsVG9SZ2IocGZDb2xvcikgOiB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBzQ29sb3IgPSB0d2lua2xpbmcgJiYgdHdpbmtsZVJnYiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHR3aW5rbGVSZ2JcbiAgICAgICAgICAgIDogaW5mZWN0aW9uUmdiICE9PSBudWxsICYmIGluZmVjdGlvblJnYiAhPT0gdm9pZCAwID8gaW5mZWN0aW9uUmdiIDogKHBzQ29sb3IgPyBVdGlsc18xLkNvbG9yVXRpbHMuaHNsVG9SZ2IocHNDb2xvcikgOiB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBmaWxsQ29sb3JWYWx1ZSA9IGZDb2xvciAhPT0gdW5kZWZpbmVkID8gVXRpbHNfMS5Db2xvclV0aWxzLmdldFN0eWxlRnJvbVJnYihmQ29sb3IsIG9wYWNpdHkpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCB8fCAoIWZpbGxDb2xvclZhbHVlICYmICFzQ29sb3IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3Ryb2tlQ29sb3JWYWx1ZSA9IHNDb2xvciAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IFV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21SZ2Ioc0NvbG9yLCAoX2QgPSBwYXJ0aWNsZS5zdHJva2Uub3BhY2l0eSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogb3BhY2l0eSlcbiAgICAgICAgICAgIDogZmlsbENvbG9yVmFsdWU7XG4gICAgICAgIHRoaXMuZHJhd1BhcnRpY2xlTGlua3MocGFydGljbGUpO1xuICAgICAgICBpZiAocmFkaXVzID4gMCkge1xuICAgICAgICAgICAgVXRpbHNfMS5DYW52YXNVdGlscy5kcmF3UGFydGljbGUodGhpcy5jb250YWluZXIsIHRoaXMuY29udGV4dCwgcGFydGljbGUsIGRlbHRhLCBmaWxsQ29sb3JWYWx1ZSwgc3Ryb2tlQ29sb3JWYWx1ZSwgb3B0aW9ucy5iYWNrZ3JvdW5kTWFzay5lbmFibGUsIG9wdGlvbnMuYmFja2dyb3VuZE1hc2suY29tcG9zaXRlLCByYWRpdXMsIG9wYWNpdHksIHBhcnRpY2xlLnBhcnRpY2xlc09wdGlvbnMuc2hhZG93KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3UGFydGljbGVMaW5rcyhwYXJ0aWNsZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZXMgPSBjb250YWluZXIucGFydGljbGVzO1xuICAgICAgICBjb25zdCBwT3B0aW9ucyA9IHBhcnRpY2xlLnBhcnRpY2xlc09wdGlvbnM7XG4gICAgICAgIGlmIChwYXJ0aWNsZS5saW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgY29uc3QgcDFMaW5rcyA9IHBhcnRpY2xlLmxpbmtzLmZpbHRlcigobCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtGcmVxID0gY29udGFpbmVyLnBhcnRpY2xlcy5nZXRMaW5rRnJlcXVlbmN5KHBhcnRpY2xlLCBsLmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlua0ZyZXEgPD0gcE9wdGlvbnMubGlua3MuZnJlcXVlbmN5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmsgb2YgcDFMaW5rcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAyID0gbGluay5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAocE9wdGlvbnMubGlua3MudHJpYW5nbGVzLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rcyA9IHAxTGlua3MubWFwKChsKSA9PiBsLmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVydGljZXMgPSBwMi5saW5rcy5maWx0ZXIoKHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtGcmVxID0gY29udGFpbmVyLnBhcnRpY2xlcy5nZXRMaW5rRnJlcXVlbmN5KHAyLCB0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5rRnJlcSA8PSBwMi5wYXJ0aWNsZXNPcHRpb25zLmxpbmtzLmZyZXF1ZW5jeSAmJiBsaW5rcy5pbmRleE9mKHQuZGVzdGluYXRpb24pID49IDA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZlcnRleCBvZiB2ZXJ0aWNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAzID0gdmVydGV4LmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlRnJlcSA9IHBhcnRpY2xlcy5nZXRUcmlhbmdsZUZyZXF1ZW5jeShwYXJ0aWNsZSwgcDIsIHAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJpYW5nbGVGcmVxID4gcE9wdGlvbnMubGlua3MudHJpYW5nbGVzLmZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3TGlua1RyaWFuZ2xlKHBhcnRpY2xlLCBsaW5rLCB2ZXJ0ZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsaW5rLm9wYWNpdHkgPiAwICYmIGNvbnRhaW5lci5yZXRpbmEubGlua3NXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3TGlua0xpbmUocGFydGljbGUsIGxpbmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhd1BsdWdpbihwbHVnaW4sIGRlbHRhKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgVXRpbHNfMS5DYW52YXNVdGlscy5kcmF3UGx1Z2luKHRoaXMuY29udGV4dCwgcGx1Z2luLCBkZWx0YSk7XG4gICAgfVxuICAgIGRyYXdMaWdodChtb3VzZVBvcykge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFV0aWxzXzEuQ2FudmFzVXRpbHMuZHJhd0xpZ2h0KHRoaXMuY29udGFpbmVyLCB0aGlzLmNvbnRleHQsIG1vdXNlUG9zKTtcbiAgICB9XG4gICAgcGFpbnRCYXNlKGJhc2VDb2xvcikge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFV0aWxzXzEuQ2FudmFzVXRpbHMucGFpbnRCYXNlKHRoaXMuY29udGV4dCwgdGhpcy5zaXplLCBiYXNlQ29sb3IpO1xuICAgIH1cbiAgICBsaW5lU3R5bGUocDEsIHAyKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCBjb25uZWN0T3B0aW9ucyA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5jb25uZWN0O1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHNfMS5DYW52YXNVdGlscy5ncmFkaWVudCh0aGlzLmNvbnRleHQsIHAxLCBwMiwgY29ubmVjdE9wdGlvbnMubGlua3Mub3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdEJhY2tncm91bmQoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gb3B0aW9ucy5iYWNrZ3JvdW5kO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50U3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgICBpZiAoYmFja2dyb3VuZC5jb2xvcikge1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb1JnYihiYWNrZ3JvdW5kLmNvbG9yKTtcbiAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKGNvbG9yLCBiYWNrZ3JvdW5kLm9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kLmltYWdlKSB7XG4gICAgICAgICAgICBlbGVtZW50U3R5bGUuYmFja2dyb3VuZEltYWdlID0gYmFja2dyb3VuZC5pbWFnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFja2dyb3VuZC5wb3NpdGlvbikge1xuICAgICAgICAgICAgZWxlbWVudFN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9IGJhY2tncm91bmQucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhY2tncm91bmQucmVwZWF0KSB7XG4gICAgICAgICAgICBlbGVtZW50U3R5bGUuYmFja2dyb3VuZFJlcGVhdCA9IGJhY2tncm91bmQucmVwZWF0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kLnNpemUpIHtcbiAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGJhY2tncm91bmQuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2FudmFzID0gQ2FudmFzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udGFpbmVyID0gdm9pZCAwO1xuY29uc3QgQ2FudmFzXzEgPSByZXF1aXJlKFwiLi9DYW52YXNcIik7XG5jb25zdCBQYXJ0aWNsZXNfMSA9IHJlcXVpcmUoXCIuL1BhcnRpY2xlc1wiKTtcbmNvbnN0IFJldGluYV8xID0gcmVxdWlyZShcIi4vUmV0aW5hXCIpO1xuY29uc3QgRnJhbWVNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9GcmFtZU1hbmFnZXJcIik7XG5jb25zdCBPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vT3B0aW9ucy9DbGFzc2VzL09wdGlvbnNcIik7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpO1xuY2xhc3MgQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgc291cmNlT3B0aW9ucywgLi4ucHJlc2V0cykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuc291cmNlT3B0aW9ucyA9IHNvdXJjZU9wdGlvbnM7XG4gICAgICAgIHRoaXMuZmlyc3RTdGFydCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IDA7XG4gICAgICAgIHRoaXMucGFnZUhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJldGluYSA9IG5ldyBSZXRpbmFfMS5SZXRpbmEodGhpcyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbmV3IENhbnZhc18xLkNhbnZhcyh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBuZXcgUGFydGljbGVzXzEuUGFydGljbGVzKHRoaXMpO1xuICAgICAgICB0aGlzLmRyYXdlciA9IG5ldyBGcmFtZU1hbmFnZXJfMS5GcmFtZU1hbmFnZXIodGhpcyk7XG4gICAgICAgIHRoaXMubm9pc2UgPSB7XG4gICAgICAgICAgICBnZW5lcmF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlOiBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluaXQ6ICgpID0+IHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpdml0eSA9IHtcbiAgICAgICAgICAgIG1vdXNlOiB7XG4gICAgICAgICAgICAgICAgY2xpY2tpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGluc2lkZTogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJ1YmJsZSA9IHt9O1xuICAgICAgICB0aGlzLnJlcHVsc2UgPSB7IHBhcnRpY2xlczogW10gfTtcbiAgICAgICAgdGhpcy5hdHRyYWN0ID0geyBwYXJ0aWNsZXM6IFtdIH07XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kcmF3ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmRlbnNpdHkgPSAxO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBuZXcgT3B0aW9uc18xLk9wdGlvbnMoKTtcbiAgICAgICAgZm9yIChjb25zdCBwcmVzZXQgb2YgcHJlc2V0cykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxvYWQoVXRpbHNfMS5QbHVnaW5zLmdldFByZXNldChwcmVzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaGFwZXMgPSBVdGlsc18xLlBsdWdpbnMuZ2V0U3VwcG9ydGVkU2hhcGVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBzaGFwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRyYXdlciA9IFV0aWxzXzEuUGx1Z2lucy5nZXRTaGFwZURyYXdlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChkcmF3ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdlcnMuc2V0KHR5cGUsIGRyYXdlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc291cmNlT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxvYWQodGhpcy5zb3VyY2VPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZwc0xpbWl0ID0gdGhpcy5vcHRpb25zLmZwc0xpbWl0ID4gMCA/IHRoaXMub3B0aW9ucy5mcHNMaW1pdCA6IDYwO1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2V0VGhlbWUodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IG5ldyBVdGlsc18xLkV2ZW50TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiICYmIEludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB0aGlzLmludGVyc2VjdGlvbk1hbmFnZXIoZW50cmllcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBsYXkoZm9yY2UpIHtcbiAgICAgICAgY29uc3QgbmVlZHNVcGRhdGUgPSB0aGlzLnBhdXNlZCB8fCBmb3JjZTtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RTdGFydCAmJiAhdGhpcy5vcHRpb25zLmF1dG9QbGF5KSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0U3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5wbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5wbGF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICBpZiAodGhpcy5kcmF3QW5pbWF0aW9uRnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgVXRpbHNfMS5VdGlscy5jYW5jZWxBbmltYXRpb24odGhpcy5kcmF3QW5pbWF0aW9uRnJhbWUpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZHJhd0FuaW1hdGlvbkZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgWywgcGx1Z2luXSBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4ucGF1c2UpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4ucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucGFnZUhpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgIHRoaXMuZHJhd0FuaW1hdGlvbkZyYW1lID0gVXRpbHNfMS5VdGlscy5hbmltYXRlKCh0aW1lc3RhbXApID0+IHRoaXMuZHJhd2VyLm5leHRGcmFtZSh0aW1lc3RhbXApKTtcbiAgICB9XG4gICAgZ2V0QW5pbWF0aW9uU3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucGF1c2VkO1xuICAgIH1cbiAgICBzZXROb2lzZShub2lzZU9yR2VuZXJhdG9yLCBpbml0LCB1cGRhdGUpIHtcbiAgICAgICAgaWYgKCFub2lzZU9yR2VuZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBub2lzZU9yR2VuZXJhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMubm9pc2UuZ2VuZXJhdGUgPSBub2lzZU9yR2VuZXJhdG9yO1xuICAgICAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vaXNlLmluaXQgPSBpbml0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9pc2UudXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vaXNlT3JHZW5lcmF0b3IuZ2VuZXJhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vaXNlLmdlbmVyYXRlID0gbm9pc2VPckdlbmVyYXRvci5nZW5lcmF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2lzZU9yR2VuZXJhdG9yLmluaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vaXNlLmluaXQgPSBub2lzZU9yR2VuZXJhdG9yLmluaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9pc2VPckdlbmVyYXRvci51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vaXNlLnVwZGF0ZSA9IG5vaXNlT3JHZW5lcmF0b3IudXBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLmNhbnZhcy5kZXN0cm95KCk7XG4gICAgICAgIGZvciAoY29uc3QgWywgZHJhd2VyXSBvZiB0aGlzLmRyYXdlcnMpIHtcbiAgICAgICAgICAgIGlmIChkcmF3ZXIuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIGRyYXdlci5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuZHJhd2Vycy5rZXlzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd2Vycy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIGV4cG9ydEltZyhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmV4cG9ydEltYWdlKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZXhwb3J0SW1hZ2UoY2FsbGJhY2ssIHR5cGUsIHF1YWxpdHkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jYW52YXMuZWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvQmxvYihjYWxsYmFjaywgdHlwZSAhPT0gbnVsbCAmJiB0eXBlICE9PSB2b2lkIDAgPyB0eXBlIDogXCJpbWFnZS9wbmdcIiwgcXVhbGl0eSk7XG4gICAgfVxuICAgIGV4cG9ydENvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMsIHVuZGVmaW5lZCwgMik7XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maXJzdFN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jYW52YXMuY2xlYXIoKTtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3Rpdml0eS5lbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuaW50ZXJhY3Rpdml0eS5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLnN0b3ApIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMucGx1Z2lucy5rZXlzKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRpY2xlcy5saW5rc0NvbG9ycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMucGFydGljbGVzLmdyYWJMaW5lQ29sb3I7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhcnRpY2xlcy5saW5rc0NvbG9yO1xuICAgIH1cbiAgICBsb2FkVGhlbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNldFRoZW1lKG5hbWUpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmFkZExpc3RlbmVycygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3Rpdml0eS5lbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmludGVyYWN0aXZpdHkuZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zdGFydEFzeW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgcGx1Z2luLnN0YXJ0QXN5bmMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGx1Z2luLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5yZXRpbmEuaW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5mcHNMaW1pdCA9IHRoaXMub3B0aW9ucy5mcHNMaW1pdCA+IDAgPyB0aGlzLm9wdGlvbnMuZnBzTGltaXQgOiA2MDtcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZVBsdWdpbnMgPSBVdGlsc18xLlBsdWdpbnMuZ2V0QXZhaWxhYmxlUGx1Z2lucyh0aGlzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkLCBwbHVnaW5dIG9mIGF2YWlsYWJsZVBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbnMuc2V0KGlkLCBwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBbLCBkcmF3ZXJdIG9mIHRoaXMuZHJhd2Vycykge1xuICAgICAgICAgICAgICAgIGlmIChkcmF3ZXIuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBkcmF3ZXIuaW5pdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5pbml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5pbml0KHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBsdWdpbi5pbml0QXN5bmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBwbHVnaW4uaW5pdEFzeW5jKHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYW52YXMuaW5pdFNpemUoKTtcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzLnNldERlbnNpdHkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludGVyc2VjdGlvbk1hbmFnZXIoZW50cmllcykge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wYXVzZU9uT3V0c2lkZVZpZXdwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkudGFyZ2V0ICE9PSB0aGlzLmludGVyYWN0aXZpdHkuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNvbnRhaW5lciA9IENvbnRhaW5lcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GcmFtZU1hbmFnZXIgPSB2b2lkIDA7XG5jbGFzcyBGcmFtZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgbmV4dEZyYW1lKHRpbWVzdGFtcCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLmxhc3RGcmFtZVRpbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA8IGNvbnRhaW5lci5sYXN0RnJhbWVUaW1lICsgMTAwMCAvIGNvbnRhaW5lci5mcHNMaW1pdCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5kcmF3KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsdGFWYWx1ZSA9IHRpbWVzdGFtcCAtIGNvbnRhaW5lci5sYXN0RnJhbWVUaW1lO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlbHRhVmFsdWUsXG4gICAgICAgICAgICAgICAgZmFjdG9yOiAoNjAgKiBkZWx0YVZhbHVlKSAvIDEwMDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGFpbmVyLmxhc3RGcmFtZVRpbWUgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICBjb250YWluZXIucGFydGljbGVzLmRyYXcoZGVsdGEpO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5nZXRBbmltYXRpb25TdGF0dXMoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5kcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJ0c1BhcnRpY2xlcyBlcnJvciBpbiBhbmltYXRpb24gbG9vcFwiLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRnJhbWVNYW5hZ2VyID0gRnJhbWVNYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9hZGVyID0gdm9pZCAwO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpO1xuY29uc3QgdHNQYXJ0aWNsZXNEb20gPSBbXTtcbmZ1bmN0aW9uIGZldGNoRXJyb3Ioc3RhdHVzQ29kZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHRzUGFydGljbGVzIC0gZmV0Y2ggc3RhdHVzOiAke3N0YXR1c0NvZGV9YCk7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHRzUGFydGljbGVzIC0gRmlsZSBjb25maWcgbm90IGZvdW5kXCIpO1xufVxuY2xhc3MgTG9hZGVyIHtcbiAgICBzdGF0aWMgZG9tKCkge1xuICAgICAgICByZXR1cm4gdHNQYXJ0aWNsZXNEb207XG4gICAgfVxuICAgIHN0YXRpYyBkb21JdGVtKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGRvbSA9IExvYWRlci5kb20oKTtcbiAgICAgICAgY29uc3QgaXRlbSA9IGRvbVtpbmRleF07XG4gICAgICAgIGlmIChpdGVtICYmICFpdGVtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZG9tLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHN0YXRpYyBsb2FkKHRhZ0lkLCBvcHRpb25zLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZG9tQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFnSWQpO1xuICAgICAgICAgICAgaWYgKCFkb21Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTG9hZGVyLnNldCh0YWdJZCwgZG9tQ29udGFpbmVyLCBvcHRpb25zLCBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0KGlkLCBkb21Db250YWluZXIsIG9wdGlvbnMsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50T3B0aW9ucyA9IG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSA/IFV0aWxzXzEuVXRpbHMuaXRlbUZyb21BcnJheShvcHRpb25zLCBpbmRleCkgOiBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgZG9tID0gTG9hZGVyLmRvbSgpO1xuICAgICAgICAgICAgY29uc3Qgb2xkSW5kZXggPSBkb20uZmluZEluZGV4KCh2KSA9PiB2LmlkID09PSBpZCk7XG4gICAgICAgICAgICBpZiAob2xkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZCA9IExvYWRlci5kb21JdGVtKG9sZEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAob2xkICYmICFvbGQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zcGxpY2Uob2xkSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjYW52YXNFbDtcbiAgICAgICAgICAgIGxldCBnZW5lcmF0ZWRDYW52YXM7XG4gICAgICAgICAgICBpZiAoZG9tQ29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJjYW52YXNcIikge1xuICAgICAgICAgICAgICAgIGNhbnZhc0VsID0gZG9tQ29udGFpbmVyO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZENhbnZhcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdDYW52YXNlcyA9IGRvbUNvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNhbnZhc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdDYW52YXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzRWwgPSBleGlzdGluZ0NhbnZhc2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbnZhc0VsLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzRWwuY2xhc3NOYW1lID0gVXRpbHNfMS5Db25zdGFudHMuY2FudmFzQ2xhc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkQ2FudmFzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRDYW52YXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0VsLmNsYXNzTmFtZSA9IFV0aWxzXzEuQ29uc3RhbnRzLmNhbnZhc0NsYXNzO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNFbC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNFbC5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgICAgICAgICAgICAgICAgZG9tQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhc0VsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcihpZCwgY3VycmVudE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9sZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBkb20uc3BsaWNlKG9sZEluZGV4LCAwLCBuZXdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbS5wdXNoKG5ld0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3SXRlbS5jYW52YXMubG9hZENhbnZhcyhjYW52YXNFbCwgZ2VuZXJhdGVkQ2FudmFzKTtcbiAgICAgICAgICAgIHlpZWxkIG5ld0l0ZW0uc3RhcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdJdGVtO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGxvYWRKU09OKHRhZ0lkLCBqc29uVXJsLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0ganNvblVybCBpbnN0YW5jZW9mIEFycmF5ID8gVXRpbHNfMS5VdGlscy5pdGVtRnJvbUFycmF5KGpzb25VcmwsIGluZGV4KSA6IGpzb25Vcmw7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKHVybCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9hZGVyLmxvYWQodGFnSWQsIHlpZWxkIHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmZXRjaEVycm9yKHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0SlNPTihpZCwgZG9tQ29udGFpbmVyLCBqc29uVXJsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKGpzb25VcmwpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9hZGVyLnNldChpZCwgZG9tQ29udGFpbmVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZldGNoRXJyb3IocmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRPbkNsaWNrSGFuZGxlcihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBkb20gPSBMb2FkZXIuZG9tKCk7XG4gICAgICAgIGlmIChkb20ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gb25seSBzZXQgY2xpY2sgaGFuZGxlcnMgYWZ0ZXIgY2FsbGluZyB0c1BhcnRpY2xlcy5sb2FkKCkgb3IgdHNQYXJ0aWNsZXMubG9hZEpTT04oKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGRvbUl0ZW0gb2YgZG9tKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IGRvbUl0ZW0uaW50ZXJhY3Rpdml0eS5lbGVtZW50O1xuICAgICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xpY2tPclRvdWNoSGFuZGxlciA9IChlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tSXRlbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBweFJhdGlvID0gZG9tSXRlbS5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NSZXRpbmEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHBvcy54ICogcHhSYXRpbyxcbiAgICAgICAgICAgICAgICAgICAgeTogcG9zLnkgKiBweFJhdGlvLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydGljbGVzID0gZG9tSXRlbS5wYXJ0aWNsZXMucXVhZFRyZWUucXVlcnlDaXJjbGUocG9zUmV0aW5hLCBkb21JdGVtLnJldGluYS5zaXplVmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIHBhcnRpY2xlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2xpY2tIYW5kbGVyID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tSXRlbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZUV2ZW50ID0gZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IG1vdXNlRXZlbnQub2Zmc2V0WCB8fCBtb3VzZUV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IG1vdXNlRXZlbnQub2Zmc2V0WSB8fCBtb3VzZUV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjbGlja09yVG91Y2hIYW5kbGVyKGUsIHBvcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdG91Y2hTdGFydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUl0ZW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG91Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdG91Y2hNb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoTW92ZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUl0ZW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdG91Y2hFbmRIYW5kbGVyID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBpZiAoZG9tSXRlbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG91Y2hlZCAmJiAhdG91Y2hNb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3VjaEV2ZW50ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFRvdWNoID0gdG91Y2hFdmVudC50b3VjaGVzW3RvdWNoRXZlbnQudG91Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FudmFzUmVjdCA9IChfYSA9IGRvbUl0ZW0uY2FudmFzLmVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogbGFzdFRvdWNoLmNsaWVudFggLSAoKF9iID0gY2FudmFzUmVjdCA9PT0gbnVsbCB8fCBjYW52YXNSZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYW52YXNSZWN0LmxlZnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogbGFzdFRvdWNoLmNsaWVudFkgLSAoKF9jID0gY2FudmFzUmVjdCA9PT0gbnVsbCB8fCBjYW52YXNSZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYW52YXNSZWN0LnRvcCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrT3JUb3VjaEhhbmRsZXIoZSwgcG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0b3VjaENhbmNlbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUl0ZW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgdG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjbGlja0hhbmRsZXIpO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdG91Y2hTdGFydEhhbmRsZXIpO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0b3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0b3VjaEVuZEhhbmRsZXIpO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIHRvdWNoQ2FuY2VsSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxvYWRlciA9IExvYWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJ0aWNsZSA9IHZvaWQgMDtcbmNvbnN0IFVwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL1BhcnRpY2xlL1VwZGF0ZXJcIik7XG5jb25zdCBQYXJ0aWNsZXNfMSA9IHJlcXVpcmUoXCIuLi9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL1BhcnRpY2xlc1wiKTtcbmNvbnN0IFNoYXBlXzEgPSByZXF1aXJlKFwiLi4vT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9TaGFwZS9TaGFwZVwiKTtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vRW51bXNcIik7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpO1xuY29uc3QgSW5mZWN0ZXJfMSA9IHJlcXVpcmUoXCIuL1BhcnRpY2xlL0luZmVjdGVyXCIpO1xuY29uc3QgTW92ZXJfMSA9IHJlcXVpcmUoXCIuL1BhcnRpY2xlL01vdmVyXCIpO1xuY2xhc3MgUGFydGljbGUge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBjb250YWluZXIsIHBvc2l0aW9uLCBvdmVycmlkZU9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMubGlua3MgPSBbXTtcbiAgICAgICAgdGhpcy5maWxsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbG9zZSA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdE5vaXNlVGltZSA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWlzcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHB4UmF0aW8gPSBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIub3B0aW9ucztcbiAgICAgICAgY29uc3QgcGFydGljbGVzT3B0aW9ucyA9IG5ldyBQYXJ0aWNsZXNfMS5QYXJ0aWNsZXMoKTtcbiAgICAgICAgcGFydGljbGVzT3B0aW9ucy5sb2FkKG9wdGlvbnMucGFydGljbGVzKTtcbiAgICAgICAgY29uc3Qgc2hhcGVUeXBlID0gcGFydGljbGVzT3B0aW9ucy5zaGFwZS50eXBlO1xuICAgICAgICBjb25zdCByZWR1Y2VEdXBsaWNhdGVzID0gcGFydGljbGVzT3B0aW9ucy5yZWR1Y2VEdXBsaWNhdGVzO1xuICAgICAgICB0aGlzLnNoYXBlID0gc2hhcGVUeXBlIGluc3RhbmNlb2YgQXJyYXkgPyBVdGlsc18xLlV0aWxzLml0ZW1Gcm9tQXJyYXkoc2hhcGVUeXBlLCB0aGlzLmlkLCByZWR1Y2VEdXBsaWNhdGVzKSA6IHNoYXBlVHlwZTtcbiAgICAgICAgaWYgKG92ZXJyaWRlT3B0aW9ucyA9PT0gbnVsbCB8fCBvdmVycmlkZU9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG92ZXJyaWRlT3B0aW9ucy5zaGFwZSkge1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlT3B0aW9ucy5zaGFwZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGVTaGFwZVR5cGUgPSBvdmVycmlkZU9wdGlvbnMuc2hhcGUudHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlID1cbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVTaGFwZVR5cGUgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBVdGlsc18xLlV0aWxzLml0ZW1Gcm9tQXJyYXkob3ZlcnJpZGVTaGFwZVR5cGUsIHRoaXMuaWQsIHJlZHVjZUR1cGxpY2F0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG92ZXJyaWRlU2hhcGVUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2hhcGVPcHRpb25zID0gbmV3IFNoYXBlXzEuU2hhcGUoKTtcbiAgICAgICAgICAgIHNoYXBlT3B0aW9ucy5sb2FkKG92ZXJyaWRlT3B0aW9ucy5zaGFwZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zaGFwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYXBlRGF0YSA9IHNoYXBlT3B0aW9ucy5vcHRpb25zW3RoaXMuc2hhcGVdO1xuICAgICAgICAgICAgICAgIGlmIChzaGFwZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFwZURhdGEgPSBVdGlsc18xLlV0aWxzLmRlZXBFeHRlbmQoe30sIHNoYXBlRGF0YSBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICA/IFV0aWxzXzEuVXRpbHMuaXRlbUZyb21BcnJheShzaGFwZURhdGEsIHRoaXMuaWQsIHJlZHVjZUR1cGxpY2F0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNoYXBlRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2hhcGVEYXRhID0gcGFydGljbGVzT3B0aW9ucy5zaGFwZS5vcHRpb25zW3RoaXMuc2hhcGVdO1xuICAgICAgICAgICAgaWYgKHNoYXBlRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcGVEYXRhID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCBzaGFwZURhdGEgaW5zdGFuY2VvZiBBcnJheSA/IFV0aWxzXzEuVXRpbHMuaXRlbUZyb21BcnJheShzaGFwZURhdGEsIHRoaXMuaWQsIHJlZHVjZUR1cGxpY2F0ZXMpIDogc2hhcGVEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnJpZGVPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlc09wdGlvbnMubG9hZChvdmVycmlkZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5zaGFwZURhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJ0aWNsZXMpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlc09wdGlvbnMubG9hZCgoX2IgPSB0aGlzLnNoYXBlRGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcnRpY2xlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWxsID0gKF9kID0gKF9jID0gdGhpcy5zaGFwZURhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5maWxsKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLmZpbGw7XG4gICAgICAgIHRoaXMuY2xvc2UgPSAoX2YgPSAoX2UgPSB0aGlzLnNoYXBlRGF0YSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNsb3NlKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0aGlzLmNsb3NlO1xuICAgICAgICB0aGlzLnBhcnRpY2xlc09wdGlvbnMgPSBwYXJ0aWNsZXNPcHRpb25zO1xuICAgICAgICB0aGlzLm5vaXNlRGVsYXkgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldFZhbHVlKHRoaXMucGFydGljbGVzT3B0aW9ucy5tb3ZlLm5vaXNlLmRlbGF5KSAqIDEwMDA7XG4gICAgICAgIGNvbnRhaW5lci5yZXRpbmEuaW5pdFBhcnRpY2xlKHRoaXMpO1xuICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMucGFydGljbGVzT3B0aW9ucy5jb2xvcjtcbiAgICAgICAgY29uc3Qgc2l6ZU9wdGlvbnMgPSB0aGlzLnBhcnRpY2xlc09wdGlvbnMuc2l6ZTtcbiAgICAgICAgY29uc3Qgc2l6ZVZhbHVlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRWYWx1ZShzaXplT3B0aW9ucykgKiBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgIGNvbnN0IHJhbmRvbVNpemUgPSB0eXBlb2Ygc2l6ZU9wdGlvbnMucmFuZG9tID09PSBcImJvb2xlYW5cIiA/IHNpemVPcHRpb25zLnJhbmRvbSA6IHNpemVPcHRpb25zLnJhbmRvbS5lbmFibGU7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBzaXplVmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5wYXJ0aWNsZXNPcHRpb25zLm1vdmUuZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLmJ1YmJsZSA9IHtcbiAgICAgICAgICAgIGluUmFuZ2U6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRpYWxWZWxvY2l0eSA9IHRoaXMuY2FsY3VsYXRlVmVsb2NpdHkoKTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHtcbiAgICAgICAgICAgIGhvcml6b250YWw6IHRoaXMuaW5pdGlhbFZlbG9jaXR5Lmhvcml6b250YWwsXG4gICAgICAgICAgICB2ZXJ0aWNhbDogdGhpcy5pbml0aWFsVmVsb2NpdHkudmVydGljYWwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGF0aEFuZ2xlID0gTWF0aC5hdGFuMih0aGlzLmluaXRpYWxWZWxvY2l0eS52ZXJ0aWNhbCwgdGhpcy5pbml0aWFsVmVsb2NpdHkuaG9yaXpvbnRhbCk7XG4gICAgICAgIGNvbnN0IHJvdGF0ZU9wdGlvbnMgPSB0aGlzLnBhcnRpY2xlc09wdGlvbnMucm90YXRlO1xuICAgICAgICB0aGlzLnJvdGF0ZSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiAoKHJvdGF0ZU9wdGlvbnMucmFuZG9tLmVuYWJsZSA/IE1hdGgucmFuZG9tKCkgKiAzNjAgOiByb3RhdGVPcHRpb25zLnZhbHVlKSAqIE1hdGguUEkpIC8gMTgwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcm90YXRlRGlyZWN0aW9uID0gcm90YXRlT3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIGlmIChyb3RhdGVEaXJlY3Rpb24gPT09IEVudW1zXzEuUm90YXRlRGlyZWN0aW9uLnJhbmRvbSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyKTtcbiAgICAgICAgICAgIHJvdGF0ZURpcmVjdGlvbiA9IGluZGV4ID4gMCA/IEVudW1zXzEuUm90YXRlRGlyZWN0aW9uLmNvdW50ZXJDbG9ja3dpc2UgOiBFbnVtc18xLlJvdGF0ZURpcmVjdGlvbi5jbG9ja3dpc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChyb3RhdGVEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgRW51bXNfMS5Sb3RhdGVEaXJlY3Rpb24uY291bnRlckNsb2Nrd2lzZTpcbiAgICAgICAgICAgIGNhc2UgXCJjb3VudGVyQ2xvY2t3aXNlXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGUuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRW51bXNfMS5Sb3RhdGVEaXJlY3Rpb24uY2xvY2t3aXNlOlxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlLnN0YXR1cyA9IEVudW1zXzEuQW5pbWF0aW9uU3RhdHVzLmluY3JlYXNpbmc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm90YXRlQW5pbWF0aW9uID0gdGhpcy5wYXJ0aWNsZXNPcHRpb25zLnJvdGF0ZS5hbmltYXRpb247XG4gICAgICAgIGlmIChyb3RhdGVBbmltYXRpb24uZW5hYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZS52ZWxvY2l0eSA9IChyb3RhdGVBbmltYXRpb24uc3BlZWQgLyAzNjApICogY29udGFpbmVyLnJldGluYS5yZWR1Y2VGYWN0b3I7XG4gICAgICAgICAgICBpZiAoIXJvdGF0ZUFuaW1hdGlvbi5zeW5jKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGUudmVsb2NpdHkgKj0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplQW5pbWF0aW9uID0gdGhpcy5wYXJ0aWNsZXNPcHRpb25zLnNpemUuYW5pbWF0aW9uO1xuICAgICAgICBpZiAoc2l6ZUFuaW1hdGlvbi5lbmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZS5zdGF0dXMgPSBFbnVtc18xLkFuaW1hdGlvblN0YXR1cy5pbmNyZWFzaW5nO1xuICAgICAgICAgICAgaWYgKCFyYW5kb21TaXplKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzaXplQW5pbWF0aW9uLnN0YXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtc18xLlN0YXJ0VmFsdWVUeXBlLm1pbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZS52YWx1ZSA9IHNpemVBbmltYXRpb24ubWluaW11bVZhbHVlICogcHhSYXRpbztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuU3RhcnRWYWx1ZVR5cGUucmFuZG9tOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplLnZhbHVlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5yYW5kb21JblJhbmdlKHNpemVBbmltYXRpb24ubWluaW11bVZhbHVlICogcHhSYXRpbywgdGhpcy5zaXplLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuU3RhcnRWYWx1ZVR5cGUubWF4OlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplLnN0YXR1cyA9IEVudW1zXzEuQW5pbWF0aW9uU3RhdHVzLmRlY3JlYXNpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNpemUudmVsb2NpdHkgPVxuICAgICAgICAgICAgICAgICgoKF9nID0gdGhpcy5zaXplQW5pbWF0aW9uU3BlZWQpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IGNvbnRhaW5lci5yZXRpbmEuc2l6ZUFuaW1hdGlvblNwZWVkKSAvIDEwMCkgKlxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcjtcbiAgICAgICAgICAgIGlmICghc2l6ZUFuaW1hdGlvbi5zeW5jKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplLnZlbG9jaXR5ICo9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xvciA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb0hzbChjb2xvciwgdGhpcy5pZCwgcmVkdWNlRHVwbGljYXRlcyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbG9yQW5pbWF0aW9uID0gdGhpcy5wYXJ0aWNsZXNPcHRpb25zLmNvbG9yLmFuaW1hdGlvbjtcbiAgICAgICAgaWYgKGNvbG9yQW5pbWF0aW9uLmVuYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb2xvci52ZWxvY2l0eSA9IChjb2xvckFuaW1hdGlvbi5zcGVlZCAvIDEwMCkgKiBjb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcjtcbiAgICAgICAgICAgIGlmICghY29sb3JBbmltYXRpb24uc3luYykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IudmVsb2NpdHkgKj0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5jYWxjUG9zaXRpb24odGhpcy5jb250YWluZXIsIHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5pbml0aWFsUG9zaXRpb24gPSB7XG4gICAgICAgICAgICB4OiB0aGlzLnBvc2l0aW9uLngsXG4gICAgICAgICAgICB5OiB0aGlzLnBvc2l0aW9uLnksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2Zmc2V0ID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wYWNpdHlPcHRpb25zID0gdGhpcy5wYXJ0aWNsZXNPcHRpb25zLm9wYWNpdHk7XG4gICAgICAgIGNvbnN0IHJhbmRvbU9wYWNpdHkgPSB0eXBlb2Ygb3BhY2l0eU9wdGlvbnMucmFuZG9tID09PSBcImJvb2xlYW5cIiA/IG9wYWNpdHlPcHRpb25zLnJhbmRvbSA6IG9wYWNpdHlPcHRpb25zLnJhbmRvbS5lbmFibGU7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBVdGlsc18xLk51bWJlclV0aWxzLmdldFZhbHVlKG9wYWNpdHlPcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3BhY2l0eUFuaW1hdGlvbiA9IG9wYWNpdHlPcHRpb25zLmFuaW1hdGlvbjtcbiAgICAgICAgaWYgKG9wYWNpdHlBbmltYXRpb24uZW5hYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuaW5jcmVhc2luZztcbiAgICAgICAgICAgIGlmICghcmFuZG9tT3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BhY2l0eUFuaW1hdGlvbi5zdGFydFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5TdGFydFZhbHVlVHlwZS5taW46XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkudmFsdWUgPSBvcGFjaXR5QW5pbWF0aW9uLm1pbmltdW1WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuU3RhcnRWYWx1ZVR5cGUucmFuZG9tOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGFjaXR5LnZhbHVlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5yYW5kb21JblJhbmdlKG9wYWNpdHlBbmltYXRpb24ubWluaW11bVZhbHVlLCB0aGlzLm9wYWNpdHkudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5TdGFydFZhbHVlVHlwZS5tYXg6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3BhY2l0eS52ZWxvY2l0eSA9IChvcGFjaXR5QW5pbWF0aW9uLnNwZWVkIC8gMTAwKSAqIGNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yO1xuICAgICAgICAgICAgaWYgKCFvcGFjaXR5QW5pbWF0aW9uLnN5bmMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkudmVsb2NpdHkgKj0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpZGVzID0gMjQ7XG4gICAgICAgIGxldCBkcmF3ZXIgPSBjb250YWluZXIuZHJhd2Vycy5nZXQodGhpcy5zaGFwZSk7XG4gICAgICAgIGlmICghZHJhd2VyKSB7XG4gICAgICAgICAgICBkcmF3ZXIgPSBVdGlsc18xLlBsdWdpbnMuZ2V0U2hhcGVEcmF3ZXIodGhpcy5zaGFwZSk7XG4gICAgICAgICAgICBpZiAoZHJhd2VyKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmRyYXdlcnMuc2V0KHRoaXMuc2hhcGUsIGRyYXdlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lkZUNvdW50RnVuYyA9IGRyYXdlciA9PT0gbnVsbCB8fCBkcmF3ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYXdlci5nZXRTaWRlc0NvdW50O1xuICAgICAgICBpZiAoc2lkZUNvdW50RnVuYykge1xuICAgICAgICAgICAgdGhpcy5zaWRlcyA9IHNpZGVDb3VudEZ1bmModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1hZ2VTaGFwZSA9IHRoaXMubG9hZEltYWdlU2hhcGUoY29udGFpbmVyLCBkcmF3ZXIpO1xuICAgICAgICBpZiAoaW1hZ2VTaGFwZSkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlU2hhcGUuaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLmZpbGwgPSBpbWFnZVNoYXBlLmZpbGw7XG4gICAgICAgICAgICB0aGlzLmNsb3NlID0gaW1hZ2VTaGFwZS5jbG9zZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cm9rZSA9XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlc09wdGlvbnMuc3Ryb2tlIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgICAgICA/IFV0aWxzXzEuVXRpbHMuaXRlbUZyb21BcnJheSh0aGlzLnBhcnRpY2xlc09wdGlvbnMuc3Ryb2tlLCB0aGlzLmlkLCByZWR1Y2VEdXBsaWNhdGVzKVxuICAgICAgICAgICAgICAgIDogdGhpcy5wYXJ0aWNsZXNPcHRpb25zLnN0cm9rZTtcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlLndpZHRoICogY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvO1xuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0ge1xuICAgICAgICAgICAgdmFsdWU6IChfaCA9IFV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvSHNsKHRoaXMuc3Ryb2tlLmNvbG9yKSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogdGhpcy5jb2xvci52YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0cm9rZS5jb2xvciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlQ29sb3JBbmltYXRpb24gPSAoX2ogPSB0aGlzLnN0cm9rZS5jb2xvcikgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmFuaW1hdGlvbjtcbiAgICAgICAgICAgIGlmIChzdHJva2VDb2xvckFuaW1hdGlvbiAmJiB0aGlzLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cm9rZUNvbG9yQW5pbWF0aW9uLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZUNvbG9yLnZlbG9jaXR5ID0gKHN0cm9rZUNvbG9yQW5pbWF0aW9uLnNwZWVkIC8gMTAwKSAqIGNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0cm9rZUNvbG9yQW5pbWF0aW9uLnN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IudmVsb2NpdHkgPSB0aGlzLnN0cm9rZUNvbG9yLnZlbG9jaXR5ICogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJva2VDb2xvci52ZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHJva2VDb2xvckFuaW1hdGlvbi5lbmFibGUgJiYgIXN0cm9rZUNvbG9yQW5pbWF0aW9uLnN5bmMgJiYgdGhpcy5zdHJva2VDb2xvci52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZUNvbG9yLnZhbHVlLmggPSBNYXRoLnJhbmRvbSgpICogMzYwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaWZlT3B0aW9ucyA9IHBhcnRpY2xlc09wdGlvbnMubGlmZTtcbiAgICAgICAgdGhpcy5saWZlRGVsYXkgPSBjb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvclxuICAgICAgICAgICAgPyAoKFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0VmFsdWUobGlmZU9wdGlvbnMuZGVsYXkpICogKGxpZmVPcHRpb25zLmRlbGF5LnN5bmMgPyAxIDogTWF0aC5yYW5kb20oKSkpIC9cbiAgICAgICAgICAgICAgICBjb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcikgKlxuICAgICAgICAgICAgICAgIDEwMDBcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgdGhpcy5saWZlRGVsYXlUaW1lID0gMDtcbiAgICAgICAgdGhpcy5saWZlRHVyYXRpb24gPSBjb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvclxuICAgICAgICAgICAgPyAoKFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0VmFsdWUobGlmZU9wdGlvbnMuZHVyYXRpb24pICogKGxpZmVPcHRpb25zLmR1cmF0aW9uLnN5bmMgPyAxIDogTWF0aC5yYW5kb20oKSkpIC9cbiAgICAgICAgICAgICAgICBjb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcikgKlxuICAgICAgICAgICAgICAgIDEwMDBcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgdGhpcy5saWZlVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGl2ZXNSZW1haW5pbmcgPSBwYXJ0aWNsZXNPcHRpb25zLmxpZmUuY291bnQ7XG4gICAgICAgIHRoaXMuc3Bhd25pbmcgPSB0aGlzLmxpZmVEZWxheSA+IDA7XG4gICAgICAgIGlmICh0aGlzLmxpZmVEdXJhdGlvbiA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpZmVEdXJhdGlvbiA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpdmVzUmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMubGl2ZXNSZW1haW5pbmcgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoYWRvd0NvbG9yID0gVXRpbHNfMS5Db2xvclV0aWxzLmNvbG9yVG9SZ2IodGhpcy5wYXJ0aWNsZXNPcHRpb25zLnNoYWRvdy5jb2xvcik7XG4gICAgICAgIHRoaXMudXBkYXRlciA9IG5ldyBVcGRhdGVyXzEuVXBkYXRlcihjb250YWluZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLmluZmVjdGVyID0gbmV3IEluZmVjdGVyXzEuSW5mZWN0ZXIoY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5tb3ZlciA9IG5ldyBNb3Zlcl8xLk1vdmVyKGNvbnRhaW5lciwgdGhpcyk7XG4gICAgfVxuICAgIG1vdmUoZGVsdGEpIHtcbiAgICAgICAgdGhpcy5tb3Zlci5tb3ZlKGRlbHRhKTtcbiAgICB9XG4gICAgdXBkYXRlKGRlbHRhKSB7XG4gICAgICAgIHRoaXMudXBkYXRlci51cGRhdGUoZGVsdGEpO1xuICAgIH1cbiAgICBkcmF3KGRlbHRhKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNhbnZhcy5kcmF3UGFydGljbGUodGhpcywgZGVsdGEpO1xuICAgIH1cbiAgICBnZXRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMucG9zaXRpb24ueCArIHRoaXMub2Zmc2V0LngsXG4gICAgICAgICAgICB5OiB0aGlzLnBvc2l0aW9uLnkgKyB0aGlzLm9mZnNldC55LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRSYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1YmJsZS5yYWRpdXMgfHwgdGhpcy5zaXplLnZhbHVlO1xuICAgIH1cbiAgICBnZXRGaWxsQ29sb3IoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuYnViYmxlLmNvbG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbG9yLnZhbHVlO1xuICAgIH1cbiAgICBnZXRTdHJva2VDb2xvcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuYnViYmxlLmNvbG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnN0cm9rZUNvbG9yLnZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmNvbG9yLnZhbHVlO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYnViYmxlLmluUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5rcyA9IFtdO1xuICAgIH1cbiAgICBjYWxjUG9zaXRpb24oY29udGFpbmVyLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgY29udGFpbmVyLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsdWdpblBvcyA9IHBsdWdpbi5wYXJ0aWNsZVBvc2l0aW9uICE9PSB1bmRlZmluZWQgPyBwbHVnaW4ucGFydGljbGVQb3NpdGlvbihwb3NpdGlvbiwgdGhpcykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAocGx1Z2luUG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCBwbHVnaW5Qb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcyA9IHtcbiAgICAgICAgICAgIHg6IChfYSA9IHBvc2l0aW9uID09PSBudWxsIHx8IHBvc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb3NpdGlvbi54KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBNYXRoLnJhbmRvbSgpICogY29udGFpbmVyLmNhbnZhcy5zaXplLndpZHRoLFxuICAgICAgICAgICAgeTogKF9iID0gcG9zaXRpb24gPT09IG51bGwgfHwgcG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvc2l0aW9uLnkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE1hdGgucmFuZG9tKCkgKiBjb250YWluZXIuY2FudmFzLnNpemUuaGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvdXRNb2RlID0gdGhpcy5wYXJ0aWNsZXNPcHRpb25zLm1vdmUub3V0TW9kZTtcbiAgICAgICAgaWYgKFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KG91dE1vZGUsIEVudW1zXzEuT3V0TW9kZS5ib3VuY2UpIHx8IFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KG91dE1vZGUsIEVudW1zXzEuT3V0TW9kZS5ib3VuY2VIb3Jpem9udGFsKSkge1xuICAgICAgICAgICAgaWYgKHBvcy54ID4gY29udGFpbmVyLmNhbnZhcy5zaXplLndpZHRoIC0gdGhpcy5zaXplLnZhbHVlICogMikge1xuICAgICAgICAgICAgICAgIHBvcy54IC09IHRoaXMuc2l6ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBvcy54IDwgdGhpcy5zaXplLnZhbHVlICogMikge1xuICAgICAgICAgICAgICAgIHBvcy54ICs9IHRoaXMuc2l6ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHNfMS5VdGlscy5pc0luQXJyYXkob3V0TW9kZSwgRW51bXNfMS5PdXRNb2RlLmJvdW5jZSkgfHwgVXRpbHNfMS5VdGlscy5pc0luQXJyYXkob3V0TW9kZSwgRW51bXNfMS5PdXRNb2RlLmJvdW5jZVZlcnRpY2FsKSkge1xuICAgICAgICAgICAgaWYgKHBvcy55ID4gY29udGFpbmVyLmNhbnZhcy5zaXplLmhlaWdodCAtIHRoaXMuc2l6ZS52YWx1ZSAqIDIpIHtcbiAgICAgICAgICAgICAgICBwb3MueSAtPSB0aGlzLnNpemUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwb3MueSA8IHRoaXMuc2l6ZS52YWx1ZSAqIDIpIHtcbiAgICAgICAgICAgICAgICBwb3MueSArPSB0aGlzLnNpemUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgY2FsY3VsYXRlVmVsb2NpdHkoKSB7XG4gICAgICAgIGNvbnN0IGJhc2VWZWxvY2l0eSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0UGFydGljbGVCYXNlVmVsb2NpdHkodGhpcyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICAgICAgICB2ZXJ0aWNhbDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbW92ZU9wdGlvbnMgPSB0aGlzLnBhcnRpY2xlc09wdGlvbnMubW92ZTtcbiAgICAgICAgbGV0IHJhZDtcbiAgICAgICAgbGV0IHJhZE9mZnNldCA9IE1hdGguUEkgLyA0O1xuICAgICAgICBpZiAodHlwZW9mIG1vdmVPcHRpb25zLmFuZ2xlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByYWQgPSAoTWF0aC5QSSAvIDE4MCkgKiBtb3ZlT3B0aW9ucy5hbmdsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhZCA9IChNYXRoLlBJIC8gMTgwKSAqIG1vdmVPcHRpb25zLmFuZ2xlLnZhbHVlO1xuICAgICAgICAgICAgcmFkT2Zmc2V0ID0gKE1hdGguUEkgLyAxODApICogbW92ZU9wdGlvbnMuYW5nbGUub2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICAgICAgbGVmdDogTWF0aC5zaW4ocmFkT2Zmc2V0ICsgcmFkIC8gMikgLSBNYXRoLnNpbihyYWRPZmZzZXQgLSByYWQgLyAyKSxcbiAgICAgICAgICAgIHJpZ2h0OiBNYXRoLmNvcyhyYWRPZmZzZXQgKyByYWQgLyAyKSAtIE1hdGguY29zKHJhZE9mZnNldCAtIHJhZCAvIDIpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobW92ZU9wdGlvbnMuc3RyYWlnaHQpIHtcbiAgICAgICAgICAgIHJlcy5ob3Jpem9udGFsID0gYmFzZVZlbG9jaXR5Lng7XG4gICAgICAgICAgICByZXMudmVydGljYWwgPSBiYXNlVmVsb2NpdHkueTtcbiAgICAgICAgICAgIGlmIChtb3ZlT3B0aW9ucy5yYW5kb20pIHtcbiAgICAgICAgICAgICAgICByZXMuaG9yaXpvbnRhbCArPSBVdGlsc18xLk51bWJlclV0aWxzLnJhbmRvbUluUmFuZ2UocmFuZ2UubGVmdCwgcmFuZ2UucmlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICByZXMudmVydGljYWwgKz0gVXRpbHNfMS5OdW1iZXJVdGlscy5yYW5kb21JblJhbmdlKHJhbmdlLmxlZnQsIHJhbmdlLnJpZ2h0KSAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMuaG9yaXpvbnRhbCA9IGJhc2VWZWxvY2l0eS54ICsgVXRpbHNfMS5OdW1iZXJVdGlscy5yYW5kb21JblJhbmdlKHJhbmdlLmxlZnQsIHJhbmdlLnJpZ2h0KSAvIDI7XG4gICAgICAgICAgICByZXMudmVydGljYWwgPSBiYXNlVmVsb2NpdHkueSArIFV0aWxzXzEuTnVtYmVyVXRpbHMucmFuZG9tSW5SYW5nZShyYW5nZS5sZWZ0LCByYW5nZS5yaWdodCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGxvYWRJbWFnZVNoYXBlKGNvbnRhaW5lciwgZHJhd2VyKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIGlmICghKHRoaXMuc2hhcGUgPT09IEVudW1zXzEuU2hhcGVUeXBlLmltYWdlIHx8IHRoaXMuc2hhcGUgPT09IEVudW1zXzEuU2hhcGVUeXBlLmltYWdlcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbWFnZURyYXdlciA9IGRyYXdlcjtcbiAgICAgICAgY29uc3QgaW1hZ2VzID0gaW1hZ2VEcmF3ZXIuZ2V0SW1hZ2VzKGNvbnRhaW5lcikuaW1hZ2VzO1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSB0aGlzLnNoYXBlRGF0YTtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSAoX2EgPSBpbWFnZXMuZmluZCgodCkgPT4gdC5zb3VyY2UgPT09IGltYWdlRGF0YS5zcmMpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpbWFnZXNbMF07XG4gICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5nZXRGaWxsQ29sb3IoKTtcbiAgICAgICAgbGV0IGltYWdlUmVzO1xuICAgICAgICBpZiAoIWltYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlLnN2Z0RhdGEgIT09IHVuZGVmaW5lZCAmJiBpbWFnZURhdGEucmVwbGFjZUNvbG9yICYmIGNvbG9yKSB7XG4gICAgICAgICAgICBjb25zdCBzdmdDb2xvcmVkRGF0YSA9IFV0aWxzXzEuQ29sb3JVdGlscy5yZXBsYWNlQ29sb3JTdmcoaW1hZ2UsIGNvbG9yLCB0aGlzLm9wYWNpdHkudmFsdWUpO1xuICAgICAgICAgICAgY29uc3Qgc3ZnID0gbmV3IEJsb2IoW3N2Z0NvbG9yZWREYXRhXSwgeyB0eXBlOiBcImltYWdlL3N2Zyt4bWxcIiB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRvbVVybCA9IFVSTCB8fCB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93O1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZG9tVXJsLmNyZWF0ZU9iamVjdFVSTChzdmcpO1xuICAgICAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWFnZVJlcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBpbWFnZSxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJhdGlvOiBpbWFnZURhdGEud2lkdGggLyBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJlcGxhY2VDb2xvcjogKF9iID0gaW1hZ2VEYXRhLnJlcGxhY2VDb2xvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogaW1hZ2VEYXRhLnJlcGxhY2VfY29sb3IsXG4gICAgICAgICAgICAgICAgc291cmNlOiBpbWFnZURhdGEuc3JjLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5lbGVtZW50ID0gaW1nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb21VcmwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvbVVybC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgICAgICAgICAgICBVdGlsc18xLlV0aWxzLmxvYWRJbWFnZShpbWFnZURhdGEuc3JjKS50aGVuKChpbWcyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5lbGVtZW50ID0gaW1nMi5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbWFnZVJlcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBpbWFnZSxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgcmF0aW86IGltYWdlRGF0YS53aWR0aCAvIGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvbG9yOiAoX2MgPSBpbWFnZURhdGEucmVwbGFjZUNvbG9yKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBpbWFnZURhdGEucmVwbGFjZV9jb2xvcixcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGltYWdlRGF0YS5zcmMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW1hZ2VSZXMucmF0aW8pIHtcbiAgICAgICAgICAgIGltYWdlUmVzLnJhdGlvID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxsID0gKF9kID0gaW1hZ2VEYXRhLmZpbGwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRoaXMuZmlsbDtcbiAgICAgICAgY29uc3QgY2xvc2UgPSAoX2UgPSBpbWFnZURhdGEuY2xvc2UpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMuY2xvc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbWFnZTogaW1hZ2VSZXMsXG4gICAgICAgICAgICBmaWxsLFxuICAgICAgICAgICAgY2xvc2UsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5QYXJ0aWNsZSA9IFBhcnRpY2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluZmVjdGVyID0gdm9pZCAwO1xuY2xhc3MgSW5mZWN0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgc3RhcnRJbmZlY3Rpb24oc3RhZ2UpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuY29udGFpbmVyLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHN0YWdlcyA9IG9wdGlvbnMuaW5mZWN0aW9uLnN0YWdlcztcbiAgICAgICAgY29uc3Qgc3RhZ2VzQ291bnQgPSBzdGFnZXMubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhZ2UgPiBzdGFnZXNDb3VudCB8fCBzdGFnZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZmVjdGlvbkRlbGF5ID0gMDtcbiAgICAgICAgdGhpcy5pbmZlY3Rpb25EZWxheVN0YWdlID0gc3RhZ2U7XG4gICAgfVxuICAgIHVwZGF0ZUluZmVjdGlvblN0YWdlKHN0YWdlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCBzdGFnZXNDb3VudCA9IG9wdGlvbnMuaW5mZWN0aW9uLnN0YWdlcy5sZW5ndGg7XG4gICAgICAgIGlmIChzdGFnZSA+IHN0YWdlc0NvdW50IHx8IHN0YWdlIDwgMCB8fCAodGhpcy5pbmZlY3Rpb25TdGFnZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaW5mZWN0aW9uU3RhZ2UgPiBzdGFnZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZmVjdGlvblN0YWdlID0gc3RhZ2U7XG4gICAgICAgIHRoaXMuaW5mZWN0aW9uVGltZSA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZUluZmVjdGlvbihkZWx0YSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb250YWluZXIub3B0aW9ucztcbiAgICAgICAgY29uc3QgaW5mZWN0aW9uID0gb3B0aW9ucy5pbmZlY3Rpb247XG4gICAgICAgIGNvbnN0IHN0YWdlcyA9IG9wdGlvbnMuaW5mZWN0aW9uLnN0YWdlcztcbiAgICAgICAgY29uc3Qgc3RhZ2VzQ291bnQgPSBzdGFnZXMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5pbmZlY3Rpb25EZWxheSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaW5mZWN0aW9uRGVsYXlTdGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFnZSA9IHRoaXMuaW5mZWN0aW9uRGVsYXlTdGFnZTtcbiAgICAgICAgICAgIGlmIChzdGFnZSA+IHN0YWdlc0NvdW50IHx8IHN0YWdlIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmluZmVjdGlvbkRlbGF5ID4gaW5mZWN0aW9uLmRlbGF5ICogMTAwMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mZWN0aW9uU3RhZ2UgPSBzdGFnZTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZmVjdGlvblRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmluZmVjdGlvbkRlbGF5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmluZmVjdGlvbkRlbGF5U3RhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZmVjdGlvbkRlbGF5ICs9IGRlbHRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5mZWN0aW9uRGVsYXk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pbmZlY3Rpb25EZWxheVN0YWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZmVjdGlvblN0YWdlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pbmZlY3Rpb25UaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZmVjdGlvblN0YWdlID0gc3RhZ2VzW3RoaXMuaW5mZWN0aW9uU3RhZ2VdO1xuICAgICAgICAgICAgaWYgKGluZmVjdGlvblN0YWdlLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgaW5mZWN0aW9uU3RhZ2UuZHVyYXRpb24gPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZmVjdGlvblRpbWUgPiBpbmZlY3Rpb25TdGFnZS5kdXJhdGlvbiAqIDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0SW5mZWN0aW9uU3RhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mZWN0aW9uVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZmVjdGlvblRpbWUgKz0gZGVsdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pbmZlY3Rpb25TdGFnZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmluZmVjdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dEluZmVjdGlvblN0YWdlKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb250YWluZXIub3B0aW9ucztcbiAgICAgICAgY29uc3Qgc3RhZ2VzQ291bnQgPSBvcHRpb25zLmluZmVjdGlvbi5zdGFnZXMubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhZ2VzQ291bnQgPD0gMCB8fCB0aGlzLmluZmVjdGlvblN0YWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZmVjdGlvblRpbWUgPSAwO1xuICAgICAgICBpZiAoc3RhZ2VzQ291bnQgPD0gKyt0aGlzLmluZmVjdGlvblN0YWdlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbmZlY3Rpb24uY3VyZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmluZmVjdGlvblN0YWdlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmluZmVjdGlvblRpbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZlY3Rpb25TdGFnZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZlY3Rpb25UaW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSW5mZWN0ZXIgPSBJbmZlY3RlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnRlcmFjdGlvbk1hbmFnZXIgPSB2b2lkIDA7XG5jb25zdCBHcmFiYmVyXzEgPSByZXF1aXJlKFwiLi4vLi4vSW50ZXJhY3Rpb25zL0V4dGVybmFsL0dyYWJiZXJcIik7XG5jb25zdCBSZXB1bHNlcl8xID0gcmVxdWlyZShcIi4uLy4uL0ludGVyYWN0aW9ucy9FeHRlcm5hbC9SZXB1bHNlclwiKTtcbmNvbnN0IEJ1YmJsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9JbnRlcmFjdGlvbnMvRXh0ZXJuYWwvQnViYmxlclwiKTtcbmNvbnN0IENvbm5lY3Rvcl8xID0gcmVxdWlyZShcIi4uLy4uL0ludGVyYWN0aW9ucy9FeHRlcm5hbC9Db25uZWN0b3JcIik7XG5jb25zdCBMaW5rZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9JbnRlcmFjdGlvbnMvUGFydGljbGVzL0xpbmtlclwiKTtcbmNvbnN0IEF0dHJhY3Rvcl8xID0gcmVxdWlyZShcIi4uLy4uL0ludGVyYWN0aW9ucy9QYXJ0aWNsZXMvQXR0cmFjdG9yXCIpO1xuY29uc3QgQ29sbGlkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9JbnRlcmFjdGlvbnMvUGFydGljbGVzL0NvbGxpZGVyXCIpO1xuY29uc3QgSW5mZWN0ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9JbnRlcmFjdGlvbnMvUGFydGljbGVzL0luZmVjdGVyXCIpO1xuY29uc3QgVHJhaWxNYWtlcl8xID0gcmVxdWlyZShcIi4uLy4uL0ludGVyYWN0aW9ucy9FeHRlcm5hbC9UcmFpbE1ha2VyXCIpO1xuY29uc3QgQXR0cmFjdG9yXzIgPSByZXF1aXJlKFwiLi4vLi4vSW50ZXJhY3Rpb25zL0V4dGVybmFsL0F0dHJhY3RvclwiKTtcbmNvbnN0IExpZ2h0ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9JbnRlcmFjdGlvbnMvUGFydGljbGVzL0xpZ2h0ZXJcIik7XG5jb25zdCBMaWdodGVyXzIgPSByZXF1aXJlKFwiLi4vLi4vSW50ZXJhY3Rpb25zL0V4dGVybmFsL0xpZ2h0ZXJcIik7XG5jb25zdCBCb3VuY2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vSW50ZXJhY3Rpb25zL0V4dGVybmFsL0JvdW5jZXJcIik7XG5jbGFzcyBJbnRlcmFjdGlvbk1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5leHRlcm5hbEludGVyYWN0b3JzID0gW1xuICAgICAgICAgICAgbmV3IEJvdW5jZXJfMS5Cb3VuY2VyKGNvbnRhaW5lciksXG4gICAgICAgICAgICBuZXcgQnViYmxlcl8xLkJ1YmJsZXIoY29udGFpbmVyKSxcbiAgICAgICAgICAgIG5ldyBDb25uZWN0b3JfMS5Db25uZWN0b3IoY29udGFpbmVyKSxcbiAgICAgICAgICAgIG5ldyBHcmFiYmVyXzEuR3JhYmJlcihjb250YWluZXIpLFxuICAgICAgICAgICAgbmV3IExpZ2h0ZXJfMi5MaWdodGVyKGNvbnRhaW5lciksXG4gICAgICAgICAgICBuZXcgQXR0cmFjdG9yXzIuQXR0cmFjdG9yKGNvbnRhaW5lciksXG4gICAgICAgICAgICBuZXcgUmVwdWxzZXJfMS5SZXB1bHNlcihjb250YWluZXIpLFxuICAgICAgICAgICAgbmV3IFRyYWlsTWFrZXJfMS5UcmFpbE1ha2VyKGNvbnRhaW5lciksXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMucGFydGljbGVJbnRlcmFjdG9ycyA9IFtcbiAgICAgICAgICAgIG5ldyBBdHRyYWN0b3JfMS5BdHRyYWN0b3IoY29udGFpbmVyKSxcbiAgICAgICAgICAgIG5ldyBMaWdodGVyXzEuTGlnaHRlcihjb250YWluZXIpLFxuICAgICAgICAgICAgbmV3IENvbGxpZGVyXzEuQ29sbGlkZXIoY29udGFpbmVyKSxcbiAgICAgICAgICAgIG5ldyBJbmZlY3Rlcl8xLkluZmVjdGVyKGNvbnRhaW5lciksXG4gICAgICAgICAgICBuZXcgTGlua2VyXzEuTGlua2VyKGNvbnRhaW5lciksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgfVxuICAgIGV4dGVybmFsSW50ZXJhY3QoZGVsdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbnRlcmFjdG9yIG9mIHRoaXMuZXh0ZXJuYWxJbnRlcmFjdG9ycykge1xuICAgICAgICAgICAgaWYgKGludGVyYWN0b3IuaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdG9yLmludGVyYWN0KGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJ0aWNsZXNJbnRlcmFjdChwYXJ0aWNsZSwgZGVsdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbnRlcmFjdG9yIG9mIHRoaXMuZXh0ZXJuYWxJbnRlcmFjdG9ycykge1xuICAgICAgICAgICAgaW50ZXJhY3Rvci5yZXNldChwYXJ0aWNsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbnRlcmFjdG9yIG9mIHRoaXMucGFydGljbGVJbnRlcmFjdG9ycykge1xuICAgICAgICAgICAgaWYgKGludGVyYWN0b3IuaXNFbmFibGVkKHBhcnRpY2xlKSkge1xuICAgICAgICAgICAgICAgIGludGVyYWN0b3IuaW50ZXJhY3QocGFydGljbGUsIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJhY3Rpb25NYW5hZ2VyID0gSW50ZXJhY3Rpb25NYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vdmVyID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXNcIik7XG5jbGFzcyBNb3ZlciB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBwYXJ0aWNsZSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZSA9IHBhcnRpY2xlO1xuICAgIH1cbiAgICBtb3ZlKGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZTtcbiAgICAgICAgcGFydGljbGUuYnViYmxlLmluUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgcGFydGljbGUubGlua3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbLCBwbHVnaW5dIG9mIHRoaXMuY29udGFpbmVyLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbHVnaW4ucGFydGljbGVVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4ucGFydGljbGVVcGRhdGUocGFydGljbGUsIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGljbGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlUGFydGljbGUoZGVsdGEpO1xuICAgICAgICB0aGlzLm1vdmVQYXJhbGxheCgpO1xuICAgIH1cbiAgICBtb3ZlUGFydGljbGUoZGVsdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZXNPcHRpb25zID0gcGFydGljbGUucGFydGljbGVzT3B0aW9ucztcbiAgICAgICAgaWYgKCFwYXJ0aWNsZXNPcHRpb25zLm1vdmUuZW5hYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHNsb3dGYWN0b3IgPSB0aGlzLmdldFByb3hpbWl0eVNwZWVkRmFjdG9yKCk7XG4gICAgICAgIGNvbnN0IGJhc2VTcGVlZCA9ICgoX2EgPSBwYXJ0aWNsZS5tb3ZlU3BlZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnRhaW5lci5yZXRpbmEubW92ZVNwZWVkKSAqIGNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yO1xuICAgICAgICBjb25zdCBtYXhTaXplID0gKF9iID0gcGFydGljbGUuc2l6ZVZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb250YWluZXIucmV0aW5hLnNpemVWYWx1ZTtcbiAgICAgICAgY29uc3Qgc2l6ZUZhY3RvciA9IHBhcnRpY2xlc09wdGlvbnMubW92ZS5zaXplID8gcGFydGljbGUuZ2V0UmFkaXVzKCkgLyBtYXhTaXplIDogMTtcbiAgICAgICAgY29uc3QgbW92ZVNwZWVkID0gKGJhc2VTcGVlZCAvIDIpICogc2l6ZUZhY3RvciAqIHNsb3dGYWN0b3IgKiBkZWx0YS5mYWN0b3I7XG4gICAgICAgIHRoaXMuYXBwbHlOb2lzZShkZWx0YSk7XG4gICAgICAgIGNvbnN0IGdyYXZpdHlPcHRpb25zID0gcGFydGljbGVzT3B0aW9ucy5tb3ZlLmdyYXZpdHk7XG4gICAgICAgIGlmIChncmF2aXR5T3B0aW9ucy5lbmFibGUpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnZlcnRpY2FsICs9IChncmF2aXR5T3B0aW9ucy5hY2NlbGVyYXRpb24gKiBkZWx0YS5mYWN0b3IpIC8gKDYwICogbW92ZVNwZWVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IHtcbiAgICAgICAgICAgIGhvcml6b250YWw6IHBhcnRpY2xlLnZlbG9jaXR5Lmhvcml6b250YWwgKiBtb3ZlU3BlZWQsXG4gICAgICAgICAgICB2ZXJ0aWNhbDogcGFydGljbGUudmVsb2NpdHkudmVydGljYWwgKiBtb3ZlU3BlZWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChncmF2aXR5T3B0aW9ucy5lbmFibGUgJiYgdmVsb2NpdHkudmVydGljYWwgPj0gZ3Jhdml0eU9wdGlvbnMubWF4U3BlZWQgJiYgZ3Jhdml0eU9wdGlvbnMubWF4U3BlZWQgPiAwKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eS52ZXJ0aWNhbCA9IGdyYXZpdHlPcHRpb25zLm1heFNwZWVkO1xuICAgICAgICAgICAgcGFydGljbGUudmVsb2NpdHkudmVydGljYWwgPSB2ZWxvY2l0eS52ZXJ0aWNhbCAvIG1vdmVTcGVlZDtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi54ICs9IHZlbG9jaXR5Lmhvcml6b250YWw7XG4gICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnkgKz0gdmVsb2NpdHkudmVydGljYWw7XG4gICAgICAgIGlmIChwYXJ0aWNsZXNPcHRpb25zLm1vdmUudmlicmF0ZSkge1xuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueCArPSBNYXRoLnNpbihwYXJ0aWNsZS5wb3NpdGlvbi54ICogTWF0aC5jb3MocGFydGljbGUucG9zaXRpb24ueSkpO1xuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueSArPSBNYXRoLmNvcyhwYXJ0aWNsZS5wb3NpdGlvbi55ICogTWF0aC5zaW4ocGFydGljbGUucG9zaXRpb24ueCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXRpYWxQb3NpdGlvbiA9IHBhcnRpY2xlLmluaXRpYWxQb3NpdGlvbjtcbiAgICAgICAgY29uc3QgaW5pdGlhbERpc3RhbmNlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShpbml0aWFsUG9zaXRpb24sIHBhcnRpY2xlLnBvc2l0aW9uKTtcbiAgICAgICAgaWYgKHBhcnRpY2xlLm1heERpc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbERpc3RhbmNlID49IHBhcnRpY2xlLm1heERpc3RhbmNlICYmICFwYXJ0aWNsZS5taXNwbGFjZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5taXNwbGFjZWQgPSBpbml0aWFsRGlzdGFuY2UgPiBwYXJ0aWNsZS5tYXhEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS5ob3Jpem9udGFsID0gcGFydGljbGUudmVsb2NpdHkudmVydGljYWwgLyAyIC0gcGFydGljbGUudmVsb2NpdHkuaG9yaXpvbnRhbDtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS52ZXJ0aWNhbCA9IHBhcnRpY2xlLnZlbG9jaXR5Lmhvcml6b250YWwgLyAyIC0gcGFydGljbGUudmVsb2NpdHkudmVydGljYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbml0aWFsRGlzdGFuY2UgPCBwYXJ0aWNsZS5tYXhEaXN0YW5jZSAmJiBwYXJ0aWNsZS5taXNwbGFjZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5taXNwbGFjZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRpY2xlLm1pc3BsYWNlZCkge1xuICAgICAgICAgICAgICAgIGlmICgocGFydGljbGUucG9zaXRpb24ueCA8IGluaXRpYWxQb3NpdGlvbi54ICYmIHBhcnRpY2xlLnZlbG9jaXR5Lmhvcml6b250YWwgPCAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAocGFydGljbGUucG9zaXRpb24ueCA+IGluaXRpYWxQb3NpdGlvbi54ICYmIHBhcnRpY2xlLnZlbG9jaXR5Lmhvcml6b250YWwgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS5ob3Jpem9udGFsICo9IC1NYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHBhcnRpY2xlLnBvc2l0aW9uLnkgPCBpbml0aWFsUG9zaXRpb24ueSAmJiBwYXJ0aWNsZS52ZWxvY2l0eS52ZXJ0aWNhbCA8IDApIHx8XG4gICAgICAgICAgICAgICAgICAgIChwYXJ0aWNsZS5wb3NpdGlvbi55ID4gaW5pdGlhbFBvc2l0aW9uLnkgJiYgcGFydGljbGUudmVsb2NpdHkudmVydGljYWwgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS52ZXJ0aWNhbCAqPSAtTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlOb2lzZShkZWx0YSkge1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGU7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlc09wdGlvbnMgPSBwYXJ0aWNsZS5wYXJ0aWNsZXNPcHRpb25zO1xuICAgICAgICBjb25zdCBub2lzZU9wdGlvbnMgPSBwYXJ0aWNsZXNPcHRpb25zLm1vdmUubm9pc2U7XG4gICAgICAgIGNvbnN0IG5vaXNlRW5hYmxlZCA9IG5vaXNlT3B0aW9ucy5lbmFibGU7XG4gICAgICAgIGlmICghbm9pc2VFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGlmIChwYXJ0aWNsZS5sYXN0Tm9pc2VUaW1lIDw9IHBhcnRpY2xlLm5vaXNlRGVsYXkpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLmxhc3ROb2lzZVRpbWUgKz0gZGVsdGEudmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9pc2UgPSBjb250YWluZXIubm9pc2UuZ2VuZXJhdGUocGFydGljbGUpO1xuICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS5ob3Jpem9udGFsICs9IE1hdGguY29zKG5vaXNlLmFuZ2xlKSAqIG5vaXNlLmxlbmd0aDtcbiAgICAgICAgcGFydGljbGUudmVsb2NpdHkuaG9yaXpvbnRhbCA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuY2xhbXAocGFydGljbGUudmVsb2NpdHkuaG9yaXpvbnRhbCwgLTEsIDEpO1xuICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS52ZXJ0aWNhbCArPSBNYXRoLnNpbihub2lzZS5hbmdsZSkgKiBub2lzZS5sZW5ndGg7XG4gICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnZlcnRpY2FsID0gVXRpbHNfMS5OdW1iZXJVdGlscy5jbGFtcChwYXJ0aWNsZS52ZWxvY2l0eS52ZXJ0aWNhbCwgLTEsIDEpO1xuICAgICAgICBwYXJ0aWNsZS5sYXN0Tm9pc2VUaW1lIC09IHBhcnRpY2xlLm5vaXNlRGVsYXk7XG4gICAgfVxuICAgIG1vdmVQYXJhbGxheCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIub3B0aW9ucztcbiAgICAgICAgaWYgKFV0aWxzXzEuVXRpbHMuaXNTc3IoKSB8fCAhb3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cy5vbkhvdmVyLnBhcmFsbGF4LmVuYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZTtcbiAgICAgICAgY29uc3QgcGFyYWxsYXhGb3JjZSA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25Ib3Zlci5wYXJhbGxheC5mb3JjZTtcbiAgICAgICAgY29uc3QgbW91c2VQb3MgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5wb3NpdGlvbjtcbiAgICAgICAgaWYgKCFtb3VzZVBvcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhc0NlbnRlciA9IHtcbiAgICAgICAgICAgIHg6IGNvbnRhaW5lci5jYW52YXMuc2l6ZS53aWR0aCAvIDIsXG4gICAgICAgICAgICB5OiBjb250YWluZXIuY2FudmFzLnNpemUuaGVpZ2h0IC8gMixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFyYWxsYXhTbW9vdGggPSBvcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzLm9uSG92ZXIucGFyYWxsYXguc21vb3RoO1xuICAgICAgICBjb25zdCBmYWN0b3IgPSBwYXJ0aWNsZS5nZXRSYWRpdXMoKSAvIHBhcmFsbGF4Rm9yY2U7XG4gICAgICAgIGNvbnN0IHRtcCA9IHtcbiAgICAgICAgICAgIHg6IChtb3VzZVBvcy54IC0gY2FudmFzQ2VudGVyLngpICogZmFjdG9yLFxuICAgICAgICAgICAgeTogKG1vdXNlUG9zLnkgLSBjYW52YXNDZW50ZXIueSkgKiBmYWN0b3IsXG4gICAgICAgIH07XG4gICAgICAgIHBhcnRpY2xlLm9mZnNldC54ICs9ICh0bXAueCAtIHBhcnRpY2xlLm9mZnNldC54KSAvIHBhcmFsbGF4U21vb3RoO1xuICAgICAgICBwYXJ0aWNsZS5vZmZzZXQueSArPSAodG1wLnkgLSBwYXJ0aWNsZS5vZmZzZXQueSkgLyBwYXJhbGxheFNtb290aDtcbiAgICB9XG4gICAgZ2V0UHJveGltaXR5U3BlZWRGYWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuSG92ZXJNb2RlLnNsb3csIG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25Ib3Zlci5tb2RlKTtcbiAgICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vdXNlUG9zID0gdGhpcy5jb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5wb3NpdGlvbjtcbiAgICAgICAgaWYgKCFtb3VzZVBvcykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydGljbGVQb3MgPSB0aGlzLnBhcnRpY2xlLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlKG1vdXNlUG9zLCBwYXJ0aWNsZVBvcyk7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGNvbnRhaW5lci5yZXRpbmEuc2xvd01vZGVSYWRpdXM7XG4gICAgICAgIGlmIChkaXN0ID4gcmFkaXVzKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm94aW1pdHlGYWN0b3IgPSBkaXN0IC8gcmFkaXVzIHx8IDA7XG4gICAgICAgIGNvbnN0IHNsb3dGYWN0b3IgPSBvcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMuc2xvdy5mYWN0b3I7XG4gICAgICAgIHJldHVybiBwcm94aW1pdHlGYWN0b3IgLyBzbG93RmFjdG9yO1xuICAgIH1cbn1cbmV4cG9ydHMuTW92ZXIgPSBNb3ZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VcGRhdGVyID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXNcIik7XG5jb25zdCBPdXRNb2RlRGlyZWN0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXMvRGlyZWN0aW9ucy9PdXRNb2RlRGlyZWN0aW9uXCIpO1xuZnVuY3Rpb24gYm91bmNlSG9yaXpvbnRhbChkYXRhKSB7XG4gICAgaWYgKGRhdGEub3V0TW9kZSA9PT0gRW51bXNfMS5PdXRNb2RlLmJvdW5jZSB8fFxuICAgICAgICBkYXRhLm91dE1vZGUgPT09IEVudW1zXzEuT3V0TW9kZS5ib3VuY2VIb3Jpem9udGFsIHx8XG4gICAgICAgIGRhdGEub3V0TW9kZSA9PT0gXCJib3VuY2VIb3Jpem9udGFsXCIpIHtcbiAgICAgICAgY29uc3QgdmVsb2NpdHkgPSBkYXRhLnBhcnRpY2xlLnZlbG9jaXR5Lmhvcml6b250YWw7XG4gICAgICAgIGxldCBib3VuY2VkID0gZmFsc2U7XG4gICAgICAgIGlmICgoZGF0YS5kaXJlY3Rpb24gPT09IE91dE1vZGVEaXJlY3Rpb25fMS5PdXRNb2RlRGlyZWN0aW9uLnJpZ2h0ICYmIGRhdGEuYm91bmRzLnJpZ2h0ID49IGRhdGEuY2FudmFzU2l6ZS53aWR0aCAmJiB2ZWxvY2l0eSA+IDApIHx8XG4gICAgICAgICAgICAoZGF0YS5kaXJlY3Rpb24gPT09IE91dE1vZGVEaXJlY3Rpb25fMS5PdXRNb2RlRGlyZWN0aW9uLmxlZnQgJiYgZGF0YS5ib3VuZHMubGVmdCA8PSAwICYmIHZlbG9jaXR5IDwgMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZlbG9jaXR5ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRWYWx1ZShkYXRhLnBhcnRpY2xlLnBhcnRpY2xlc09wdGlvbnMuYm91bmNlLmhvcml6b250YWwpO1xuICAgICAgICAgICAgZGF0YS5wYXJ0aWNsZS52ZWxvY2l0eS5ob3Jpem9udGFsICo9IC1uZXdWZWxvY2l0eTtcbiAgICAgICAgICAgIGJvdW5jZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3VuY2VkKSB7XG4gICAgICAgICAgICBjb25zdCBtaW5Qb3MgPSBkYXRhLm9mZnNldC54ICsgZGF0YS5zaXplO1xuICAgICAgICAgICAgaWYgKGRhdGEuYm91bmRzLnJpZ2h0ID49IGRhdGEuY2FudmFzU2l6ZS53aWR0aCkge1xuICAgICAgICAgICAgICAgIGRhdGEucGFydGljbGUucG9zaXRpb24ueCA9IGRhdGEuY2FudmFzU2l6ZS53aWR0aCAtIG1pblBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuYm91bmRzLmxlZnQgPD0gMCkge1xuICAgICAgICAgICAgICAgIGRhdGEucGFydGljbGUucG9zaXRpb24ueCA9IG1pblBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGJvdW5jZVZlcnRpY2FsKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5vdXRNb2RlID09PSBFbnVtc18xLk91dE1vZGUuYm91bmNlIHx8XG4gICAgICAgIGRhdGEub3V0TW9kZSA9PT0gRW51bXNfMS5PdXRNb2RlLmJvdW5jZVZlcnRpY2FsIHx8XG4gICAgICAgIGRhdGEub3V0TW9kZSA9PT0gXCJib3VuY2VWZXJ0aWNhbFwiKSB7XG4gICAgICAgIGNvbnN0IHZlbG9jaXR5ID0gZGF0YS5wYXJ0aWNsZS52ZWxvY2l0eS52ZXJ0aWNhbDtcbiAgICAgICAgbGV0IGJvdW5jZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKChkYXRhLmRpcmVjdGlvbiA9PT0gT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24uYm90dG9tICYmXG4gICAgICAgICAgICBkYXRhLmJvdW5kcy5ib3R0b20gPj0gZGF0YS5jYW52YXNTaXplLmhlaWdodCAmJlxuICAgICAgICAgICAgdmVsb2NpdHkgPiAwKSB8fFxuICAgICAgICAgICAgKGRhdGEuZGlyZWN0aW9uID09PSBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi50b3AgJiYgZGF0YS5ib3VuZHMudG9wIDw9IDAgJiYgdmVsb2NpdHkgPCAwKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3VmVsb2NpdHkgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldFZhbHVlKGRhdGEucGFydGljbGUucGFydGljbGVzT3B0aW9ucy5ib3VuY2UudmVydGljYWwpO1xuICAgICAgICAgICAgZGF0YS5wYXJ0aWNsZS52ZWxvY2l0eS52ZXJ0aWNhbCAqPSAtbmV3VmVsb2NpdHk7XG4gICAgICAgICAgICBib3VuY2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm91bmNlZCkge1xuICAgICAgICAgICAgY29uc3QgbWluUG9zID0gZGF0YS5vZmZzZXQueSArIGRhdGEuc2l6ZTtcbiAgICAgICAgICAgIGlmIChkYXRhLmJvdW5kcy5ib3R0b20gPj0gZGF0YS5jYW52YXNTaXplLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGRhdGEucGFydGljbGUucG9zaXRpb24ueSA9IGRhdGEuY2FudmFzU2l6ZS5oZWlnaHQgLSBtaW5Qb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLmJvdW5kcy50b3AgPD0gMCkge1xuICAgICAgICAgICAgICAgIGRhdGEucGFydGljbGUucG9zaXRpb24ueSA9IG1pblBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRGVzdHJveShwYXJ0aWNsZSwgZGVzdHJveSwgdmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSkge1xuICAgIHN3aXRjaCAoZGVzdHJveSkge1xuICAgICAgICBjYXNlIEVudW1zXzEuRGVzdHJveVR5cGUubWF4OlxuICAgICAgICAgICAgaWYgKHZhbHVlID49IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRW51bXNfMS5EZXN0cm95VHlwZS5taW46XG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gbWluVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5jbGFzcyBVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHBhcnRpY2xlKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLnBhcnRpY2xlID0gcGFydGljbGU7XG4gICAgfVxuICAgIHVwZGF0ZShkZWx0YSkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUxpZmUoZGVsdGEpO1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZS5kZXN0cm95ZWQgfHwgdGhpcy5wYXJ0aWNsZS5zcGF3bmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlT3BhY2l0eShkZWx0YSk7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZShkZWx0YSk7XG4gICAgICAgIHRoaXMudXBkYXRlQW5nbGUoZGVsdGEpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbG9yKGRlbHRhKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHJva2VDb2xvcihkZWx0YSk7XG4gICAgICAgIHRoaXMudXBkYXRlT3V0TW9kZXMoZGVsdGEpO1xuICAgIH1cbiAgICB1cGRhdGVMaWZlKGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZTtcbiAgICAgICAgbGV0IGp1c3RTcGF3bmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXJ0aWNsZS5zcGF3bmluZykge1xuICAgICAgICAgICAgcGFydGljbGUubGlmZURlbGF5VGltZSArPSBkZWx0YS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5saWZlRGVsYXlUaW1lID49IHBhcnRpY2xlLmxpZmVEZWxheSkge1xuICAgICAgICAgICAgICAgIGp1c3RTcGF3bmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5zcGF3bmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpZmVEZWxheVRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpZmVUaW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGljbGUubGlmZUR1cmF0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFydGljbGUuc3Bhd25pbmcpIHtcbiAgICAgICAgICAgIGlmIChqdXN0U3Bhd25lZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpZmVUaW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpZmVUaW1lICs9IGRlbHRhLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnRpY2xlLmxpZmVUaW1lID49IHBhcnRpY2xlLmxpZmVEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpZmVUaW1lID0gMDtcbiAgICAgICAgICAgICAgICBpZiAocGFydGljbGUubGl2ZXNSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpdmVzUmVtYWluaW5nLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5saXZlc1JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzU2l6ZSA9IHRoaXMuY29udGFpbmVyLmNhbnZhcy5zaXplO1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnggPSBVdGlsc18xLk51bWJlclV0aWxzLnJhbmRvbUluUmFuZ2UoMCwgY2FudmFzU2l6ZS53aWR0aCk7XG4gICAgICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMucmFuZG9tSW5SYW5nZSgwLCBjYW52YXNTaXplLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgcGFydGljbGUuc3Bhd25pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpZmVEZWxheVRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpZmVUaW1lID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBsaWZlT3B0aW9ucyA9IHBhcnRpY2xlLnBhcnRpY2xlc09wdGlvbnMubGlmZTtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5saWZlRGVsYXkgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldFZhbHVlKGxpZmVPcHRpb25zLmRlbGF5KSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgcGFydGljbGUubGlmZUR1cmF0aW9uID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRWYWx1ZShsaWZlT3B0aW9ucy5kdXJhdGlvbikgKiAxMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZU9wYWNpdHkoZGVsdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlO1xuICAgICAgICBjb25zdCBvcGFjaXR5QW5pbSA9IHBhcnRpY2xlLnBhcnRpY2xlc09wdGlvbnMub3BhY2l0eS5hbmltO1xuICAgICAgICBjb25zdCBtaW5WYWx1ZSA9IG9wYWNpdHlBbmltLm1pbmltdW1WYWx1ZTtcbiAgICAgICAgY29uc3QgbWF4VmFsdWUgPSBwYXJ0aWNsZS5wYXJ0aWNsZXNPcHRpb25zLm9wYWNpdHkudmFsdWU7XG4gICAgICAgIGlmIChvcGFjaXR5QW5pbS5lbmFibGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydGljbGUub3BhY2l0eS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuQW5pbWF0aW9uU3RhdHVzLmluY3JlYXNpbmc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5vcGFjaXR5LnZhbHVlID49IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5vcGFjaXR5LnN0YXR1cyA9IEVudW1zXzEuQW5pbWF0aW9uU3RhdHVzLmRlY3JlYXNpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5vcGFjaXR5LnZhbHVlICs9ICgoX2EgPSBwYXJ0aWNsZS5vcGFjaXR5LnZlbG9jaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSAqIGRlbHRhLmZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuQW5pbWF0aW9uU3RhdHVzLmRlY3JlYXNpbmc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5vcGFjaXR5LnZhbHVlIDw9IG1pblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5vcGFjaXR5LnN0YXR1cyA9IEVudW1zXzEuQW5pbWF0aW9uU3RhdHVzLmluY3JlYXNpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5vcGFjaXR5LnZhbHVlIC09ICgoX2IgPSBwYXJ0aWNsZS5vcGFjaXR5LnZlbG9jaXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSAqIGRlbHRhLmZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrRGVzdHJveShwYXJ0aWNsZSwgb3BhY2l0eUFuaW0uZGVzdHJveSwgcGFydGljbGUub3BhY2l0eS52YWx1ZSwgbWluVmFsdWUsIG1heFZhbHVlKTtcbiAgICAgICAgICAgIGlmICghcGFydGljbGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUub3BhY2l0eS52YWx1ZSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuY2xhbXAocGFydGljbGUub3BhY2l0eS52YWx1ZSwgbWluVmFsdWUsIG1heFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTaXplKGRlbHRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGU7XG4gICAgICAgIGNvbnN0IHNpemVPcHQgPSBwYXJ0aWNsZS5wYXJ0aWNsZXNPcHRpb25zLnNpemU7XG4gICAgICAgIGNvbnN0IHNpemVBbmltID0gc2l6ZU9wdC5hbmltYXRpb247XG4gICAgICAgIGNvbnN0IHNpemVWZWxvY2l0eSA9ICgoX2EgPSBwYXJ0aWNsZS5zaXplLnZlbG9jaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSAqIGRlbHRhLmZhY3RvcjtcbiAgICAgICAgY29uc3QgbWF4VmFsdWUgPSAoX2IgPSBwYXJ0aWNsZS5zaXplVmFsdWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbnRhaW5lci5yZXRpbmEuc2l6ZVZhbHVlO1xuICAgICAgICBjb25zdCBtaW5WYWx1ZSA9IHNpemVBbmltLm1pbmltdW1WYWx1ZSAqIGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgaWYgKHNpemVBbmltLmVuYWJsZSkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0aWNsZS5zaXplLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5BbmltYXRpb25TdGF0dXMuaW5jcmVhc2luZzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpY2xlLnNpemUudmFsdWUgPj0gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnNpemUuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnNpemUudmFsdWUgKz0gc2l6ZVZlbG9jaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpY2xlLnNpemUudmFsdWUgPD0gbWluVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnNpemUuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuaW5jcmVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnNpemUudmFsdWUgLT0gc2l6ZVZlbG9jaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0Rlc3Ryb3kocGFydGljbGUsIHNpemVBbmltLmRlc3Ryb3ksIHBhcnRpY2xlLnNpemUudmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoIXBhcnRpY2xlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnNpemUudmFsdWUgPSBVdGlsc18xLk51bWJlclV0aWxzLmNsYW1wKHBhcnRpY2xlLnNpemUudmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQW5nbGUoZGVsdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGU7XG4gICAgICAgIGNvbnN0IHJvdGF0ZSA9IHBhcnRpY2xlLnBhcnRpY2xlc09wdGlvbnMucm90YXRlO1xuICAgICAgICBjb25zdCByb3RhdGVBbmltYXRpb24gPSByb3RhdGUuYW5pbWF0aW9uO1xuICAgICAgICBjb25zdCBzcGVlZCA9ICgoX2EgPSBwYXJ0aWNsZS5yb3RhdGUudmVsb2NpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICogZGVsdGEuZmFjdG9yO1xuICAgICAgICBjb25zdCBtYXggPSAyICogTWF0aC5QSTtcbiAgICAgICAgaWYgKHJvdGF0ZS5wYXRoKSB7XG4gICAgICAgICAgICBwYXJ0aWNsZS5wYXRoQW5nbGUgPSBNYXRoLmF0YW4yKHBhcnRpY2xlLnZlbG9jaXR5LnZlcnRpY2FsLCBwYXJ0aWNsZS52ZWxvY2l0eS5ob3Jpem9udGFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3RhdGVBbmltYXRpb24uZW5hYmxlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnRpY2xlLnJvdGF0ZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuQW5pbWF0aW9uU3RhdHVzLmluY3JlYXNpbmc6XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnJvdGF0ZS52YWx1ZSArPSBzcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpY2xlLnJvdGF0ZS52YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljbGUucm90YXRlLnZhbHVlIC09IG1heDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuQW5pbWF0aW9uU3RhdHVzLmRlY3JlYXNpbmc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUucm90YXRlLnZhbHVlIC09IHNwZWVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydGljbGUucm90YXRlLnZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljbGUucm90YXRlLnZhbHVlICs9IG1heDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDb2xvcihkZWx0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZTtcbiAgICAgICAgaWYgKHBhcnRpY2xlLmNvbG9yLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGljbGUucGFydGljbGVzT3B0aW9ucy5jb2xvci5hbmltYXRpb24uZW5hYmxlKSB7XG4gICAgICAgICAgICBwYXJ0aWNsZS5jb2xvci52YWx1ZS5oICs9ICgoX2EgPSBwYXJ0aWNsZS5jb2xvci52ZWxvY2l0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKiBkZWx0YS5mYWN0b3I7XG4gICAgICAgICAgICBpZiAocGFydGljbGUuY29sb3IudmFsdWUuaCA+IDM2MCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmNvbG9yLnZhbHVlLmggLT0gMzYwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0cm9rZUNvbG9yKGRlbHRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZTtcbiAgICAgICAgY29uc3QgY29sb3IgPSBwYXJ0aWNsZS5zdHJva2UuY29sb3I7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwic3RyaW5nXCIgfHwgY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWNsZS5zdHJva2VDb2xvci52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yLmFuaW1hdGlvbi5lbmFibGUpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLnN0cm9rZUNvbG9yLnZhbHVlLmggKz1cbiAgICAgICAgICAgICAgICAoKF9iID0gKF9hID0gcGFydGljbGUuc3Ryb2tlQ29sb3IudmVsb2NpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBhcnRpY2xlLmNvbG9yLnZlbG9jaXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSAqIGRlbHRhLmZhY3RvcjtcbiAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5zdHJva2VDb2xvci52YWx1ZS5oID4gMzYwKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUuc3Ryb2tlQ29sb3IudmFsdWUuaCAtPSAzNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlT3V0TW9kZXMoZGVsdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBvdXRNb2RlcyA9IHRoaXMucGFydGljbGUucGFydGljbGVzT3B0aW9ucy5tb3ZlLm91dE1vZGVzO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dE1vZGUoZGVsdGEsIChfYSA9IG91dE1vZGVzLmJvdHRvbSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3V0TW9kZXMuZGVmYXVsdCwgT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24uYm90dG9tKTtcbiAgICAgICAgdGhpcy51cGRhdGVPdXRNb2RlKGRlbHRhLCAoX2IgPSBvdXRNb2Rlcy5sZWZ0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBvdXRNb2Rlcy5kZWZhdWx0LCBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi5sZWZ0KTtcbiAgICAgICAgdGhpcy51cGRhdGVPdXRNb2RlKGRlbHRhLCAoX2MgPSBvdXRNb2Rlcy5yaWdodCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogb3V0TW9kZXMuZGVmYXVsdCwgT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24ucmlnaHQpO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dE1vZGUoZGVsdGEsIChfZCA9IG91dE1vZGVzLnRvcCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogb3V0TW9kZXMuZGVmYXVsdCwgT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24udG9wKTtcbiAgICB9XG4gICAgdXBkYXRlT3V0TW9kZShkZWx0YSwgb3V0TW9kZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGU7XG4gICAgICAgIHN3aXRjaCAob3V0TW9kZSkge1xuICAgICAgICAgICAgY2FzZSBFbnVtc18xLk91dE1vZGUuYm91bmNlOlxuICAgICAgICAgICAgY2FzZSBFbnVtc18xLk91dE1vZGUuYm91bmNlVmVydGljYWw6XG4gICAgICAgICAgICBjYXNlIEVudW1zXzEuT3V0TW9kZS5ib3VuY2VIb3Jpem9udGFsOlxuICAgICAgICAgICAgY2FzZSBcImJvdW5jZVZlcnRpY2FsXCI6XG4gICAgICAgICAgICBjYXNlIFwiYm91bmNlSG9yaXpvbnRhbFwiOlxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQm91bmNlKGRlbHRhLCBkaXJlY3Rpb24sIG91dE1vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFbnVtc18xLk91dE1vZGUuZGVzdHJveTpcbiAgICAgICAgICAgICAgICBpZiAoIVV0aWxzXzEuVXRpbHMuaXNQb2ludEluc2lkZShwYXJ0aWNsZS5wb3NpdGlvbiwgY29udGFpbmVyLmNhbnZhcy5zaXplLCBwYXJ0aWNsZS5nZXRSYWRpdXMoKSwgZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucGFydGljbGVzLnJlbW92ZShwYXJ0aWNsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFbnVtc18xLk91dE1vZGUub3V0OlxuICAgICAgICAgICAgICAgIGlmICghVXRpbHNfMS5VdGlscy5pc1BvaW50SW5zaWRlKHBhcnRpY2xlLnBvc2l0aW9uLCBjb250YWluZXIuY2FudmFzLnNpemUsIHBhcnRpY2xlLmdldFJhZGl1cygpLCBkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZml4T3V0T2ZDYW52YXNQb3NpdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRW51bXNfMS5PdXRNb2RlLm5vbmU6XG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuY2VOb25lKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZml4T3V0T2ZDYW52YXNQb3NpdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZTtcbiAgICAgICAgY29uc3Qgd3JhcCA9IHBhcnRpY2xlLnBhcnRpY2xlc09wdGlvbnMubW92ZS53YXJwO1xuICAgICAgICBjb25zdCBjYW52YXNTaXplID0gY29udGFpbmVyLmNhbnZhcy5zaXplO1xuICAgICAgICBjb25zdCBuZXdQb3MgPSB7XG4gICAgICAgICAgICBib3R0b206IGNhbnZhc1NpemUuaGVpZ2h0ICsgcGFydGljbGUuZ2V0UmFkaXVzKCkgLSBwYXJ0aWNsZS5vZmZzZXQueSxcbiAgICAgICAgICAgIGxlZnQ6IC1wYXJ0aWNsZS5nZXRSYWRpdXMoKSAtIHBhcnRpY2xlLm9mZnNldC54LFxuICAgICAgICAgICAgcmlnaHQ6IGNhbnZhc1NpemUud2lkdGggKyBwYXJ0aWNsZS5nZXRSYWRpdXMoKSArIHBhcnRpY2xlLm9mZnNldC54LFxuICAgICAgICAgICAgdG9wOiAtcGFydGljbGUuZ2V0UmFkaXVzKCkgLSBwYXJ0aWNsZS5vZmZzZXQueSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2l6ZVZhbHVlID0gcGFydGljbGUuZ2V0UmFkaXVzKCk7XG4gICAgICAgIGNvbnN0IG5leHRCb3VuZHMgPSBVdGlsc18xLlV0aWxzLmNhbGN1bGF0ZUJvdW5kcyhwYXJ0aWNsZS5wb3NpdGlvbiwgc2l6ZVZhbHVlKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24ucmlnaHQgJiYgbmV4dEJvdW5kcy5sZWZ0ID4gY2FudmFzU2l6ZS53aWR0aCAtIHBhcnRpY2xlLm9mZnNldC54KSB7XG4gICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi54ID0gbmV3UG9zLmxlZnQ7XG4gICAgICAgICAgICBpZiAoIXdyYXApIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi55ID0gTWF0aC5yYW5kb20oKSAqIGNhbnZhc1NpemUuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24ubGVmdCAmJiBuZXh0Qm91bmRzLnJpZ2h0IDwgLXBhcnRpY2xlLm9mZnNldC54KSB7XG4gICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi54ID0gbmV3UG9zLnJpZ2h0O1xuICAgICAgICAgICAgaWYgKCF3cmFwKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueSA9IE1hdGgucmFuZG9tKCkgKiBjYW52YXNTaXplLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi5ib3R0b20gJiYgbmV4dEJvdW5kcy50b3AgPiBjYW52YXNTaXplLmhlaWdodCAtIHBhcnRpY2xlLm9mZnNldC55KSB7XG4gICAgICAgICAgICBpZiAoIXdyYXApIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi54ID0gTWF0aC5yYW5kb20oKSAqIGNhbnZhc1NpemUud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi55ID0gbmV3UG9zLnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IE91dE1vZGVEaXJlY3Rpb25fMS5PdXRNb2RlRGlyZWN0aW9uLnRvcCAmJiBuZXh0Qm91bmRzLmJvdHRvbSA8IC1wYXJ0aWNsZS5vZmZzZXQueSkge1xuICAgICAgICAgICAgaWYgKCF3cmFwKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueCA9IE1hdGgucmFuZG9tKCkgKiBjYW52YXNTaXplLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueSA9IG5ld1Bvcy5ib3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQm91bmNlKGRlbHRhLCBkaXJlY3Rpb24sIG91dE1vZGUpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZTtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBbLCBwbHVnaW5dIG9mIGNvbnRhaW5lci5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLnBhcnRpY2xlQm91bmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gcGx1Z2luLnBhcnRpY2xlQm91bmNlKHBhcnRpY2xlLCBkZWx0YSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3MgPSBwYXJ0aWNsZS5nZXRQb3NpdGlvbigpLCBvZmZzZXQgPSBwYXJ0aWNsZS5vZmZzZXQsIHNpemUgPSBwYXJ0aWNsZS5nZXRSYWRpdXMoKSwgYm91bmRzID0gVXRpbHNfMS5VdGlscy5jYWxjdWxhdGVCb3VuZHMocG9zLCBzaXplKSwgY2FudmFzU2l6ZSA9IGNvbnRhaW5lci5jYW52YXMuc2l6ZTtcbiAgICAgICAgYm91bmNlSG9yaXpvbnRhbCh7IHBhcnRpY2xlLCBvdXRNb2RlLCBkaXJlY3Rpb24sIGJvdW5kcywgY2FudmFzU2l6ZSwgb2Zmc2V0LCBzaXplIH0pO1xuICAgICAgICBib3VuY2VWZXJ0aWNhbCh7IHBhcnRpY2xlLCBvdXRNb2RlLCBkaXJlY3Rpb24sIGJvdW5kcywgY2FudmFzU2l6ZSwgb2Zmc2V0LCBzaXplIH0pO1xuICAgIH1cbiAgICBib3VuY2VOb25lKGRpcmVjdGlvbikge1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGU7XG4gICAgICAgIGlmIChwYXJ0aWNsZS5wYXJ0aWNsZXNPcHRpb25zLm1vdmUuZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncmF2aXR5T3B0aW9ucyA9IHBhcnRpY2xlLnBhcnRpY2xlc09wdGlvbnMubW92ZS5ncmF2aXR5O1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKCFncmF2aXR5T3B0aW9ucy5lbmFibGUpIHtcbiAgICAgICAgICAgIGlmICghVXRpbHNfMS5VdGlscy5pc1BvaW50SW5zaWRlKHBhcnRpY2xlLnBvc2l0aW9uLCBjb250YWluZXIuY2FudmFzLnNpemUsIHBhcnRpY2xlLmdldFJhZGl1cygpLCBkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcnRpY2xlcy5yZW1vdmUocGFydGljbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwYXJ0aWNsZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGlmICgoZ3Jhdml0eU9wdGlvbnMuYWNjZWxlcmF0aW9uID49IDAgJiZcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi55ID4gY29udGFpbmVyLmNhbnZhcy5zaXplLmhlaWdodCAmJlxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24uYm90dG9tKSB8fFxuICAgICAgICAgICAgICAgIChncmF2aXR5T3B0aW9ucy5hY2NlbGVyYXRpb24gPCAwICYmIHBvc2l0aW9uLnkgPCAwICYmIGRpcmVjdGlvbiA9PT0gT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24udG9wKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5wYXJ0aWNsZXMucmVtb3ZlKHBhcnRpY2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVXBkYXRlciA9IFVwZGF0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFydGljbGVzID0gdm9pZCAwO1xuY29uc3QgUGFydGljbGVfMSA9IHJlcXVpcmUoXCIuL1BhcnRpY2xlXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9VdGlsc1wiKTtcbmNvbnN0IEludGVyYWN0aW9uTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vUGFydGljbGUvSW50ZXJhY3Rpb25NYW5hZ2VyXCIpO1xuY2xhc3MgUGFydGljbGVzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMubmV4dElkID0gMDtcbiAgICAgICAgdGhpcy5hcnJheSA9IFtdO1xuICAgICAgICB0aGlzLmxpbWl0ID0gMDtcbiAgICAgICAgdGhpcy5saW5rc0ZyZXEgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudHJpYW5nbGVzRnJlcSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIgPSBuZXcgSW50ZXJhY3Rpb25NYW5hZ2VyXzEuSW50ZXJhY3Rpb25NYW5hZ2VyKGNvbnRhaW5lcik7XG4gICAgICAgIGNvbnN0IGNhbnZhc1NpemUgPSB0aGlzLmNvbnRhaW5lci5jYW52YXMuc2l6ZTtcbiAgICAgICAgdGhpcy5saW5rc0NvbG9ycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5xdWFkVHJlZSA9IG5ldyBVdGlsc18xLlF1YWRUcmVlKG5ldyBVdGlsc18xLlJlY3RhbmdsZSgtY2FudmFzU2l6ZS53aWR0aCAvIDQsIC1jYW52YXNTaXplLmhlaWdodCAvIDQsIChjYW52YXNTaXplLndpZHRoICogMykgLyAyLCAoY2FudmFzU2l6ZS5oZWlnaHQgKiAzKSAvIDIpLCA0KTtcbiAgICB9XG4gICAgZ2V0IGNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLm9wdGlvbnM7XG4gICAgICAgIHRoaXMubGlua3NGcmVxID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlc0ZyZXEgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgcGFydGljbGUgb2Ygb3B0aW9ucy5tYW51YWxQYXJ0aWNsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHBhcnRpY2xlLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHg6IChwYXJ0aWNsZS5wb3NpdGlvbi54ICogY29udGFpbmVyLmNhbnZhcy5zaXplLndpZHRoKSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgeTogKHBhcnRpY2xlLnBvc2l0aW9uLnkgKiBjb250YWluZXIuY2FudmFzLnNpemUuaGVpZ2h0KSAvIDEwMCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmFkZFBhcnRpY2xlKHBvcywgcGFydGljbGUub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbLCBwbHVnaW5dIG9mIGNvbnRhaW5lci5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLnBhcnRpY2xlc0luaXRpYWxpemF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gcGx1Z2luLnBhcnRpY2xlc0luaXRpYWxpemF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuY291bnQ7IGkgPCBvcHRpb25zLnBhcnRpY2xlcy5udW1iZXIudmFsdWU7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUGFydGljbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbmZlY3Rpb24uZW5hYmxlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMuaW5mZWN0aW9uLmluZmVjdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdEluZmVjdGVkID0gdGhpcy5hcnJheS5maWx0ZXIoKHApID0+IHAuaW5mZWN0ZXIuaW5mZWN0aW9uU3RhZ2UgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5mZWN0ZWQgPSBVdGlsc18xLlV0aWxzLml0ZW1Gcm9tQXJyYXkobm90SW5mZWN0ZWQpO1xuICAgICAgICAgICAgICAgIGluZmVjdGVkLmluZmVjdGVyLnN0YXJ0SW5mZWN0aW9uKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLmluaXQoKTtcbiAgICAgICAgY29udGFpbmVyLm5vaXNlLmluaXQoKTtcbiAgICB9XG4gICAgcmVkcmF3KCkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLmRyYXcoeyB2YWx1ZTogMCwgZmFjdG9yOiAwIH0pO1xuICAgIH1cbiAgICByZW1vdmVBdChpbmRleCwgcXVhbnRpdHkpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gdGhpcy5jb3VudCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0aWNsZSBvZiB0aGlzLmFycmF5LnNwbGljZShpbmRleCwgcXVhbnRpdHkgIT09IG51bGwgJiYgcXVhbnRpdHkgIT09IHZvaWQgMCA/IHF1YW50aXR5IDogMSkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKHBhcnRpY2xlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXQodGhpcy5hcnJheS5pbmRleE9mKHBhcnRpY2xlKSk7XG4gICAgfVxuICAgIHVwZGF0ZShkZWx0YSkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcGFydGljbGVzVG9EZWxldGUgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLm5vaXNlLnVwZGF0ZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnRpY2xlIG9mIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLm1vdmUoZGVsdGEpO1xuICAgICAgICAgICAgaWYgKHBhcnRpY2xlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlc1RvRGVsZXRlLnB1c2gocGFydGljbGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5xdWFkVHJlZS5pbnNlcnQobmV3IFV0aWxzXzEuUG9pbnQocGFydGljbGUuZ2V0UG9zaXRpb24oKSwgcGFydGljbGUpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhcnRpY2xlIG9mIHBhcnRpY2xlc1RvRGVsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShwYXJ0aWNsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIuZXh0ZXJuYWxJbnRlcmFjdChkZWx0YSk7XG4gICAgICAgIGZvciAoY29uc3QgcGFydGljbGUgb2YgdGhpcy5jb250YWluZXIucGFydGljbGVzLmFycmF5KSB7XG4gICAgICAgICAgICBwYXJ0aWNsZS51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgaWYgKCFwYXJ0aWNsZS5kZXN0cm95ZWQgJiYgIXBhcnRpY2xlLnNwYXduaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIucGFydGljbGVzSW50ZXJhY3QocGFydGljbGUsIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3KGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb250YWluZXIuY2FudmFzLmNsZWFyKCk7XG4gICAgICAgIGNvbnN0IGNhbnZhc1NpemUgPSB0aGlzLmNvbnRhaW5lci5jYW52YXMuc2l6ZTtcbiAgICAgICAgdGhpcy5xdWFkVHJlZSA9IG5ldyBVdGlsc18xLlF1YWRUcmVlKG5ldyBVdGlsc18xLlJlY3RhbmdsZSgtY2FudmFzU2l6ZS53aWR0aCAvIDQsIC1jYW52YXNTaXplLmhlaWdodCAvIDQsIChjYW52YXNTaXplLndpZHRoICogMykgLyAyLCAoY2FudmFzU2l6ZS5oZWlnaHQgKiAzKSAvIDIpLCA0KTtcbiAgICAgICAgdGhpcy51cGRhdGUoZGVsdGEpO1xuICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgY29udGFpbmVyLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jYW52YXMuZHJhd1BsdWdpbihwbHVnaW4sIGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5hcnJheSkge1xuICAgICAgICAgICAgcC5kcmF3KGRlbHRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IFtdO1xuICAgIH1cbiAgICBwdXNoKG5iLCBtb3VzZSwgb3ZlcnJpZGVPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5wYXJ0aWNsZXMubnVtYmVyLmxpbWl0ICogY29udGFpbmVyLmRlbnNpdHk7XG4gICAgICAgIHRoaXMucHVzaGluZyA9IHRydWU7XG4gICAgICAgIGlmIChsaW1pdCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50VG9SZW1vdmUgPSB0aGlzLmNvdW50ICsgbmIgLSBsaW1pdDtcbiAgICAgICAgICAgIGlmIChjb3VudFRvUmVtb3ZlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUXVhbnRpdHkoY291bnRUb1JlbW92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFBhcnRpY2xlKG1vdXNlID09PSBudWxsIHx8IG1vdXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3VzZS5wb3NpdGlvbiwgb3ZlcnJpZGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgYWRkUGFydGljbGUocG9zaXRpb24sIG92ZXJyaWRlT3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFydGljbGUgPSBuZXcgUGFydGljbGVfMS5QYXJ0aWNsZSh0aGlzLm5leHRJZCwgdGhpcy5jb250YWluZXIsIHBvc2l0aW9uLCBvdmVycmlkZU9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5hcnJheS5wdXNoKHBhcnRpY2xlKTtcbiAgICAgICAgICAgIHRoaXMubmV4dElkKys7XG4gICAgICAgICAgICByZXR1cm4gcGFydGljbGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJlcnJvciBhZGRpbmcgcGFydGljbGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlUXVhbnRpdHkocXVhbnRpdHkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdCgwLCBxdWFudGl0eSk7XG4gICAgfVxuICAgIGdldExpbmtGcmVxdWVuY3kocDEsIHAyKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGAke01hdGgubWluKHAxLmlkLCBwMi5pZCl9XyR7TWF0aC5tYXgocDEuaWQsIHAyLmlkKX1gO1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5saW5rc0ZyZXEuZ2V0KGtleSk7XG4gICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIHRoaXMubGlua3NGcmVxLnNldChrZXksIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZ2V0VHJpYW5nbGVGcmVxdWVuY3kocDEsIHAyLCBwMykge1xuICAgICAgICBsZXQgW2lkMSwgaWQyLCBpZDNdID0gW3AxLmlkLCBwMi5pZCwgcDMuaWRdO1xuICAgICAgICBpZiAoaWQxID4gaWQyKSB7XG4gICAgICAgICAgICBbaWQyLCBpZDFdID0gW2lkMSwgaWQyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQyID4gaWQzKSB7XG4gICAgICAgICAgICBbaWQzLCBpZDJdID0gW2lkMiwgaWQzXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQxID4gaWQzKSB7XG4gICAgICAgICAgICBbaWQzLCBpZDFdID0gW2lkMSwgaWQzXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBgJHtpZDF9XyR7aWQyfV8ke2lkM31gO1xuICAgICAgICBsZXQgcmVzID0gdGhpcy50cmlhbmdsZXNGcmVxLmdldChrZXkpO1xuICAgICAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcyA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlc0ZyZXEuc2V0KGtleSwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBzZXREZW5zaXR5KCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb250YWluZXIub3B0aW9ucztcbiAgICAgICAgdGhpcy5hcHBseURlbnNpdHkob3B0aW9ucy5wYXJ0aWNsZXMpO1xuICAgIH1cbiAgICBhcHBseURlbnNpdHkob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghKChfYSA9IG9wdGlvbnMubnVtYmVyLmRlbnNpdHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmFibGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVtYmVyT3B0aW9ucyA9IG9wdGlvbnMubnVtYmVyO1xuICAgICAgICBjb25zdCBkZW5zaXR5RmFjdG9yID0gdGhpcy5pbml0RGVuc2l0eUZhY3RvcihudW1iZXJPcHRpb25zLmRlbnNpdHkpO1xuICAgICAgICBjb25zdCBvcHRQYXJ0aWNsZXNOdW1iZXIgPSBudW1iZXJPcHRpb25zLnZhbHVlO1xuICAgICAgICBjb25zdCBvcHRQYXJ0aWNsZXNMaW1pdCA9IG51bWJlck9wdGlvbnMubGltaXQgPiAwID8gbnVtYmVyT3B0aW9ucy5saW1pdCA6IG9wdFBhcnRpY2xlc051bWJlcjtcbiAgICAgICAgY29uc3QgcGFydGljbGVzTnVtYmVyID0gTWF0aC5taW4ob3B0UGFydGljbGVzTnVtYmVyLCBvcHRQYXJ0aWNsZXNMaW1pdCkgKiBkZW5zaXR5RmFjdG9yO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZXNDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgIHRoaXMubGltaXQgPSBudW1iZXJPcHRpb25zLmxpbWl0ICogZGVuc2l0eUZhY3RvcjtcbiAgICAgICAgaWYgKHBhcnRpY2xlc0NvdW50IDwgcGFydGljbGVzTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2goTWF0aC5hYnMocGFydGljbGVzTnVtYmVyIC0gcGFydGljbGVzQ291bnQpLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnRpY2xlc0NvdW50ID4gcGFydGljbGVzTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVF1YW50aXR5KHBhcnRpY2xlc0NvdW50IC0gcGFydGljbGVzTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0RGVuc2l0eUZhY3RvcihkZW5zaXR5T3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKCFjb250YWluZXIuY2FudmFzLmVsZW1lbnQgfHwgIWRlbnNpdHlPcHRpb25zLmVuYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FudmFzID0gY29udGFpbmVyLmNhbnZhcy5lbGVtZW50O1xuICAgICAgICBjb25zdCBweFJhdGlvID0gY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvO1xuICAgICAgICByZXR1cm4gKGNhbnZhcy53aWR0aCAqIGNhbnZhcy5oZWlnaHQpIC8gKGRlbnNpdHlPcHRpb25zLmZhY3RvciAqIHB4UmF0aW8gKiBweFJhdGlvICogZGVuc2l0eU9wdGlvbnMuYXJlYSk7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJ0aWNsZXMgPSBQYXJ0aWNsZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmV0aW5hID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9VdGlsc1wiKTtcbmNsYXNzIFJldGluYSB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEpIHtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IFV0aWxzXzEuVXRpbHMuaXNTc3IoKSA/IDEgOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW90aW9uT3B0aW9ucyA9IHRoaXMuY29udGFpbmVyLm9wdGlvbnMubW90aW9uO1xuICAgICAgICBpZiAobW90aW9uT3B0aW9ucyAmJiAobW90aW9uT3B0aW9ucy5kaXNhYmxlIHx8IG1vdGlvbk9wdGlvbnMucmVkdWNlLnZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKFV0aWxzXzEuVXRpbHMuaXNTc3IoKSB8fCB0eXBlb2YgbWF0Y2hNZWRpYSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhbWF0Y2hNZWRpYSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVkdWNlRmFjdG9yID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lZGlhUXVlcnkgPSBtYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIik7XG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3Rpb25DaGFuZ2UobWVkaWFRdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW90aW9uQ2hhbmdlKG1lZGlhUXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnJlZnJlc2goKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lZGlhUXVlcnkuYWRkRXZlbnRMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYVF1ZXJ5LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZWRpYVF1ZXJ5LmFkZExpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhUXVlcnkuYWRkTGlzdGVuZXIoaGFuZGxlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlRmFjdG9yID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgaWYgKGNvbnRhaW5lci5jYW52YXMuZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGNvbnRhaW5lci5jYW52YXMuZWxlbWVudDtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jYW52YXMuc2l6ZS53aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggKiByYXRpbztcbiAgICAgICAgICAgIGNvbnRhaW5lci5jYW52YXMuc2l6ZS5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAqIHJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlcyA9IG9wdGlvbnMucGFydGljbGVzO1xuICAgICAgICB0aGlzLmxpbmtzRGlzdGFuY2UgPSBwYXJ0aWNsZXMubGlua3MuZGlzdGFuY2UgKiByYXRpbztcbiAgICAgICAgdGhpcy5saW5rc1dpZHRoID0gcGFydGljbGVzLmxpbmtzLndpZHRoICogcmF0aW87XG4gICAgICAgIHRoaXMubW92ZVNwZWVkID0gcGFydGljbGVzLm1vdmUuc3BlZWQgKiByYXRpbztcbiAgICAgICAgdGhpcy5zaXplVmFsdWUgPSBwYXJ0aWNsZXMuc2l6ZS52YWx1ZSAqIHJhdGlvO1xuICAgICAgICB0aGlzLnNpemVBbmltYXRpb25TcGVlZCA9IHBhcnRpY2xlcy5zaXplLmFuaW1hdGlvbi5zcGVlZCAqIHJhdGlvO1xuICAgICAgICBjb25zdCBtb2RlcyA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2RlcztcbiAgICAgICAgdGhpcy5jb25uZWN0TW9kZURpc3RhbmNlID0gbW9kZXMuY29ubmVjdC5kaXN0YW5jZSAqIHJhdGlvO1xuICAgICAgICB0aGlzLmNvbm5lY3RNb2RlUmFkaXVzID0gbW9kZXMuY29ubmVjdC5yYWRpdXMgKiByYXRpbztcbiAgICAgICAgdGhpcy5ncmFiTW9kZURpc3RhbmNlID0gbW9kZXMuZ3JhYi5kaXN0YW5jZSAqIHJhdGlvO1xuICAgICAgICB0aGlzLnJlcHVsc2VNb2RlRGlzdGFuY2UgPSBtb2Rlcy5yZXB1bHNlLmRpc3RhbmNlICogcmF0aW87XG4gICAgICAgIHRoaXMuYm91bmNlTW9kZURpc3RhbmNlID0gbW9kZXMuYm91bmNlLmRpc3RhbmNlICogcmF0aW87XG4gICAgICAgIHRoaXMuYXR0cmFjdE1vZGVEaXN0YW5jZSA9IG1vZGVzLmF0dHJhY3QuZGlzdGFuY2UgKiByYXRpbztcbiAgICAgICAgdGhpcy5zbG93TW9kZVJhZGl1cyA9IG1vZGVzLnNsb3cucmFkaXVzICogcmF0aW87XG4gICAgICAgIHRoaXMuYnViYmxlTW9kZURpc3RhbmNlID0gbW9kZXMuYnViYmxlLmRpc3RhbmNlICogcmF0aW87XG4gICAgICAgIGlmIChtb2Rlcy5idWJibGUuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5idWJibGVNb2RlU2l6ZSA9IG1vZGVzLmJ1YmJsZS5zaXplICogcmF0aW87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdFBhcnRpY2xlKHBhcnRpY2xlKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlc09wdGlvbnMgPSBwYXJ0aWNsZS5wYXJ0aWNsZXNPcHRpb25zO1xuICAgICAgICBjb25zdCByYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgcGFydGljbGUubGlua3NEaXN0YW5jZSA9IHBhcnRpY2xlc09wdGlvbnMubGlua3MuZGlzdGFuY2UgKiByYXRpbztcbiAgICAgICAgcGFydGljbGUubGlua3NXaWR0aCA9IHBhcnRpY2xlc09wdGlvbnMubGlua3Mud2lkdGggKiByYXRpbztcbiAgICAgICAgcGFydGljbGUubW92ZVNwZWVkID0gcGFydGljbGVzT3B0aW9ucy5tb3ZlLnNwZWVkICogcmF0aW87XG4gICAgICAgIHBhcnRpY2xlLnNpemVWYWx1ZSA9IHBhcnRpY2xlc09wdGlvbnMuc2l6ZS52YWx1ZSAqIHJhdGlvO1xuICAgICAgICBwYXJ0aWNsZS5zaXplQW5pbWF0aW9uU3BlZWQgPSBwYXJ0aWNsZXNPcHRpb25zLnNpemUuYW5pbWF0aW9uLnNwZWVkICogcmF0aW87XG4gICAgICAgIHBhcnRpY2xlLm1heERpc3RhbmNlID0gcGFydGljbGVzT3B0aW9ucy5tb3ZlLmRpc3RhbmNlICogcmF0aW87XG4gICAgfVxuICAgIGhhbmRsZU1vdGlvbkNoYW5nZShtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBpZiAobWVkaWFRdWVyeS5tYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBtb3Rpb24gPSBvcHRpb25zLm1vdGlvbjtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlRmFjdG9yID0gbW90aW9uLmRpc2FibGUgPyAwIDogbW90aW9uLnJlZHVjZS52YWx1ZSA/IDEgLyBtb3Rpb24ucmVkdWNlLmZhY3RvciA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZHVjZUZhY3RvciA9IDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJldGluYSA9IFJldGluYTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbmltYXRpb25TdGF0dXMgPSB2b2lkIDA7XG52YXIgQW5pbWF0aW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChBbmltYXRpb25TdGF0dXMpIHtcbiAgICBBbmltYXRpb25TdGF0dXNbQW5pbWF0aW9uU3RhdHVzW1wiaW5jcmVhc2luZ1wiXSA9IDBdID0gXCJpbmNyZWFzaW5nXCI7XG4gICAgQW5pbWF0aW9uU3RhdHVzW0FuaW1hdGlvblN0YXR1c1tcImRlY3JlYXNpbmdcIl0gPSAxXSA9IFwiZGVjcmVhc2luZ1wiO1xufSkoQW5pbWF0aW9uU3RhdHVzID0gZXhwb3J0cy5BbmltYXRpb25TdGF0dXMgfHwgKGV4cG9ydHMuQW5pbWF0aW9uU3RhdHVzID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Nb3ZlRGlyZWN0aW9uID0gdm9pZCAwO1xudmFyIE1vdmVEaXJlY3Rpb247XG4oZnVuY3Rpb24gKE1vdmVEaXJlY3Rpb24pIHtcbiAgICBNb3ZlRGlyZWN0aW9uW1wiYm90dG9tXCJdID0gXCJib3R0b21cIjtcbiAgICBNb3ZlRGlyZWN0aW9uW1wiYm90dG9tTGVmdFwiXSA9IFwiYm90dG9tLWxlZnRcIjtcbiAgICBNb3ZlRGlyZWN0aW9uW1wiYm90dG9tUmlnaHRcIl0gPSBcImJvdHRvbS1yaWdodFwiO1xuICAgIE1vdmVEaXJlY3Rpb25bXCJsZWZ0XCJdID0gXCJsZWZ0XCI7XG4gICAgTW92ZURpcmVjdGlvbltcIm5vbmVcIl0gPSBcIm5vbmVcIjtcbiAgICBNb3ZlRGlyZWN0aW9uW1wicmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gICAgTW92ZURpcmVjdGlvbltcInRvcFwiXSA9IFwidG9wXCI7XG4gICAgTW92ZURpcmVjdGlvbltcInRvcExlZnRcIl0gPSBcInRvcC1sZWZ0XCI7XG4gICAgTW92ZURpcmVjdGlvbltcInRvcFJpZ2h0XCJdID0gXCJ0b3AtcmlnaHRcIjtcbn0pKE1vdmVEaXJlY3Rpb24gPSBleHBvcnRzLk1vdmVEaXJlY3Rpb24gfHwgKGV4cG9ydHMuTW92ZURpcmVjdGlvbiA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3V0TW9kZURpcmVjdGlvbiA9IHZvaWQgMDtcbnZhciBPdXRNb2RlRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChPdXRNb2RlRGlyZWN0aW9uKSB7XG4gICAgT3V0TW9kZURpcmVjdGlvbltcImJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG4gICAgT3V0TW9kZURpcmVjdGlvbltcImxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBPdXRNb2RlRGlyZWN0aW9uW1wicmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gICAgT3V0TW9kZURpcmVjdGlvbltcInRvcFwiXSA9IFwidG9wXCI7XG59KShPdXRNb2RlRGlyZWN0aW9uID0gZXhwb3J0cy5PdXRNb2RlRGlyZWN0aW9uIHx8IChleHBvcnRzLk91dE1vZGVEaXJlY3Rpb24gPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJvdGF0ZURpcmVjdGlvbiA9IHZvaWQgMDtcbnZhciBSb3RhdGVEaXJlY3Rpb247XG4oZnVuY3Rpb24gKFJvdGF0ZURpcmVjdGlvbikge1xuICAgIFJvdGF0ZURpcmVjdGlvbltcImNsb2Nrd2lzZVwiXSA9IFwiY2xvY2t3aXNlXCI7XG4gICAgUm90YXRlRGlyZWN0aW9uW1wiY291bnRlckNsb2Nrd2lzZVwiXSA9IFwiY291bnRlci1jbG9ja3dpc2VcIjtcbiAgICBSb3RhdGVEaXJlY3Rpb25bXCJyYW5kb21cIl0gPSBcInJhbmRvbVwiO1xufSkoUm90YXRlRGlyZWN0aW9uID0gZXhwb3J0cy5Sb3RhdGVEaXJlY3Rpb24gfHwgKGV4cG9ydHMuUm90YXRlRGlyZWN0aW9uID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTW92ZURpcmVjdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUm90YXRlRGlyZWN0aW9uXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnRlcmFjdGl2aXR5RGV0ZWN0ID0gdm9pZCAwO1xudmFyIEludGVyYWN0aXZpdHlEZXRlY3Q7XG4oZnVuY3Rpb24gKEludGVyYWN0aXZpdHlEZXRlY3QpIHtcbiAgICBJbnRlcmFjdGl2aXR5RGV0ZWN0W1wiY2FudmFzXCJdID0gXCJjYW52YXNcIjtcbiAgICBJbnRlcmFjdGl2aXR5RGV0ZWN0W1wicGFyZW50XCJdID0gXCJwYXJlbnRcIjtcbiAgICBJbnRlcmFjdGl2aXR5RGV0ZWN0W1wid2luZG93XCJdID0gXCJ3aW5kb3dcIjtcbn0pKEludGVyYWN0aXZpdHlEZXRlY3QgPSBleHBvcnRzLkludGVyYWN0aXZpdHlEZXRlY3QgfHwgKGV4cG9ydHMuSW50ZXJhY3Rpdml0eURldGVjdCA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpY2tNb2RlID0gdm9pZCAwO1xudmFyIENsaWNrTW9kZTtcbihmdW5jdGlvbiAoQ2xpY2tNb2RlKSB7XG4gICAgQ2xpY2tNb2RlW1wiYXR0cmFjdFwiXSA9IFwiYXR0cmFjdFwiO1xuICAgIENsaWNrTW9kZVtcImJ1YmJsZVwiXSA9IFwiYnViYmxlXCI7XG4gICAgQ2xpY2tNb2RlW1wicHVzaFwiXSA9IFwicHVzaFwiO1xuICAgIENsaWNrTW9kZVtcInJlbW92ZVwiXSA9IFwicmVtb3ZlXCI7XG4gICAgQ2xpY2tNb2RlW1wicmVwdWxzZVwiXSA9IFwicmVwdWxzZVwiO1xuICAgIENsaWNrTW9kZVtcInBhdXNlXCJdID0gXCJwYXVzZVwiO1xuICAgIENsaWNrTW9kZVtcInRyYWlsXCJdID0gXCJ0cmFpbFwiO1xufSkoQ2xpY2tNb2RlID0gZXhwb3J0cy5DbGlja01vZGUgfHwgKGV4cG9ydHMuQ2xpY2tNb2RlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2xsaXNpb25Nb2RlID0gdm9pZCAwO1xudmFyIENvbGxpc2lvbk1vZGU7XG4oZnVuY3Rpb24gKENvbGxpc2lvbk1vZGUpIHtcbiAgICBDb2xsaXNpb25Nb2RlW1wiYWJzb3JiXCJdID0gXCJhYnNvcmJcIjtcbiAgICBDb2xsaXNpb25Nb2RlW1wiYm91bmNlXCJdID0gXCJib3VuY2VcIjtcbiAgICBDb2xsaXNpb25Nb2RlW1wiZGVzdHJveVwiXSA9IFwiZGVzdHJveVwiO1xufSkoQ29sbGlzaW9uTW9kZSA9IGV4cG9ydHMuQ29sbGlzaW9uTW9kZSB8fCAoZXhwb3J0cy5Db2xsaXNpb25Nb2RlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXZNb2RlID0gdm9pZCAwO1xudmFyIERpdk1vZGU7XG4oZnVuY3Rpb24gKERpdk1vZGUpIHtcbiAgICBEaXZNb2RlW1wiYm91bmNlXCJdID0gXCJib3VuY2VcIjtcbiAgICBEaXZNb2RlW1wiYnViYmxlXCJdID0gXCJidWJibGVcIjtcbiAgICBEaXZNb2RlW1wicmVwdWxzZVwiXSA9IFwicmVwdWxzZVwiO1xufSkoRGl2TW9kZSA9IGV4cG9ydHMuRGl2TW9kZSB8fCAoZXhwb3J0cy5EaXZNb2RlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ib3Zlck1vZGUgPSB2b2lkIDA7XG52YXIgSG92ZXJNb2RlO1xuKGZ1bmN0aW9uIChIb3Zlck1vZGUpIHtcbiAgICBIb3Zlck1vZGVbXCJhdHRyYWN0XCJdID0gXCJhdHRyYWN0XCI7XG4gICAgSG92ZXJNb2RlW1wiYm91bmNlXCJdID0gXCJib3VuY2VcIjtcbiAgICBIb3Zlck1vZGVbXCJidWJibGVcIl0gPSBcImJ1YmJsZVwiO1xuICAgIEhvdmVyTW9kZVtcImNvbm5lY3RcIl0gPSBcImNvbm5lY3RcIjtcbiAgICBIb3Zlck1vZGVbXCJncmFiXCJdID0gXCJncmFiXCI7XG4gICAgSG92ZXJNb2RlW1wibGlnaHRcIl0gPSBcImxpZ2h0XCI7XG4gICAgSG92ZXJNb2RlW1wicmVwdWxzZVwiXSA9IFwicmVwdWxzZVwiO1xuICAgIEhvdmVyTW9kZVtcInNsb3dcIl0gPSBcInNsb3dcIjtcbiAgICBIb3Zlck1vZGVbXCJ0cmFpbFwiXSA9IFwidHJhaWxcIjtcbn0pKEhvdmVyTW9kZSA9IGV4cG9ydHMuSG92ZXJNb2RlIHx8IChleHBvcnRzLkhvdmVyTW9kZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3V0TW9kZSA9IHZvaWQgMDtcbnZhciBPdXRNb2RlO1xuKGZ1bmN0aW9uIChPdXRNb2RlKSB7XG4gICAgT3V0TW9kZVtcImJvdW5jZVwiXSA9IFwiYm91bmNlXCI7XG4gICAgT3V0TW9kZVtcImJvdW5jZUhvcml6b250YWxcIl0gPSBcImJvdW5jZS1ob3Jpem9udGFsXCI7XG4gICAgT3V0TW9kZVtcImJvdW5jZVZlcnRpY2FsXCJdID0gXCJib3VuY2UtdmVydGljYWxcIjtcbiAgICBPdXRNb2RlW1wibm9uZVwiXSA9IFwibm9uZVwiO1xuICAgIE91dE1vZGVbXCJvdXRcIl0gPSBcIm91dFwiO1xuICAgIE91dE1vZGVbXCJkZXN0cm95XCJdID0gXCJkZXN0cm95XCI7XG59KShPdXRNb2RlID0gZXhwb3J0cy5PdXRNb2RlIHx8IChleHBvcnRzLk91dE1vZGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpemVNb2RlID0gdm9pZCAwO1xudmFyIFNpemVNb2RlO1xuKGZ1bmN0aW9uIChTaXplTW9kZSkge1xuICAgIFNpemVNb2RlW1wicHJlY2lzZVwiXSA9IFwicHJlY2lzZVwiO1xuICAgIFNpemVNb2RlW1wicGVyY2VudFwiXSA9IFwicGVyY2VudFwiO1xufSkoU2l6ZU1vZGUgPSBleHBvcnRzLlNpemVNb2RlIHx8IChleHBvcnRzLlNpemVNb2RlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UaGVtZU1vZGUgPSB2b2lkIDA7XG52YXIgVGhlbWVNb2RlO1xuKGZ1bmN0aW9uIChUaGVtZU1vZGUpIHtcbiAgICBUaGVtZU1vZGVbXCJhbnlcIl0gPSBcImFueVwiO1xuICAgIFRoZW1lTW9kZVtcImRhcmtcIl0gPSBcImRhcmtcIjtcbiAgICBUaGVtZU1vZGVbXCJsaWdodFwiXSA9IFwibGlnaHRcIjtcbn0pKFRoZW1lTW9kZSA9IGV4cG9ydHMuVGhlbWVNb2RlIHx8IChleHBvcnRzLlRoZW1lTW9kZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NsaWNrTW9kZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGl2TW9kZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vSG92ZXJNb2RlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db2xsaXNpb25Nb2RlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9PdXRNb2RlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TaXplTW9kZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVGhlbWVNb2RlXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGlyZWN0aW9uc1wiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL01vZGVzXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2x5Z29uTWFza0lubGluZUFycmFuZ2VtZW50ID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi9QbHVnaW5zL1BvbHlnb25NYXNrL0VudW1zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9seWdvbk1hc2tJbmxpbmVBcnJhbmdlbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRW51bXNfMS5JbmxpbmVBcnJhbmdlbWVudDsgfSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2x5Z29uTWFza01vdmVUeXBlID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi9QbHVnaW5zL1BvbHlnb25NYXNrL0VudW1zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9seWdvbk1hc2tNb3ZlVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRW51bXNfMS5Nb3ZlVHlwZTsgfSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2x5Z29uTWFza1R5cGUgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uL1BsdWdpbnMvUG9seWdvbk1hc2svRW51bXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQb2x5Z29uTWFza1R5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEVudW1zXzEuVHlwZTsgfSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVHlwZXNcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9EaXJlY3Rpb25zXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVHlwZXNcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlc3Ryb3lUeXBlID0gdm9pZCAwO1xudmFyIERlc3Ryb3lUeXBlO1xuKGZ1bmN0aW9uIChEZXN0cm95VHlwZSkge1xuICAgIERlc3Ryb3lUeXBlW1wibm9uZVwiXSA9IFwibm9uZVwiO1xuICAgIERlc3Ryb3lUeXBlW1wibWF4XCJdID0gXCJtYXhcIjtcbiAgICBEZXN0cm95VHlwZVtcIm1pblwiXSA9IFwibWluXCI7XG59KShEZXN0cm95VHlwZSA9IGV4cG9ydHMuRGVzdHJveVR5cGUgfHwgKGV4cG9ydHMuRGVzdHJveVR5cGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpdlR5cGUgPSB2b2lkIDA7XG52YXIgRGl2VHlwZTtcbihmdW5jdGlvbiAoRGl2VHlwZSkge1xuICAgIERpdlR5cGVbXCJjaXJjbGVcIl0gPSBcImNpcmNsZVwiO1xuICAgIERpdlR5cGVbXCJyZWN0YW5nbGVcIl0gPSBcInJlY3RhbmdsZVwiO1xufSkoRGl2VHlwZSA9IGV4cG9ydHMuRGl2VHlwZSB8fCAoZXhwb3J0cy5EaXZUeXBlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9jZXNzQnViYmxlVHlwZSA9IHZvaWQgMDtcbnZhciBQcm9jZXNzQnViYmxlVHlwZTtcbihmdW5jdGlvbiAoUHJvY2Vzc0J1YmJsZVR5cGUpIHtcbiAgICBQcm9jZXNzQnViYmxlVHlwZVtcImNvbG9yXCJdID0gXCJjb2xvclwiO1xuICAgIFByb2Nlc3NCdWJibGVUeXBlW1wib3BhY2l0eVwiXSA9IFwib3BhY2l0eVwiO1xuICAgIFByb2Nlc3NCdWJibGVUeXBlW1wic2l6ZVwiXSA9IFwic2l6ZVwiO1xufSkoUHJvY2Vzc0J1YmJsZVR5cGUgPSBleHBvcnRzLlByb2Nlc3NCdWJibGVUeXBlIHx8IChleHBvcnRzLlByb2Nlc3NCdWJibGVUeXBlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaGFwZVR5cGUgPSB2b2lkIDA7XG52YXIgU2hhcGVUeXBlO1xuKGZ1bmN0aW9uIChTaGFwZVR5cGUpIHtcbiAgICBTaGFwZVR5cGVbXCJjaGFyXCJdID0gXCJjaGFyXCI7XG4gICAgU2hhcGVUeXBlW1wiY2hhcmFjdGVyXCJdID0gXCJjaGFyYWN0ZXJcIjtcbiAgICBTaGFwZVR5cGVbXCJjaXJjbGVcIl0gPSBcImNpcmNsZVwiO1xuICAgIFNoYXBlVHlwZVtcImVkZ2VcIl0gPSBcImVkZ2VcIjtcbiAgICBTaGFwZVR5cGVbXCJpbWFnZVwiXSA9IFwiaW1hZ2VcIjtcbiAgICBTaGFwZVR5cGVbXCJpbWFnZXNcIl0gPSBcImltYWdlc1wiO1xuICAgIFNoYXBlVHlwZVtcImxpbmVcIl0gPSBcImxpbmVcIjtcbiAgICBTaGFwZVR5cGVbXCJwb2x5Z29uXCJdID0gXCJwb2x5Z29uXCI7XG4gICAgU2hhcGVUeXBlW1wic3F1YXJlXCJdID0gXCJzcXVhcmVcIjtcbiAgICBTaGFwZVR5cGVbXCJzdGFyXCJdID0gXCJzdGFyXCI7XG4gICAgU2hhcGVUeXBlW1widHJpYW5nbGVcIl0gPSBcInRyaWFuZ2xlXCI7XG59KShTaGFwZVR5cGUgPSBleHBvcnRzLlNoYXBlVHlwZSB8fCAoZXhwb3J0cy5TaGFwZVR5cGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YXJ0VmFsdWVUeXBlID0gdm9pZCAwO1xudmFyIFN0YXJ0VmFsdWVUeXBlO1xuKGZ1bmN0aW9uIChTdGFydFZhbHVlVHlwZSkge1xuICAgIFN0YXJ0VmFsdWVUeXBlW1wibWF4XCJdID0gXCJtYXhcIjtcbiAgICBTdGFydFZhbHVlVHlwZVtcIm1pblwiXSA9IFwibWluXCI7XG4gICAgU3RhcnRWYWx1ZVR5cGVbXCJyYW5kb21cIl0gPSBcInJhbmRvbVwiO1xufSkoU3RhcnRWYWx1ZVR5cGUgPSBleHBvcnRzLlN0YXJ0VmFsdWVUeXBlIHx8IChleHBvcnRzLlN0YXJ0VmFsdWVUeXBlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGVzdHJveVR5cGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1Byb2Nlc3NCdWJibGVUeXBlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TaGFwZVR5cGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1N0YXJ0VmFsdWVUeXBlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9EaXZUeXBlXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGlyZWN0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTW9kZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0FuaW1hdGlvblN0YXR1c1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVHlwZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0ludGVyYWN0aXZpdHlEZXRlY3RcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF0dHJhY3RvciA9IHZvaWQgMDtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXNcIik7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY2xhc3MgQXR0cmFjdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIub3B0aW9ucztcbiAgICAgICAgY29uc3QgbW91c2UgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cztcbiAgICAgICAgaWYgKCEoKGV2ZW50cy5vbkhvdmVyLmVuYWJsZSAmJiBtb3VzZS5wb3NpdGlvbikgfHwgKGV2ZW50cy5vbkNsaWNrLmVuYWJsZSAmJiBtb3VzZS5jbGlja1Bvc2l0aW9uKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3Zlck1vZGUgPSBldmVudHMub25Ib3Zlci5tb2RlO1xuICAgICAgICBjb25zdCBjbGlja01vZGUgPSBldmVudHMub25DbGljay5tb2RlO1xuICAgICAgICByZXR1cm4gVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoRW51bXNfMS5Ib3Zlck1vZGUuYXR0cmFjdCwgaG92ZXJNb2RlKSB8fCBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkNsaWNrTW9kZS5hdHRyYWN0LCBjbGlja01vZGUpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICB9XG4gICAgaW50ZXJhY3QoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1vdXNlTW92ZVN0YXR1cyA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5LnN0YXR1cyA9PT0gVXRpbHNfMS5Db25zdGFudHMubW91c2VNb3ZlRXZlbnQ7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHM7XG4gICAgICAgIGNvbnN0IGhvdmVyRW5hYmxlZCA9IGV2ZW50cy5vbkhvdmVyLmVuYWJsZTtcbiAgICAgICAgY29uc3QgaG92ZXJNb2RlID0gZXZlbnRzLm9uSG92ZXIubW9kZTtcbiAgICAgICAgY29uc3QgY2xpY2tFbmFibGVkID0gZXZlbnRzLm9uQ2xpY2suZW5hYmxlO1xuICAgICAgICBjb25zdCBjbGlja01vZGUgPSBldmVudHMub25DbGljay5tb2RlO1xuICAgICAgICBpZiAobW91c2VNb3ZlU3RhdHVzICYmIGhvdmVyRW5hYmxlZCAmJiBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkhvdmVyTW9kZS5hdHRyYWN0LCBob3Zlck1vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmhvdmVyQXR0cmFjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsaWNrRW5hYmxlZCAmJiBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkNsaWNrTW9kZS5hdHRyYWN0LCBjbGlja01vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrQXR0cmFjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhvdmVyQXR0cmFjdCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG1vdXNlUG9zID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UucG9zaXRpb247XG4gICAgICAgIGlmICghbW91c2VQb3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdHRyYWN0UmFkaXVzID0gY29udGFpbmVyLnJldGluYS5hdHRyYWN0TW9kZURpc3RhbmNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NBdHRyYWN0KG1vdXNlUG9zLCBhdHRyYWN0UmFkaXVzLCBuZXcgVXRpbHNfMS5DaXJjbGUobW91c2VQb3MueCwgbW91c2VQb3MueSwgYXR0cmFjdFJhZGl1cykpO1xuICAgIH1cbiAgICBwcm9jZXNzQXR0cmFjdChwb3NpdGlvbiwgYXR0cmFjdFJhZGl1cywgYXJlYSkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBjb250YWluZXIucGFydGljbGVzLnF1YWRUcmVlLnF1ZXJ5KGFyZWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnRpY2xlIG9mIHF1ZXJ5KSB7XG4gICAgICAgICAgICBjb25zdCB7IGR4LCBkeSwgZGlzdGFuY2UgfSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2VzKHBhcnRpY2xlLnBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgICAgICBjb25zdCBub3JtVmVjID0ge1xuICAgICAgICAgICAgICAgIHg6IGR4IC8gZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgeTogZHkgLyBkaXN0YW5jZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IGNvbnRhaW5lci5vcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMuYXR0cmFjdC5zcGVlZDtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJhY3RGYWN0b3IgPSBVdGlsc18xLk51bWJlclV0aWxzLmNsYW1wKCgxIC0gTWF0aC5wb3coZGlzdGFuY2UgLyBhdHRyYWN0UmFkaXVzLCAyKSkgKiB2ZWxvY2l0eSwgMCwgNTApO1xuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueCA9IHBhcnRpY2xlLnBvc2l0aW9uLnggLSBub3JtVmVjLnggKiBhdHRyYWN0RmFjdG9yO1xuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueSA9IHBhcnRpY2xlLnBvc2l0aW9uLnkgLSBub3JtVmVjLnkgKiBhdHRyYWN0RmFjdG9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsaWNrQXR0cmFjdCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGlmICghY29udGFpbmVyLmF0dHJhY3QuZmluaXNoKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5hdHRyYWN0LmNvdW50KSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmF0dHJhY3QuY291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyLmF0dHJhY3QuY291bnQrKztcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuYXR0cmFjdC5jb3VudCA9PT0gY29udGFpbmVyLnBhcnRpY2xlcy5jb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hdHRyYWN0LmZpbmlzaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5lci5hdHRyYWN0LmNsaWNraW5nKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZVBvcyA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlLmNsaWNrUG9zaXRpb247XG4gICAgICAgICAgICBpZiAoIW1vdXNlUG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXR0cmFjdFJhZGl1cyA9IGNvbnRhaW5lci5yZXRpbmEuYXR0cmFjdE1vZGVEaXN0YW5jZTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0F0dHJhY3QobW91c2VQb3MsIGF0dHJhY3RSYWRpdXMsIG5ldyBVdGlsc18xLkNpcmNsZShtb3VzZVBvcy54LCBtb3VzZVBvcy55LCBhdHRyYWN0UmFkaXVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbmVyLmF0dHJhY3QuY2xpY2tpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXR0cmFjdC5wYXJ0aWNsZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZXhwb3J0cy5BdHRyYWN0b3IgPSBBdHRyYWN0b3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQm91bmNlciA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jb25zdCBNb2Rlc18xID0gcmVxdWlyZShcIi4uLy4uL0VudW1zL01vZGVzXCIpO1xuY29uc3QgVXRpbHNfMiA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IE1vZGVzXzIgPSByZXF1aXJlKFwiLi4vLi4vRW51bXMvTW9kZXNcIik7XG5jb25zdCBUeXBlc18xID0gcmVxdWlyZShcIi4uLy4uL0VudW1zL1R5cGVzXCIpO1xuY2xhc3MgQm91bmNlciB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cbiAgICBpc0VuYWJsZWQoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1vdXNlID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2U7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHM7XG4gICAgICAgIGNvbnN0IGRpdnMgPSBldmVudHMub25EaXY7XG4gICAgICAgIHJldHVybiAoKG1vdXNlLnBvc2l0aW9uICYmIGV2ZW50cy5vbkhvdmVyLmVuYWJsZSAmJiBVdGlsc18yLlV0aWxzLmlzSW5BcnJheShNb2Rlc18xLkhvdmVyTW9kZS5ib3VuY2UsIGV2ZW50cy5vbkhvdmVyLm1vZGUpKSB8fFxuICAgICAgICAgICAgVXRpbHNfMi5VdGlscy5pc0Rpdk1vZGVFbmFibGVkKE1vZGVzXzIuRGl2TW9kZS5ib3VuY2UsIGRpdnMpKTtcbiAgICB9XG4gICAgaW50ZXJhY3QoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHM7XG4gICAgICAgIGNvbnN0IG1vdXNlTW92ZVN0YXR1cyA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5LnN0YXR1cyA9PT0gVXRpbHNfMS5Db25zdGFudHMubW91c2VNb3ZlRXZlbnQ7XG4gICAgICAgIGNvbnN0IGhvdmVyRW5hYmxlZCA9IGV2ZW50cy5vbkhvdmVyLmVuYWJsZTtcbiAgICAgICAgY29uc3QgaG92ZXJNb2RlID0gZXZlbnRzLm9uSG92ZXIubW9kZTtcbiAgICAgICAgY29uc3QgZGl2cyA9IGV2ZW50cy5vbkRpdjtcbiAgICAgICAgaWYgKG1vdXNlTW92ZVN0YXR1cyAmJiBob3ZlckVuYWJsZWQgJiYgVXRpbHNfMi5VdGlscy5pc0luQXJyYXkoTW9kZXNfMS5Ib3Zlck1vZGUuYm91bmNlLCBob3Zlck1vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NNb3VzZUJvdW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgVXRpbHNfMi5VdGlscy5kaXZNb2RlRXhlY3V0ZShNb2Rlc18yLkRpdk1vZGUuYm91bmNlLCBkaXZzLCAoc2VsZWN0b3IsIGRpdikgPT4gdGhpcy5zaW5nbGVTZWxlY3RvckJvdW5jZShzZWxlY3RvciwgZGl2KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgfVxuICAgIHByb2Nlc3NNb3VzZUJvdW5jZSgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHB4UmF0aW8gPSBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IDEwICogcHhSYXRpbztcbiAgICAgICAgY29uc3QgbW91c2VQb3MgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gY29udGFpbmVyLnJldGluYS5ib3VuY2VNb2RlRGlzdGFuY2U7XG4gICAgICAgIGlmIChtb3VzZVBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQm91bmNlKG1vdXNlUG9zLCByYWRpdXMsIG5ldyBVdGlsc18yLkNpcmNsZShtb3VzZVBvcy54LCBtb3VzZVBvcy55LCByYWRpdXMgKyB0b2xlcmFuY2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaW5nbGVTZWxlY3RvckJvdW5jZShzZWxlY3RvciwgZGl2KSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBxdWVyeSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICBpZiAoIXF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBpdGVtO1xuICAgICAgICAgICAgY29uc3QgcHhSYXRpbyA9IGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHtcbiAgICAgICAgICAgICAgICB4OiAoZWxlbS5vZmZzZXRMZWZ0ICsgZWxlbS5vZmZzZXRXaWR0aCAvIDIpICogcHhSYXRpbyxcbiAgICAgICAgICAgICAgICB5OiAoZWxlbS5vZmZzZXRUb3AgKyBlbGVtLm9mZnNldEhlaWdodCAvIDIpICogcHhSYXRpbyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByYWRpdXMgPSAoZWxlbS5vZmZzZXRXaWR0aCAvIDIpICogcHhSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IDEwICogcHhSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBkaXYudHlwZSA9PT0gVHlwZXNfMS5EaXZUeXBlLmNpcmNsZVxuICAgICAgICAgICAgICAgID8gbmV3IFV0aWxzXzIuQ2lyY2xlKHBvcy54LCBwb3MueSwgcmFkaXVzICsgdG9sZXJhbmNlKVxuICAgICAgICAgICAgICAgIDogbmV3IFV0aWxzXzIuUmVjdGFuZ2xlKGVsZW0ub2Zmc2V0TGVmdCAqIHB4UmF0aW8gLSB0b2xlcmFuY2UsIGVsZW0ub2Zmc2V0VG9wICogcHhSYXRpbyAtIHRvbGVyYW5jZSwgZWxlbS5vZmZzZXRXaWR0aCAqIHB4UmF0aW8gKyB0b2xlcmFuY2UgKiAyLCBlbGVtLm9mZnNldEhlaWdodCAqIHB4UmF0aW8gKyB0b2xlcmFuY2UgKiAyKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0JvdW5jZShwb3MsIHJhZGl1cywgYXJlYSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9jZXNzQm91bmNlKHBvc2l0aW9uLCByYWRpdXMsIGFyZWEpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLmNvbnRhaW5lci5wYXJ0aWNsZXMucXVhZFRyZWUucXVlcnkoYXJlYSk7XG4gICAgICAgIGZvciAoY29uc3QgcGFydGljbGUgb2YgcXVlcnkpIHtcbiAgICAgICAgICAgIGlmIChhcmVhIGluc3RhbmNlb2YgVXRpbHNfMi5DaXJjbGUpIHtcbiAgICAgICAgICAgICAgICBVdGlsc18yLlV0aWxzLmNpcmNsZUJvdW5jZShVdGlsc18yLlV0aWxzLmNpcmNsZUJvdW5jZURhdGFGcm9tUGFydGljbGUocGFydGljbGUpLCB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWw6IDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZhY3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJlYSBpbnN0YW5jZW9mIFV0aWxzXzIuUmVjdGFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgVXRpbHNfMi5VdGlscy5yZWN0Qm91bmNlKHBhcnRpY2xlLCBVdGlsc18yLlV0aWxzLmNhbGN1bGF0ZUJvdW5kcyhwb3NpdGlvbiwgcmFkaXVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJvdW5jZXIgPSBCb3VuY2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1YmJsZXIgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9FbnVtc1wiKTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZUJ1YmJsZVZhbHVlKHBhcnRpY2xlVmFsdWUsIG1vZGVWYWx1ZSwgb3B0aW9uc1ZhbHVlLCByYXRpbykge1xuICAgIGlmIChtb2RlVmFsdWUgPiBvcHRpb25zVmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnRpY2xlVmFsdWUgKyAobW9kZVZhbHVlIC0gb3B0aW9uc1ZhbHVlKSAqIHJhdGlvO1xuICAgICAgICByZXR1cm4gVXRpbHNfMS5OdW1iZXJVdGlscy5jbGFtcChzaXplLCBwYXJ0aWNsZVZhbHVlLCBtb2RlVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtb2RlVmFsdWUgPCBvcHRpb25zVmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnRpY2xlVmFsdWUgLSAob3B0aW9uc1ZhbHVlIC0gbW9kZVZhbHVlKSAqIHJhdGlvO1xuICAgICAgICByZXR1cm4gVXRpbHNfMS5OdW1iZXJVdGlscy5jbGFtcChzaXplLCBtb2RlVmFsdWUsIHBhcnRpY2xlVmFsdWUpO1xuICAgIH1cbn1cbmNsYXNzIEJ1YmJsZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgaXNFbmFibGVkKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCBtb3VzZSA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlO1xuICAgICAgICBjb25zdCBldmVudHMgPSBvcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzO1xuICAgICAgICBjb25zdCBkaXZzID0gZXZlbnRzLm9uRGl2O1xuICAgICAgICBjb25zdCBkaXZCdWJibGUgPSBVdGlsc18xLlV0aWxzLmlzRGl2TW9kZUVuYWJsZWQoRW51bXNfMS5EaXZNb2RlLmJ1YmJsZSwgZGl2cyk7XG4gICAgICAgIGlmICghKGRpdkJ1YmJsZSB8fCAoZXZlbnRzLm9uSG92ZXIuZW5hYmxlICYmIG1vdXNlLnBvc2l0aW9uKSB8fCAoZXZlbnRzLm9uQ2xpY2suZW5hYmxlICYmIG1vdXNlLmNsaWNrUG9zaXRpb24pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvdmVyTW9kZSA9IGV2ZW50cy5vbkhvdmVyLm1vZGU7XG4gICAgICAgIGNvbnN0IGNsaWNrTW9kZSA9IGV2ZW50cy5vbkNsaWNrLm1vZGU7XG4gICAgICAgIHJldHVybiAoVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoRW51bXNfMS5Ib3Zlck1vZGUuYnViYmxlLCBob3Zlck1vZGUpIHx8IFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuQ2xpY2tNb2RlLmJ1YmJsZSwgY2xpY2tNb2RlKSB8fCBkaXZCdWJibGUpO1xuICAgIH1cbiAgICByZXNldChwYXJ0aWNsZSwgZm9yY2UpIHtcbiAgICAgICAgaWYgKCFwYXJ0aWNsZS5idWJibGUuaW5SYW5nZSB8fCBmb3JjZSkge1xuICAgICAgICAgICAgZGVsZXRlIHBhcnRpY2xlLmJ1YmJsZS5kaXY7XG4gICAgICAgICAgICBkZWxldGUgcGFydGljbGUuYnViYmxlLm9wYWNpdHk7XG4gICAgICAgICAgICBkZWxldGUgcGFydGljbGUuYnViYmxlLnJhZGl1cztcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJ0aWNsZS5idWJibGUuY29sb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW50ZXJhY3QoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCBldmVudHMgPSBvcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzO1xuICAgICAgICBjb25zdCBvbkhvdmVyID0gZXZlbnRzLm9uSG92ZXI7XG4gICAgICAgIGNvbnN0IG9uQ2xpY2sgPSBldmVudHMub25DbGljaztcbiAgICAgICAgY29uc3QgaG92ZXJFbmFibGVkID0gb25Ib3Zlci5lbmFibGU7XG4gICAgICAgIGNvbnN0IGhvdmVyTW9kZSA9IG9uSG92ZXIubW9kZTtcbiAgICAgICAgY29uc3QgY2xpY2tFbmFibGVkID0gb25DbGljay5lbmFibGU7XG4gICAgICAgIGNvbnN0IGNsaWNrTW9kZSA9IG9uQ2xpY2subW9kZTtcbiAgICAgICAgY29uc3QgZGl2cyA9IGV2ZW50cy5vbkRpdjtcbiAgICAgICAgaWYgKGhvdmVyRW5hYmxlZCAmJiBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkhvdmVyTW9kZS5idWJibGUsIGhvdmVyTW9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJCdWJibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGlja0VuYWJsZWQgJiYgVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoRW51bXNfMS5DbGlja01vZGUuYnViYmxlLCBjbGlja01vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrQnViYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBVdGlsc18xLlV0aWxzLmRpdk1vZGVFeGVjdXRlKEVudW1zXzEuRGl2TW9kZS5idWJibGUsIGRpdnMsIChzZWxlY3RvciwgZGl2KSA9PiB0aGlzLnNpbmdsZVNlbGVjdG9ySG92ZXIoc2VsZWN0b3IsIGRpdikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNpbmdsZVNlbGVjdG9ySG92ZXIoc2VsZWN0b3IsIGRpdikge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3JzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGlmICghc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdG9ycy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtID0gaXRlbTtcbiAgICAgICAgICAgIGNvbnN0IHB4UmF0aW8gPSBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgICAgICBjb25zdCBwb3MgPSB7XG4gICAgICAgICAgICAgICAgeDogKGVsZW0ub2Zmc2V0TGVmdCArIGVsZW0ub2Zmc2V0V2lkdGggLyAyKSAqIHB4UmF0aW8sXG4gICAgICAgICAgICAgICAgeTogKGVsZW0ub2Zmc2V0VG9wICsgZWxlbS5vZmZzZXRIZWlnaHQgLyAyKSAqIHB4UmF0aW8sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVwdWxzZVJhZGl1cyA9IChlbGVtLm9mZnNldFdpZHRoIC8gMikgKiBweFJhdGlvO1xuICAgICAgICAgICAgY29uc3QgYXJlYSA9IGRpdi50eXBlID09PSBFbnVtc18xLkRpdlR5cGUuY2lyY2xlXG4gICAgICAgICAgICAgICAgPyBuZXcgVXRpbHNfMS5DaXJjbGUocG9zLngsIHBvcy55LCByZXB1bHNlUmFkaXVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFV0aWxzXzEuUmVjdGFuZ2xlKGVsZW0ub2Zmc2V0TGVmdCAqIHB4UmF0aW8sIGVsZW0ub2Zmc2V0VG9wICogcHhSYXRpbywgZWxlbS5vZmZzZXRXaWR0aCAqIHB4UmF0aW8sIGVsZW0ub2Zmc2V0SGVpZ2h0ICogcHhSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IGNvbnRhaW5lci5wYXJ0aWNsZXMucXVhZFRyZWUucXVlcnkoYXJlYSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnRpY2xlIG9mIHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhcmVhLmNvbnRhaW5zKHBhcnRpY2xlLmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5idWJibGUuaW5SYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgZGl2cyA9IGNvbnRhaW5lci5vcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMuYnViYmxlLmRpdnM7XG4gICAgICAgICAgICAgICAgY29uc3QgZGl2QnViYmxlID0gVXRpbHNfMS5VdGlscy5kaXZNb2RlKGRpdnMsIGVsZW0pO1xuICAgICAgICAgICAgICAgIGlmICghcGFydGljbGUuYnViYmxlLmRpdiB8fCBwYXJ0aWNsZS5idWJibGUuZGl2ICE9PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQocGFydGljbGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5idWJibGUuZGl2ID0gZWxlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ob3ZlckJ1YmJsZVNpemUocGFydGljbGUsIDEsIGRpdkJ1YmJsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3ZlckJ1YmJsZU9wYWNpdHkocGFydGljbGUsIDEsIGRpdkJ1YmJsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3ZlckJ1YmJsZUNvbG9yKHBhcnRpY2xlLCBkaXZCdWJibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvY2VzcyhwYXJ0aWNsZSwgZGlzdE1vdXNlLCB0aW1lU3BlbnQsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IGJ1YmJsZVBhcmFtID0gZGF0YS5idWJibGVPYmoub3B0VmFsdWU7XG4gICAgICAgIGlmIChidWJibGVQYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCBidWJibGVEdXJhdGlvbiA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5idWJibGUuZHVyYXRpb247XG4gICAgICAgIGNvbnN0IGJ1YmJsZURpc3RhbmNlID0gY29udGFpbmVyLnJldGluYS5idWJibGVNb2RlRGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlc1BhcmFtID0gZGF0YS5wYXJ0aWNsZXNPYmoub3B0VmFsdWU7XG4gICAgICAgIGNvbnN0IHBPYmpCdWJibGUgPSBkYXRhLmJ1YmJsZU9iai52YWx1ZTtcbiAgICAgICAgY29uc3QgcE9iaiA9IGRhdGEucGFydGljbGVzT2JqLnZhbHVlIHx8IDA7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBkYXRhLnR5cGU7XG4gICAgICAgIGlmIChidWJibGVQYXJhbSAhPT0gcGFydGljbGVzUGFyYW0pIHtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyLmJ1YmJsZS5kdXJhdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChkaXN0TW91c2UgPD0gYnViYmxlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gcE9iakJ1YmJsZSAhPT0gbnVsbCAmJiBwT2JqQnViYmxlICE9PSB2b2lkIDAgPyBwT2JqQnViYmxlIDogcE9iajtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiAhPT0gYnViYmxlUGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcE9iaiAtICh0aW1lU3BlbnQgKiAocE9iaiAtIGJ1YmJsZVBhcmFtKSkgLyBidWJibGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBFbnVtc18xLlByb2Nlc3NCdWJibGVUeXBlLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5idWJibGUucmFkaXVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gRW51bXNfMS5Qcm9jZXNzQnViYmxlVHlwZS5vcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljbGUuYnViYmxlLm9wYWNpdHkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IEVudW1zXzEuUHJvY2Vzc0J1YmJsZVR5cGUuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcnRpY2xlLmJ1YmJsZS5yYWRpdXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IEVudW1zXzEuUHJvY2Vzc0J1YmJsZVR5cGUub3BhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcnRpY2xlLmJ1YmJsZS5vcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocE9iakJ1YmJsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBFbnVtc18xLlByb2Nlc3NCdWJibGVUeXBlLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcnRpY2xlLmJ1YmJsZS5yYWRpdXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBFbnVtc18xLlByb2Nlc3NCdWJibGVUeXBlLm9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcnRpY2xlLmJ1YmJsZS5vcGFjaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGlja0J1YmJsZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCBtb3VzZUNsaWNrUG9zID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UuY2xpY2tQb3NpdGlvbjtcbiAgICAgICAgaWYgKG1vdXNlQ2xpY2tQb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gY29udGFpbmVyLnJldGluYS5idWJibGVNb2RlRGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gY29udGFpbmVyLnBhcnRpY2xlcy5xdWFkVHJlZS5xdWVyeUNpcmNsZShtb3VzZUNsaWNrUG9zLCBkaXN0YW5jZSk7XG4gICAgICAgIGZvciAoY29uc3QgcGFydGljbGUgb2YgcXVlcnkpIHtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyLmJ1YmJsZS5jbGlja2luZykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFydGljbGUuYnViYmxlLmluUmFuZ2UgPSAhY29udGFpbmVyLmJ1YmJsZS5kdXJhdGlvbkVuZDtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHBhcnRpY2xlLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBkaXN0TW91c2UgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlKHBvcywgbW91c2VDbGlja1Bvcyk7XG4gICAgICAgICAgICBjb25zdCB0aW1lU3BlbnQgPSAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSAoY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UuY2xpY2tUaW1lIHx8IDApKSAvIDEwMDA7XG4gICAgICAgICAgICBpZiAodGltZVNwZW50ID4gb3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLmJ1YmJsZS5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5idWJibGUuZHVyYXRpb25FbmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVTcGVudCA+IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5idWJibGUuZHVyYXRpb24gKiAyKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmJ1YmJsZS5jbGlja2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5idWJibGUuZHVyYXRpb25FbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemVEYXRhID0ge1xuICAgICAgICAgICAgICAgIGJ1YmJsZU9iajoge1xuICAgICAgICAgICAgICAgICAgICBvcHRWYWx1ZTogY29udGFpbmVyLnJldGluYS5idWJibGVNb2RlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnRpY2xlLmJ1YmJsZS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZXNPYmo6IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0VmFsdWU6IChfYSA9IHBhcnRpY2xlLnNpemVWYWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29udGFpbmVyLnJldGluYS5zaXplVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJ0aWNsZS5zaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHlwZTogRW51bXNfMS5Qcm9jZXNzQnViYmxlVHlwZS5zaXplLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJvY2VzcyhwYXJ0aWNsZSwgZGlzdE1vdXNlLCB0aW1lU3BlbnQsIHNpemVEYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IG9wYWNpdHlEYXRhID0ge1xuICAgICAgICAgICAgICAgIGJ1YmJsZU9iajoge1xuICAgICAgICAgICAgICAgICAgICBvcHRWYWx1ZTogb3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLmJ1YmJsZS5vcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFydGljbGUuYnViYmxlLm9wYWNpdHksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZXNPYmo6IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0VmFsdWU6IHBhcnRpY2xlLnBhcnRpY2xlc09wdGlvbnMub3BhY2l0eS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnRpY2xlLm9wYWNpdHkudmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlOiBFbnVtc18xLlByb2Nlc3NCdWJibGVUeXBlLm9wYWNpdHksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHBhcnRpY2xlLCBkaXN0TW91c2UsIHRpbWVTcGVudCwgb3BhY2l0eURhdGEpO1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIuYnViYmxlLmR1cmF0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RNb3VzZSA8PSBjb250YWluZXIucmV0aW5hLmJ1YmJsZU1vZGVEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdmVyQnViYmxlQ29sb3IocGFydGljbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcnRpY2xlLmJ1YmJsZS5jb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFydGljbGUuYnViYmxlLmNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhvdmVyQnViYmxlKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgbW91c2VQb3MgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5wb3NpdGlvbjtcbiAgICAgICAgaWYgKG1vdXNlUG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGNvbnRhaW5lci5yZXRpbmEuYnViYmxlTW9kZURpc3RhbmNlO1xuICAgICAgICBjb25zdCBxdWVyeSA9IGNvbnRhaW5lci5wYXJ0aWNsZXMucXVhZFRyZWUucXVlcnlDaXJjbGUobW91c2VQb3MsIGRpc3RhbmNlKTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0aWNsZSBvZiBxdWVyeSkge1xuICAgICAgICAgICAgcGFydGljbGUuYnViYmxlLmluUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcG9zID0gcGFydGljbGUuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50RGlzdGFuY2UgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlKHBvcywgbW91c2VQb3MpO1xuICAgICAgICAgICAgY29uc3QgcmF0aW8gPSAxIC0gcG9pbnREaXN0YW5jZSAvIGRpc3RhbmNlO1xuICAgICAgICAgICAgaWYgKHBvaW50RGlzdGFuY2UgPD0gZGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmF0aW8gPj0gMCAmJiBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5zdGF0dXMgPT09IFV0aWxzXzEuQ29uc3RhbnRzLm1vdXNlTW92ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG92ZXJCdWJibGVTaXplKHBhcnRpY2xlLCByYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG92ZXJCdWJibGVPcGFjaXR5KHBhcnRpY2xlLCByYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG92ZXJCdWJibGVDb2xvcihwYXJ0aWNsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldChwYXJ0aWNsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLmludGVyYWN0aXZpdHkuc3RhdHVzID09PSBVdGlsc18xLkNvbnN0YW50cy5tb3VzZUxlYXZlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KHBhcnRpY2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBob3ZlckJ1YmJsZVNpemUocGFydGljbGUsIHJhdGlvLCBkaXZCdWJibGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgbW9kZVNpemUgPSAoZGl2QnViYmxlID09PSBudWxsIHx8IGRpdkJ1YmJsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGl2QnViYmxlLnNpemUpID8gZGl2QnViYmxlLnNpemUgKiBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW9cbiAgICAgICAgICAgIDogY29udGFpbmVyLnJldGluYS5idWJibGVNb2RlU2l6ZTtcbiAgICAgICAgaWYgKG1vZGVTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRTaXplID0gKF9hID0gcGFydGljbGUuc2l6ZVZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb250YWluZXIucmV0aW5hLnNpemVWYWx1ZTtcbiAgICAgICAgY29uc3QgcFNpemUgPSBwYXJ0aWNsZS5zaXplLnZhbHVlO1xuICAgICAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlQnViYmxlVmFsdWUocFNpemUsIG1vZGVTaXplLCBvcHRTaXplLCByYXRpbyk7XG4gICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLmJ1YmJsZS5yYWRpdXMgPSBzaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhvdmVyQnViYmxlT3BhY2l0eShwYXJ0aWNsZSwgcmF0aW8sIGRpdkJ1YmJsZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCBtb2RlT3BhY2l0eSA9IChfYSA9IGRpdkJ1YmJsZSA9PT0gbnVsbCB8fCBkaXZCdWJibGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpdkJ1YmJsZS5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBvcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMuYnViYmxlLm9wYWNpdHk7XG4gICAgICAgIGlmIChtb2RlT3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0T3BhY2l0eSA9IHBhcnRpY2xlLnBhcnRpY2xlc09wdGlvbnMub3BhY2l0eS52YWx1ZTtcbiAgICAgICAgY29uc3QgcE9wYWNpdHkgPSBwYXJ0aWNsZS5vcGFjaXR5LnZhbHVlO1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gY2FsY3VsYXRlQnViYmxlVmFsdWUocE9wYWNpdHksIG1vZGVPcGFjaXR5LCBvcHRPcGFjaXR5LCByYXRpbyk7XG4gICAgICAgIGlmIChvcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLmJ1YmJsZS5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBob3ZlckJ1YmJsZUNvbG9yKHBhcnRpY2xlLCBkaXZCdWJibGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb250YWluZXIub3B0aW9ucztcbiAgICAgICAgaWYgKHBhcnRpY2xlLmJ1YmJsZS5jb2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlQ29sb3IgPSAoX2EgPSBkaXZCdWJibGUgPT09IG51bGwgfHwgZGl2QnViYmxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaXZCdWJibGUuY29sb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5idWJibGUuY29sb3I7XG4gICAgICAgICAgICBpZiAobW9kZUNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidWJibGVDb2xvciA9IG1vZGVDb2xvciBpbnN0YW5jZW9mIEFycmF5ID8gVXRpbHNfMS5VdGlscy5pdGVtRnJvbUFycmF5KG1vZGVDb2xvcikgOiBtb2RlQ29sb3I7XG4gICAgICAgICAgICBwYXJ0aWNsZS5idWJibGUuY29sb3IgPSBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb0hzbChidWJibGVDb2xvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJ1YmJsZXIgPSBCdWJibGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbm5lY3RvciA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jb25zdCBNb2Rlc18xID0gcmVxdWlyZShcIi4uLy4uL0VudW1zL01vZGVzXCIpO1xuY2xhc3MgQ29ubmVjdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG1vdXNlID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2U7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IGNvbnRhaW5lci5vcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzO1xuICAgICAgICBpZiAoIShldmVudHMub25Ib3Zlci5lbmFibGUgJiYgbW91c2UucG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG92ZXJNb2RlID0gZXZlbnRzLm9uSG92ZXIubW9kZTtcbiAgICAgICAgcmV0dXJuIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KE1vZGVzXzEuSG92ZXJNb2RlLmNvbm5lY3QsIGhvdmVyTW9kZSk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgIH1cbiAgICBpbnRlcmFjdCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25Ib3Zlci5lbmFibGUgJiYgY29udGFpbmVyLmludGVyYWN0aXZpdHkuc3RhdHVzID09PSBcIm1vdXNlbW92ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZVBvcyA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlLnBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKCFtb3VzZVBvcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5hYnMoY29udGFpbmVyLnJldGluYS5jb25uZWN0TW9kZVJhZGl1cyk7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IGNvbnRhaW5lci5wYXJ0aWNsZXMucXVhZFRyZWUucXVlcnlDaXJjbGUobW91c2VQb3MsIGRpc3RhbmNlKTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcDEgb2YgcXVlcnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3MxID0gcDEuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAyIG9mIHF1ZXJ5LnNsaWNlKGkgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3MyID0gcDIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdE1heCA9IE1hdGguYWJzKGNvbnRhaW5lci5yZXRpbmEuY29ubmVjdE1vZGVEaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhEaWZmID0gTWF0aC5hYnMocG9zMS54IC0gcG9zMi54KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeURpZmYgPSBNYXRoLmFicyhwb3MxLnkgLSBwb3MyLnkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeERpZmYgPCBkaXN0TWF4ICYmIHlEaWZmIDwgZGlzdE1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNhbnZhcy5kcmF3Q29ubmVjdExpbmUocDEsIHAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNvbm5lY3RvciA9IENvbm5lY3RvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HcmFiYmVyID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IE1vZGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXMvTW9kZXNcIik7XG5jbGFzcyBHcmFiYmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG1vdXNlID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2U7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IGNvbnRhaW5lci5vcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzO1xuICAgICAgICBpZiAoIShldmVudHMub25Ib3Zlci5lbmFibGUgJiYgbW91c2UucG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG92ZXJNb2RlID0gZXZlbnRzLm9uSG92ZXIubW9kZTtcbiAgICAgICAgcmV0dXJuIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KE1vZGVzXzEuSG92ZXJNb2RlLmdyYWIsIGhvdmVyTW9kZSk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgIH1cbiAgICBpbnRlcmFjdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCBpbnRlcmFjdGl2aXR5ID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5O1xuICAgICAgICBpZiAoaW50ZXJhY3Rpdml0eS5ldmVudHMub25Ib3Zlci5lbmFibGUgJiYgY29udGFpbmVyLmludGVyYWN0aXZpdHkuc3RhdHVzID09PSBVdGlsc18xLkNvbnN0YW50cy5tb3VzZU1vdmVFdmVudCkge1xuICAgICAgICAgICAgY29uc3QgbW91c2VQb3MgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGlmIChtb3VzZVBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBjb250YWluZXIucmV0aW5hLmdyYWJNb2RlRGlzdGFuY2U7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IGNvbnRhaW5lci5wYXJ0aWNsZXMucXVhZFRyZWUucXVlcnlDaXJjbGUobW91c2VQb3MsIGRpc3RhbmNlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFydGljbGUgb2YgcXVlcnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSBwYXJ0aWNsZS5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50RGlzdGFuY2UgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlKHBvcywgbW91c2VQb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludERpc3RhbmNlIDw9IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyYWJMaW5lT3B0aW9ucyA9IGludGVyYWN0aXZpdHkubW9kZXMuZ3JhYi5saW5rcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZU9wYWNpdHkgPSBncmFiTGluZU9wdGlvbnMub3BhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BhY2l0eUxpbmUgPSBsaW5lT3BhY2l0eSAtIChwb2ludERpc3RhbmNlICogbGluZU9wYWNpdHkpIC8gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGFjaXR5TGluZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdENvbG9yID0gKF9hID0gZ3JhYkxpbmVPcHRpb25zLmNvbG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwYXJ0aWNsZS5wYXJ0aWNsZXNPcHRpb25zLmxpbmtzLmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXIucGFydGljbGVzLmdyYWJMaW5lQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rc09wdGlvbnMgPSBjb250YWluZXIub3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLmdyYWIubGlua3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcnRpY2xlcy5ncmFiTGluZUNvbG9yID0gVXRpbHNfMS5Db2xvclV0aWxzLmdldExpbmtSYW5kb21Db2xvcihvcHRDb2xvciwgbGlua3NPcHRpb25zLmJsaW5rLCBsaW5rc09wdGlvbnMuY29uc2VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xvckxpbmUgPSBVdGlsc18xLkNvbG9yVXRpbHMuZ2V0TGlua0NvbG9yKHBhcnRpY2xlLCB1bmRlZmluZWQsIGNvbnRhaW5lci5wYXJ0aWNsZXMuZ3JhYkxpbmVDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3JMaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuY2FudmFzLmRyYXdHcmFiTGluZShwYXJ0aWNsZSwgY29sb3JMaW5lLCBvcGFjaXR5TGluZSwgbW91c2VQb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5HcmFiYmVyID0gR3JhYmJlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaWdodGVyID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IE1vZGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXMvTW9kZXNcIik7XG5jbGFzcyBMaWdodGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGludGVyYWN0KCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cy5vbkhvdmVyLmVuYWJsZSAmJiBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5zdGF0dXMgPT09IFwibW91c2Vtb3ZlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlUG9zID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UucG9zaXRpb247XG4gICAgICAgICAgICBpZiAoIW1vdXNlUG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyLmNhbnZhcy5kcmF3TGlnaHQobW91c2VQb3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG1vdXNlID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2U7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IGNvbnRhaW5lci5vcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzO1xuICAgICAgICBpZiAoIShldmVudHMub25Ib3Zlci5lbmFibGUgJiYgbW91c2UucG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG92ZXJNb2RlID0gZXZlbnRzLm9uSG92ZXIubW9kZTtcbiAgICAgICAgcmV0dXJuIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KE1vZGVzXzEuSG92ZXJNb2RlLmxpZ2h0LCBob3Zlck1vZGUpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICB9XG59XG5leHBvcnRzLkxpZ2h0ZXIgPSBMaWdodGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlcHVsc2VyID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9FbnVtc1wiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jbGFzcyBSZXB1bHNlciB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cbiAgICBpc0VuYWJsZWQoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1vdXNlID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2U7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHM7XG4gICAgICAgIGNvbnN0IGRpdnMgPSBldmVudHMub25EaXY7XG4gICAgICAgIGNvbnN0IGRpdlJlcHVsc2UgPSBVdGlsc18xLlV0aWxzLmlzRGl2TW9kZUVuYWJsZWQoRW51bXNfMS5EaXZNb2RlLnJlcHVsc2UsIGRpdnMpO1xuICAgICAgICBpZiAoIShkaXZSZXB1bHNlIHx8IChldmVudHMub25Ib3Zlci5lbmFibGUgJiYgbW91c2UucG9zaXRpb24pIHx8IChldmVudHMub25DbGljay5lbmFibGUgJiYgbW91c2UuY2xpY2tQb3NpdGlvbikpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG92ZXJNb2RlID0gZXZlbnRzLm9uSG92ZXIubW9kZTtcbiAgICAgICAgY29uc3QgY2xpY2tNb2RlID0gZXZlbnRzLm9uQ2xpY2subW9kZTtcbiAgICAgICAgcmV0dXJuIChVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkhvdmVyTW9kZS5yZXB1bHNlLCBob3Zlck1vZGUpIHx8IFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuQ2xpY2tNb2RlLnJlcHVsc2UsIGNsaWNrTW9kZSkgfHwgZGl2UmVwdWxzZSk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgIH1cbiAgICBpbnRlcmFjdCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIub3B0aW9ucztcbiAgICAgICAgY29uc3QgbW91c2VNb3ZlU3RhdHVzID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkuc3RhdHVzID09PSBVdGlsc18xLkNvbnN0YW50cy5tb3VzZU1vdmVFdmVudDtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cztcbiAgICAgICAgY29uc3QgaG92ZXJFbmFibGVkID0gZXZlbnRzLm9uSG92ZXIuZW5hYmxlO1xuICAgICAgICBjb25zdCBob3Zlck1vZGUgPSBldmVudHMub25Ib3Zlci5tb2RlO1xuICAgICAgICBjb25zdCBjbGlja0VuYWJsZWQgPSBldmVudHMub25DbGljay5lbmFibGU7XG4gICAgICAgIGNvbnN0IGNsaWNrTW9kZSA9IGV2ZW50cy5vbkNsaWNrLm1vZGU7XG4gICAgICAgIGNvbnN0IGRpdnMgPSBldmVudHMub25EaXY7XG4gICAgICAgIGlmIChtb3VzZU1vdmVTdGF0dXMgJiYgaG92ZXJFbmFibGVkICYmIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuSG92ZXJNb2RlLnJlcHVsc2UsIGhvdmVyTW9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJSZXB1bHNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xpY2tFbmFibGVkICYmIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuQ2xpY2tNb2RlLnJlcHVsc2UsIGNsaWNrTW9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpY2tSZXB1bHNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBVdGlsc18xLlV0aWxzLmRpdk1vZGVFeGVjdXRlKEVudW1zXzEuRGl2TW9kZS5yZXB1bHNlLCBkaXZzLCAoc2VsZWN0b3IsIGRpdikgPT4gdGhpcy5zaW5nbGVTZWxlY3RvclJlcHVsc2Uoc2VsZWN0b3IsIGRpdikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNpbmdsZVNlbGVjdG9yUmVwdWxzZShzZWxlY3RvciwgZGl2KSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBxdWVyeSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICBpZiAoIXF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBpdGVtO1xuICAgICAgICAgICAgY29uc3QgcHhSYXRpbyA9IGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHtcbiAgICAgICAgICAgICAgICB4OiAoZWxlbS5vZmZzZXRMZWZ0ICsgZWxlbS5vZmZzZXRXaWR0aCAvIDIpICogcHhSYXRpbyxcbiAgICAgICAgICAgICAgICB5OiAoZWxlbS5vZmZzZXRUb3AgKyBlbGVtLm9mZnNldEhlaWdodCAvIDIpICogcHhSYXRpbyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXB1bHNlUmFkaXVzID0gKGVsZW0ub2Zmc2V0V2lkdGggLyAyKSAqIHB4UmF0aW87XG4gICAgICAgICAgICBjb25zdCBhcmVhID0gZGl2LnR5cGUgPT09IEVudW1zXzEuRGl2VHlwZS5jaXJjbGVcbiAgICAgICAgICAgICAgICA/IG5ldyBVdGlsc18xLkNpcmNsZShwb3MueCwgcG9zLnksIHJlcHVsc2VSYWRpdXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVXRpbHNfMS5SZWN0YW5nbGUoZWxlbS5vZmZzZXRMZWZ0ICogcHhSYXRpbywgZWxlbS5vZmZzZXRUb3AgKiBweFJhdGlvLCBlbGVtLm9mZnNldFdpZHRoICogcHhSYXRpbywgZWxlbS5vZmZzZXRIZWlnaHQgKiBweFJhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IGRpdnMgPSBjb250YWluZXIub3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLnJlcHVsc2UuZGl2cztcbiAgICAgICAgICAgIGNvbnN0IGRpdlJlcHVsc2UgPSBVdGlsc18xLlV0aWxzLmRpdk1vZGUoZGl2cywgZWxlbSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NSZXB1bHNlKHBvcywgcmVwdWxzZVJhZGl1cywgYXJlYSwgZGl2UmVwdWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBob3ZlclJlcHVsc2UoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBtb3VzZVBvcyA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlLnBvc2l0aW9uO1xuICAgICAgICBpZiAoIW1vdXNlUG9zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVwdWxzZVJhZGl1cyA9IGNvbnRhaW5lci5yZXRpbmEucmVwdWxzZU1vZGVEaXN0YW5jZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmVwdWxzZShtb3VzZVBvcywgcmVwdWxzZVJhZGl1cywgbmV3IFV0aWxzXzEuQ2lyY2xlKG1vdXNlUG9zLngsIG1vdXNlUG9zLnksIHJlcHVsc2VSYWRpdXMpKTtcbiAgICB9XG4gICAgcHJvY2Vzc1JlcHVsc2UocG9zaXRpb24sIHJlcHVsc2VSYWRpdXMsIGFyZWEsIGRpdlJlcHVsc2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBjb250YWluZXIucGFydGljbGVzLnF1YWRUcmVlLnF1ZXJ5KGFyZWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnRpY2xlIG9mIHF1ZXJ5KSB7XG4gICAgICAgICAgICBjb25zdCB7IGR4LCBkeSwgZGlzdGFuY2UgfSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2VzKHBhcnRpY2xlLnBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgICAgICBjb25zdCBub3JtVmVjID0ge1xuICAgICAgICAgICAgICAgIHg6IGR4IC8gZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgeTogZHkgLyBkaXN0YW5jZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB2ZWxvY2l0eSA9ICgoX2EgPSBkaXZSZXB1bHNlID09PSBudWxsIHx8IGRpdlJlcHVsc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpdlJlcHVsc2Uuc3BlZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnRhaW5lci5vcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMucmVwdWxzZS5zcGVlZCkgKiAxMDA7XG4gICAgICAgICAgICBjb25zdCByZXB1bHNlRmFjdG9yID0gVXRpbHNfMS5OdW1iZXJVdGlscy5jbGFtcCgoMSAtIE1hdGgucG93KGRpc3RhbmNlIC8gcmVwdWxzZVJhZGl1cywgMikpICogdmVsb2NpdHksIDAsIDUwKTtcbiAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnggPSBwYXJ0aWNsZS5wb3NpdGlvbi54ICsgbm9ybVZlYy54ICogcmVwdWxzZUZhY3RvcjtcbiAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnkgPSBwYXJ0aWNsZS5wb3NpdGlvbi55ICsgbm9ybVZlYy55ICogcmVwdWxzZUZhY3RvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGlja1JlcHVsc2UoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBpZiAoIWNvbnRhaW5lci5yZXB1bHNlLmZpbmlzaCkge1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIucmVwdWxzZS5jb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZXB1bHNlLmNvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lci5yZXB1bHNlLmNvdW50Kys7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLnJlcHVsc2UuY291bnQgPT09IGNvbnRhaW5lci5wYXJ0aWNsZXMuY291bnQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVwdWxzZS5maW5pc2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWluZXIucmVwdWxzZS5jbGlja2luZykge1xuICAgICAgICAgICAgY29uc3QgcmVwdWxzZURpc3RhbmNlID0gY29udGFpbmVyLnJldGluYS5yZXB1bHNlTW9kZURpc3RhbmNlO1xuICAgICAgICAgICAgY29uc3QgcmVwdWxzZVJhZGl1cyA9IE1hdGgucG93KHJlcHVsc2VEaXN0YW5jZSAvIDYsIDMpO1xuICAgICAgICAgICAgY29uc3QgbW91c2VDbGlja1BvcyA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlLmNsaWNrUG9zaXRpb247XG4gICAgICAgICAgICBpZiAobW91c2VDbGlja1BvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBuZXcgVXRpbHNfMS5DaXJjbGUobW91c2VDbGlja1Bvcy54LCBtb3VzZUNsaWNrUG9zLnksIHJlcHVsc2VSYWRpdXMpO1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBjb250YWluZXIucGFydGljbGVzLnF1YWRUcmVlLnF1ZXJ5KHJhbmdlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFydGljbGUgb2YgcXVlcnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGR4LCBkeSwgZGlzdGFuY2UgfSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2VzKG1vdXNlQ2xpY2tQb3MsIHBhcnRpY2xlLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gZGlzdGFuY2UgKiBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IGNvbnRhaW5lci5vcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMucmVwdWxzZS5zcGVlZDtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JjZSA9ICgtcmVwdWxzZVJhZGl1cyAqIHZlbG9jaXR5KSAvIGQ7XG4gICAgICAgICAgICAgICAgaWYgKGQgPD0gcmVwdWxzZVJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucmVwdWxzZS5wYXJ0aWNsZXMucHVzaChwYXJ0aWNsZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS5ob3Jpem9udGFsID0gZm9yY2UgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnZlcnRpY2FsID0gZm9yY2UgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5lci5yZXB1bHNlLmNsaWNraW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0aWNsZSBvZiBjb250YWluZXIucmVwdWxzZS5wYXJ0aWNsZXMpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS5ob3Jpem9udGFsID0gcGFydGljbGUuaW5pdGlhbFZlbG9jaXR5Lmhvcml6b250YWw7XG4gICAgICAgICAgICAgICAgcGFydGljbGUudmVsb2NpdHkudmVydGljYWwgPSBwYXJ0aWNsZS5pbml0aWFsVmVsb2NpdHkudmVydGljYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIucmVwdWxzZS5wYXJ0aWNsZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmVwdWxzZXIgPSBSZXB1bHNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFpbE1ha2VyID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IE1vZGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXMvTW9kZXNcIik7XG5jbGFzcyBUcmFpbE1ha2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuZGVsYXkgPSAwO1xuICAgIH1cbiAgICBpbnRlcmFjdChkZWx0YSkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyLnJldGluYS5yZWR1Y2VGYWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCB0cmFpbE9wdGlvbnMgPSBvcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMudHJhaWw7XG4gICAgICAgIGNvbnN0IG9wdERlbGF5ID0gKHRyYWlsT3B0aW9ucy5kZWxheSAqIDEwMDApIC8gdGhpcy5jb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcjtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXkgPCBvcHREZWxheSkge1xuICAgICAgICAgICAgdGhpcy5kZWxheSArPSBkZWx0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxheSA+PSBvcHREZWxheSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnBhcnRpY2xlcy5wdXNoKHRyYWlsT3B0aW9ucy5xdWFudGl0eSwgY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UsIHRyYWlsT3B0aW9ucy5wYXJ0aWNsZXMpO1xuICAgICAgICAgICAgdGhpcy5kZWxheSAtPSBvcHREZWxheTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0VuYWJsZWQoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1vdXNlID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2U7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHM7XG4gICAgICAgIHJldHVybiAoKG1vdXNlLmNsaWNraW5nICYmXG4gICAgICAgICAgICBtb3VzZS5pbnNpZGUgJiZcbiAgICAgICAgICAgICEhbW91c2UucG9zaXRpb24gJiZcbiAgICAgICAgICAgIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KE1vZGVzXzEuQ2xpY2tNb2RlLnRyYWlsLCBldmVudHMub25DbGljay5tb2RlKSkgfHxcbiAgICAgICAgICAgIChtb3VzZS5pbnNpZGUgJiYgISFtb3VzZS5wb3NpdGlvbiAmJiBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShNb2Rlc18xLkhvdmVyTW9kZS50cmFpbCwgZXZlbnRzLm9uSG92ZXIubW9kZSkpKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFpbE1ha2VyID0gVHJhaWxNYWtlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdHRyYWN0b3IgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY2xhc3MgQXR0cmFjdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGludGVyYWN0KHAxKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gKF9hID0gcDEubGlua3NEaXN0YW5jZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29udGFpbmVyLnJldGluYS5saW5rc0Rpc3RhbmNlO1xuICAgICAgICBjb25zdCBwb3MxID0gcDEuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBjb250YWluZXIucGFydGljbGVzLnF1YWRUcmVlLnF1ZXJ5Q2lyY2xlKHBvczEsIGRpc3RhbmNlKTtcbiAgICAgICAgZm9yIChjb25zdCBwMiBvZiBxdWVyeSkge1xuICAgICAgICAgICAgaWYgKHAxID09PSBwMiB8fCAhcDIucGFydGljbGVzT3B0aW9ucy5tb3ZlLmF0dHJhY3QuZW5hYmxlIHx8IHAyLmRlc3Ryb3llZCB8fCBwMi5zcGF3bmluZykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9zMiA9IHAyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCB7IGR4LCBkeSB9ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZXMocG9zMSwgcG9zMik7XG4gICAgICAgICAgICBjb25zdCByb3RhdGUgPSBwMS5wYXJ0aWNsZXNPcHRpb25zLm1vdmUuYXR0cmFjdC5yb3RhdGU7XG4gICAgICAgICAgICBjb25zdCBheCA9IGR4IC8gKHJvdGF0ZS54ICogMTAwMCk7XG4gICAgICAgICAgICBjb25zdCBheSA9IGR5IC8gKHJvdGF0ZS55ICogMTAwMCk7XG4gICAgICAgICAgICBwMS52ZWxvY2l0eS5ob3Jpem9udGFsIC09IGF4O1xuICAgICAgICAgICAgcDEudmVsb2NpdHkudmVydGljYWwgLT0gYXk7XG4gICAgICAgICAgICBwMi52ZWxvY2l0eS5ob3Jpem9udGFsICs9IGF4O1xuICAgICAgICAgICAgcDIudmVsb2NpdHkudmVydGljYWwgKz0gYXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNFbmFibGVkKHBhcnRpY2xlKSB7XG4gICAgICAgIHJldHVybiBwYXJ0aWNsZS5wYXJ0aWNsZXNPcHRpb25zLm1vdmUuYXR0cmFjdC5lbmFibGU7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgIH1cbn1cbmV4cG9ydHMuQXR0cmFjdG9yID0gQXR0cmFjdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbGxpZGVyID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9FbnVtc1wiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5mdW5jdGlvbiBib3VuY2UocDEsIHAyKSB7XG4gICAgVXRpbHNfMS5VdGlscy5jaXJjbGVCb3VuY2UoVXRpbHNfMS5VdGlscy5jaXJjbGVCb3VuY2VEYXRhRnJvbVBhcnRpY2xlKHAxKSwgVXRpbHNfMS5VdGlscy5jaXJjbGVCb3VuY2VEYXRhRnJvbVBhcnRpY2xlKHAyKSk7XG59XG5mdW5jdGlvbiBkZXN0cm95KHAxLCBwMikge1xuICAgIGlmIChwMS5nZXRSYWRpdXMoKSA9PT0gdW5kZWZpbmVkICYmIHAyLmdldFJhZGl1cygpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcDEuZGVzdHJveSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwMS5nZXRSYWRpdXMoKSAhPT0gdW5kZWZpbmVkICYmIHAyLmdldFJhZGl1cygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcDIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwMS5nZXRSYWRpdXMoKSAhPT0gdW5kZWZpbmVkICYmIHAyLmdldFJhZGl1cygpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHAxLmdldFJhZGl1cygpID49IHAyLmdldFJhZGl1cygpKSB7XG4gICAgICAgICAgICBwMi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwMS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDb2xsaWRlciB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cbiAgICBpc0VuYWJsZWQocGFydGljbGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRpY2xlLnBhcnRpY2xlc09wdGlvbnMuY29sbGlzaW9ucy5lbmFibGU7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgIH1cbiAgICBpbnRlcmFjdChwMSkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcG9zMSA9IHAxLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gY29udGFpbmVyLnBhcnRpY2xlcy5xdWFkVHJlZS5xdWVyeUNpcmNsZShwb3MxLCBwMS5nZXRSYWRpdXMoKSAqIDIpO1xuICAgICAgICBmb3IgKGNvbnN0IHAyIG9mIHF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAocDEgPT09IHAyIHx8XG4gICAgICAgICAgICAgICAgIXAyLnBhcnRpY2xlc09wdGlvbnMuY29sbGlzaW9ucy5lbmFibGUgfHxcbiAgICAgICAgICAgICAgICBwMS5wYXJ0aWNsZXNPcHRpb25zLmNvbGxpc2lvbnMubW9kZSAhPT0gcDIucGFydGljbGVzT3B0aW9ucy5jb2xsaXNpb25zLm1vZGUgfHxcbiAgICAgICAgICAgICAgICBwMi5kZXN0cm95ZWQgfHxcbiAgICAgICAgICAgICAgICBwMi5zcGF3bmluZykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9zMiA9IHAyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShwb3MxLCBwb3MyKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1czEgPSBwMS5nZXRSYWRpdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1czIgPSBwMi5nZXRSYWRpdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RQID0gcmFkaXVzMSArIHJhZGl1czI7XG4gICAgICAgICAgICBpZiAoZGlzdCA8PSBkaXN0UCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbihwMSwgcDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVDb2xsaXNpb24ocDEsIHAyKSB7XG4gICAgICAgIHN3aXRjaCAocDEucGFydGljbGVzT3B0aW9ucy5jb2xsaXNpb25zLm1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRW51bXNfMS5Db2xsaXNpb25Nb2RlLmFic29yYjoge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJzb3JiKHAxLCBwMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVudW1zXzEuQ29sbGlzaW9uTW9kZS5ib3VuY2U6IHtcbiAgICAgICAgICAgICAgICBib3VuY2UocDEsIHAyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRW51bXNfMS5Db2xsaXNpb25Nb2RlLmRlc3Ryb3k6IHtcbiAgICAgICAgICAgICAgICBkZXN0cm95KHAxLCBwMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWJzb3JiKHAxLCBwMikge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgZnBzID0gY29udGFpbmVyLm9wdGlvbnMuZnBzTGltaXQgLyAxMDAwO1xuICAgICAgICBpZiAocDEuZ2V0UmFkaXVzKCkgPT09IHVuZGVmaW5lZCAmJiBwMi5nZXRSYWRpdXMoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwMS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocDEuZ2V0UmFkaXVzKCkgIT09IHVuZGVmaW5lZCAmJiBwMi5nZXRSYWRpdXMoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwMi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocDEuZ2V0UmFkaXVzKCkgIT09IHVuZGVmaW5lZCAmJiBwMi5nZXRSYWRpdXMoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocDEuZ2V0UmFkaXVzKCkgPj0gcDIuZ2V0UmFkaXVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWN0b3IgPSBVdGlsc18xLk51bWJlclV0aWxzLmNsYW1wKHAxLmdldFJhZGl1cygpIC8gcDIuZ2V0UmFkaXVzKCksIDAsIHAyLmdldFJhZGl1cygpKSAqIGZwcztcbiAgICAgICAgICAgICAgICBwMS5zaXplLnZhbHVlICs9IGZhY3RvcjtcbiAgICAgICAgICAgICAgICBwMi5zaXplLnZhbHVlIC09IGZhY3RvcjtcbiAgICAgICAgICAgICAgICBpZiAocDIuZ2V0UmFkaXVzKCkgPD0gY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHAyLnNpemUudmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBwMi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gVXRpbHNfMS5OdW1iZXJVdGlscy5jbGFtcChwMi5nZXRSYWRpdXMoKSAvIHAxLmdldFJhZGl1cygpLCAwLCBwMS5nZXRSYWRpdXMoKSkgKiBmcHM7XG4gICAgICAgICAgICAgICAgcDEuc2l6ZS52YWx1ZSAtPSBmYWN0b3I7XG4gICAgICAgICAgICAgICAgcDIuc2l6ZS52YWx1ZSArPSBmYWN0b3I7XG4gICAgICAgICAgICAgICAgaWYgKHAxLmdldFJhZGl1cygpIDw9IGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbykge1xuICAgICAgICAgICAgICAgICAgICBwMS5zaXplLnZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcDEuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29sbGlkZXIgPSBDb2xsaWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbmZlY3RlciA9IHZvaWQgMDtcbmNsYXNzIEluZmVjdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLm9wdGlvbnMuaW5mZWN0aW9uLmVuYWJsZTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgfVxuICAgIGludGVyYWN0KHAxLCBkZWx0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBpbmZlY3RlcjEgPSBwMS5pbmZlY3RlcjtcbiAgICAgICAgaW5mZWN0ZXIxLnVwZGF0ZUluZmVjdGlvbihkZWx0YS52YWx1ZSk7XG4gICAgICAgIGlmIChpbmZlY3RlcjEuaW5mZWN0aW9uU3RhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGluZmVjdGlvbk9wdGlvbnMgPSBvcHRpb25zLmluZmVjdGlvbjtcbiAgICAgICAgaWYgKCFpbmZlY3Rpb25PcHRpb25zLmVuYWJsZSB8fCBpbmZlY3Rpb25PcHRpb25zLnN0YWdlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5mZWN0aW9uU3RhZ2UxID0gaW5mZWN0aW9uT3B0aW9ucy5zdGFnZXNbaW5mZWN0ZXIxLmluZmVjdGlvblN0YWdlXTtcbiAgICAgICAgY29uc3QgcHhSYXRpbyA9IGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgY29uc3QgcmFkaXVzID0gcDEuZ2V0UmFkaXVzKCkgKiAyICsgaW5mZWN0aW9uU3RhZ2UxLnJhZGl1cyAqIHB4UmF0aW87XG4gICAgICAgIGNvbnN0IHBvcyA9IHAxLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IGluZmVjdGVkU3RhZ2UxID0gKF9hID0gaW5mZWN0aW9uU3RhZ2UxLmluZmVjdGVkU3RhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGluZmVjdGVyMS5pbmZlY3Rpb25TdGFnZTtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBjb250YWluZXIucGFydGljbGVzLnF1YWRUcmVlLnF1ZXJ5Q2lyY2xlKHBvcywgcmFkaXVzKTtcbiAgICAgICAgY29uc3QgaW5mZWN0aW9ucyA9IGluZmVjdGlvblN0YWdlMS5yYXRlO1xuICAgICAgICBjb25zdCBuZWlnaGJvcnMgPSBxdWVyeS5sZW5ndGg7XG4gICAgICAgIGZvciAoY29uc3QgcDIgb2YgcXVlcnkpIHtcbiAgICAgICAgICAgIGlmIChwMiA9PT0gcDEgfHxcbiAgICAgICAgICAgICAgICBwMi5kZXN0cm95ZWQgfHxcbiAgICAgICAgICAgICAgICBwMi5zcGF3bmluZyB8fFxuICAgICAgICAgICAgICAgICEocDIuaW5mZWN0ZXIuaW5mZWN0aW9uU3RhZ2UgPT09IHVuZGVmaW5lZCB8fCBwMi5pbmZlY3Rlci5pbmZlY3Rpb25TdGFnZSAhPT0gaW5mZWN0ZXIxLmluZmVjdGlvblN0YWdlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5mZWN0ZXIyID0gcDIuaW5mZWN0ZXI7XG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IGluZmVjdGlvbnMgLyBuZWlnaGJvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mZWN0ZXIyLmluZmVjdGlvblN0YWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mZWN0ZXIyLnN0YXJ0SW5mZWN0aW9uKGluZmVjdGVkU3RhZ2UxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5mZWN0ZXIyLmluZmVjdGlvblN0YWdlIDwgaW5mZWN0ZXIxLmluZmVjdGlvblN0YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZmVjdGVyMi51cGRhdGVJbmZlY3Rpb25TdGFnZShpbmZlY3RlZFN0YWdlMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZmVjdGVyMi5pbmZlY3Rpb25TdGFnZSA+IGluZmVjdGVyMS5pbmZlY3Rpb25TdGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmZlY3Rpb25TdGFnZTIgPSBpbmZlY3Rpb25PcHRpb25zLnN0YWdlc1tpbmZlY3RlcjIuaW5mZWN0aW9uU3RhZ2VdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmZlY3RlZFN0YWdlMiA9IChfYiA9IGluZmVjdGlvblN0YWdlMiA9PT0gbnVsbCB8fCBpbmZlY3Rpb25TdGFnZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZmVjdGlvblN0YWdlMi5pbmZlY3RlZFN0YWdlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBpbmZlY3RlcjIuaW5mZWN0aW9uU3RhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGluZmVjdGVyMS51cGRhdGVJbmZlY3Rpb25TdGFnZShpbmZlY3RlZFN0YWdlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JbmZlY3RlciA9IEluZmVjdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpZ2h0ZXIgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY29uc3QgTW9kZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9FbnVtcy9Nb2Rlc1wiKTtcbmNsYXNzIExpZ2h0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgaW50ZXJhY3QocGFydGljbGUpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25Ib3Zlci5lbmFibGUgJiYgY29udGFpbmVyLmludGVyYWN0aXZpdHkuc3RhdHVzID09PSBcIm1vdXNlbW92ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZVBvcyA9IHRoaXMuY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UucG9zaXRpb247XG4gICAgICAgICAgICBpZiAobW91c2VQb3MpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2FudmFzLmRyYXdQYXJ0aWNsZVNoYWRvdyhwYXJ0aWNsZSwgbW91c2VQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG1vdXNlID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2U7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IGNvbnRhaW5lci5vcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzO1xuICAgICAgICBpZiAoIShldmVudHMub25Ib3Zlci5lbmFibGUgJiYgbW91c2UucG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG92ZXJNb2RlID0gZXZlbnRzLm9uSG92ZXIubW9kZTtcbiAgICAgICAgcmV0dXJuIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KE1vZGVzXzEuSG92ZXJNb2RlLmxpZ2h0LCBob3Zlck1vZGUpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICB9XG59XG5leHBvcnRzLkxpZ2h0ZXIgPSBMaWdodGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpbmtlciA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jbGFzcyBMaW5rZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgaXNFbmFibGVkKHBhcnRpY2xlKSB7XG4gICAgICAgIHJldHVybiBwYXJ0aWNsZS5wYXJ0aWNsZXNPcHRpb25zLmxpbmtzLmVuYWJsZTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgfVxuICAgIGludGVyYWN0KHAxKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IGxpbmtPcHQxID0gcDEucGFydGljbGVzT3B0aW9ucy5saW5rcztcbiAgICAgICAgY29uc3Qgb3B0T3BhY2l0eSA9IGxpbmtPcHQxLm9wYWNpdHk7XG4gICAgICAgIGNvbnN0IG9wdERpc3RhbmNlID0gKF9hID0gcDEubGlua3NEaXN0YW5jZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29udGFpbmVyLnJldGluYS5saW5rc0Rpc3RhbmNlO1xuICAgICAgICBjb25zdCBjYW52YXNTaXplID0gY29udGFpbmVyLmNhbnZhcy5zaXplO1xuICAgICAgICBjb25zdCB3YXJwID0gbGlua09wdDEud2FycDtcbiAgICAgICAgY29uc3QgcG9zMSA9IHAxLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gd2FycFxuICAgICAgICAgICAgPyBuZXcgVXRpbHNfMS5DaXJjbGVXYXJwKHBvczEueCwgcG9zMS55LCBvcHREaXN0YW5jZSwgY2FudmFzU2l6ZSlcbiAgICAgICAgICAgIDogbmV3IFV0aWxzXzEuQ2lyY2xlKHBvczEueCwgcG9zMS55LCBvcHREaXN0YW5jZSk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gY29udGFpbmVyLnBhcnRpY2xlcy5xdWFkVHJlZS5xdWVyeShyYW5nZSk7XG4gICAgICAgIGZvciAoY29uc3QgcDIgb2YgcXVlcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtPcHQyID0gcDIucGFydGljbGVzT3B0aW9ucy5saW5rcztcbiAgICAgICAgICAgIGlmIChwMSA9PT0gcDIgfHwgIWxpbmtPcHQyLmVuYWJsZSB8fCBsaW5rT3B0MS5pZCAhPT0gbGlua09wdDIuaWQgfHwgcDIuc3Bhd25pbmcgfHwgcDIuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb3MyID0gcDIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2UocG9zMSwgcG9zMik7XG4gICAgICAgICAgICBpZiAod2FycCkge1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG9wdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvczJORSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBvczIueCAtIGNhbnZhc1NpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwb3MyLnksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShwb3MxLCBwb3MyTkUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBvcHREaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zMlNFID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBvczIueCAtIGNhbnZhc1NpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcG9zMi55IC0gY2FudmFzU2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlKHBvczEsIHBvczJTRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBvcHREaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvczJTVyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcG9zMi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwb3MyLnkgLSBjYW52YXNTaXplLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShwb3MxLCBwb3MyU1cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gb3B0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcGFjaXR5TGluZSA9ICgxIC0gZGlzdGFuY2UgLyBvcHREaXN0YW5jZSkgKiBvcHRPcGFjaXR5O1xuICAgICAgICAgICAgY29uc3QgbGlua3NPcHRpb25zID0gcDEucGFydGljbGVzT3B0aW9ucy5saW5rcztcbiAgICAgICAgICAgIGxldCBsaW5rQ29sb3IgPSBsaW5rc09wdGlvbnMuaWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gY29udGFpbmVyLnBhcnRpY2xlcy5saW5rc0NvbG9ycy5nZXQobGlua3NPcHRpb25zLmlkKVxuICAgICAgICAgICAgICAgIDogY29udGFpbmVyLnBhcnRpY2xlcy5saW5rc0NvbG9yO1xuICAgICAgICAgICAgaWYgKCFsaW5rQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRDb2xvciA9IGxpbmtzT3B0aW9ucy5jb2xvcjtcbiAgICAgICAgICAgICAgICBsaW5rQ29sb3IgPSBVdGlsc18xLkNvbG9yVXRpbHMuZ2V0TGlua1JhbmRvbUNvbG9yKG9wdENvbG9yLCBsaW5rc09wdGlvbnMuYmxpbmssIGxpbmtzT3B0aW9ucy5jb25zZW50KTtcbiAgICAgICAgICAgICAgICBpZiAobGlua3NPcHRpb25zLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcnRpY2xlcy5saW5rc0NvbG9ycy5zZXQobGlua3NPcHRpb25zLmlkLCBsaW5rQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcnRpY2xlcy5saW5rc0NvbG9yID0gbGlua0NvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwMi5saW5rcy5tYXAoKHQpID0+IHQuZGVzdGluYXRpb24pLmluZGV4T2YocDEpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIHAxLmxpbmtzLm1hcCgodCkgPT4gdC5kZXN0aW5hdGlvbikuaW5kZXhPZihwMikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcDEubGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBwMixcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eUxpbmUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpbmtlciA9IExpbmtlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYWNrZ3JvdW5kID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vT3B0aW9uc0NvbG9yXCIpO1xuY2xhc3MgQmFja2dyb3VuZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yKCk7XG4gICAgICAgIHRoaXMuY29sb3IudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmltYWdlID0gXCJcIjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFwiXCI7XG4gICAgICAgIHRoaXMucmVwZWF0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5zaXplID0gXCJcIjtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh0aGlzLmNvbG9yLCBkYXRhLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5pbWFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gZGF0YS5pbWFnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gZGF0YS5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yZXBlYXQgPSBkYXRhLnJlcGVhdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGRhdGEub3BhY2l0eTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQmFja2dyb3VuZCA9IEJhY2tncm91bmQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFja2dyb3VuZE1hc2sgPSB2b2lkIDA7XG5jb25zdCBCYWNrZ3JvdW5kTWFza0NvdmVyXzEgPSByZXF1aXJlKFwiLi9CYWNrZ3JvdW5kTWFza0NvdmVyXCIpO1xuY2xhc3MgQmFja2dyb3VuZE1hc2sge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbXBvc2l0ZSA9IFwiZGVzdGluYXRpb24tb3V0XCI7XG4gICAgICAgIHRoaXMuY292ZXIgPSBuZXcgQmFja2dyb3VuZE1hc2tDb3Zlcl8xLkJhY2tncm91bmRNYXNrQ292ZXIoKTtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5jb21wb3NpdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGUgPSBkYXRhLmNvbXBvc2l0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5jb3ZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjb3ZlciA9IGRhdGEuY292ZXI7XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9ICh0eXBlb2YgZGF0YS5jb3ZlciA9PT0gXCJzdHJpbmdcIiA/IHsgY29sb3I6IGRhdGEuY292ZXIgfSA6IGRhdGEuY292ZXIpO1xuICAgICAgICAgICAgdGhpcy5jb3Zlci5sb2FkKGNvdmVyLmNvbG9yICE9PSB1bmRlZmluZWQgPyBjb3ZlciA6IHsgY29sb3I6IGNvbG9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CYWNrZ3JvdW5kTWFzayA9IEJhY2tncm91bmRNYXNrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhY2tncm91bmRNYXNrQ292ZXIgPSB2b2lkIDA7XG5jb25zdCBPcHRpb25zQ29sb3JfMSA9IHJlcXVpcmUoXCIuLi9PcHRpb25zQ29sb3JcIik7XG5jbGFzcyBCYWNrZ3JvdW5kTWFza0NvdmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IoKTtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh0aGlzLmNvbG9yLCBkYXRhLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGRhdGEub3BhY2l0eTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQmFja2dyb3VuZE1hc2tDb3ZlciA9IEJhY2tncm91bmRNYXNrQ292ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFja2dyb3VuZE1vZGUgPSB2b2lkIDA7XG5jbGFzcyBCYWNrZ3JvdW5kTW9kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuekluZGV4ID0gLTE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS56SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy56SW5kZXggPSBkYXRhLnpJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQmFja2dyb3VuZE1vZGUgPSBCYWNrZ3JvdW5kTW9kZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbmZlY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBJbmZlY3Rpb25TdGFnZV8xID0gcmVxdWlyZShcIi4vSW5mZWN0aW9uU3RhZ2VcIik7XG5jbGFzcyBJbmZlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmN1cmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxheSA9IDA7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5mZWN0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMuc3RhZ2VzID0gW107XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY3VyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cmUgPSBkYXRhLmN1cmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGVsYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxheSA9IGRhdGEuZGVsYXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuaW5mZWN0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmluZmVjdGlvbnMgPSBkYXRhLmluZmVjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc3RhZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YWdlcyA9IGRhdGEuc3RhZ2VzLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcyA9IG5ldyBJbmZlY3Rpb25TdGFnZV8xLkluZmVjdGlvblN0YWdlKCk7XG4gICAgICAgICAgICBzLmxvYWQodCk7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbmZlY3Rpb24gPSBJbmZlY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5mZWN0aW9uU3RhZ2UgPSB2b2lkIDA7XG5jb25zdCBPcHRpb25zQ29sb3JfMSA9IHJlcXVpcmUoXCIuLi9PcHRpb25zQ29sb3JcIik7XG5jbGFzcyBJbmZlY3Rpb25TdGFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yKCk7XG4gICAgICAgIHRoaXMuY29sb3IudmFsdWUgPSBcIiNmZjAwMDBcIjtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwO1xuICAgICAgICB0aGlzLnJhdGUgPSAxO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IuY3JlYXRlKHRoaXMuY29sb3IsIGRhdGEuY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuICAgICAgICB0aGlzLmluZmVjdGVkU3RhZ2UgPSBkYXRhLmluZmVjdGVkU3RhZ2U7XG4gICAgICAgIGlmIChkYXRhLnJhZGl1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IGRhdGEucmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yYXRlID0gZGF0YS5yYXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JbmZlY3Rpb25TdGFnZSA9IEluZmVjdGlvblN0YWdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWNrRXZlbnQgPSB2b2lkIDA7XG5jbGFzcyBDbGlja0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb2RlID0gW107XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBkYXRhLm1vZGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNsaWNrRXZlbnQgPSBDbGlja0V2ZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpdkV2ZW50ID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9FbnVtc1wiKTtcbmNsYXNzIERpdkV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb2RlID0gW107XG4gICAgICAgIHRoaXMudHlwZSA9IEVudW1zXzEuRGl2VHlwZS5jaXJjbGU7XG4gICAgfVxuICAgIGdldCBlbGVtZW50SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkcztcbiAgICB9XG4gICAgc2V0IGVsZW1lbnRJZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmlkcyA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRJZDtcbiAgICB9XG4gICAgc2V0IGVsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudElkID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBpZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdG9ycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RvcnMubWFwKCh0KSA9PiB0LnJlcGxhY2UoXCIjXCIsIFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9ycy5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgaWRzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IHZhbHVlLm1hcCgodCkgPT4gYCMke3R9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IGAjJHt2YWx1ZX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWRzID0gKF9iID0gKF9hID0gZGF0YS5pZHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGEuZWxlbWVudElkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkYXRhLmVsO1xuICAgICAgICBpZiAoaWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaWRzID0gaWRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNlbGVjdG9ycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IGRhdGEuc2VsZWN0b3JzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gZGF0YS5tb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gZGF0YS50eXBlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EaXZFdmVudCA9IERpdkV2ZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV2ZW50cyA9IHZvaWQgMDtcbmNvbnN0IENsaWNrRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0NsaWNrRXZlbnRcIik7XG5jb25zdCBEaXZFdmVudF8xID0gcmVxdWlyZShcIi4vRGl2RXZlbnRcIik7XG5jb25zdCBIb3ZlckV2ZW50XzEgPSByZXF1aXJlKFwiLi9Ib3ZlckV2ZW50XCIpO1xuY2xhc3MgRXZlbnRzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gbmV3IENsaWNrRXZlbnRfMS5DbGlja0V2ZW50KCk7XG4gICAgICAgIHRoaXMub25EaXYgPSBuZXcgRGl2RXZlbnRfMS5EaXZFdmVudCgpO1xuICAgICAgICB0aGlzLm9uSG92ZXIgPSBuZXcgSG92ZXJFdmVudF8xLkhvdmVyRXZlbnQoKTtcbiAgICAgICAgdGhpcy5yZXNpemUgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgb25jbGljaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25DbGljaztcbiAgICB9XG4gICAgc2V0IG9uY2xpY2sodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBvbmRpdigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25EaXY7XG4gICAgfVxuICAgIHNldCBvbmRpdih2YWx1ZSkge1xuICAgICAgICB0aGlzLm9uRGl2ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBvbmhvdmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbkhvdmVyO1xuICAgIH1cbiAgICBzZXQgb25ob3Zlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLm9uSG92ZXIgPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkNsaWNrLmxvYWQoKF9hID0gZGF0YS5vbkNsaWNrKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhLm9uY2xpY2spO1xuICAgICAgICBjb25zdCBvbkRpdiA9IChfYiA9IGRhdGEub25EaXYpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRhdGEub25kaXY7XG4gICAgICAgIGlmIChvbkRpdiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAob25EaXYgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25EaXYgPSBvbkRpdi5tYXAoKGRpdikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgRGl2RXZlbnRfMS5EaXZFdmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB0bXAubG9hZChkaXYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpdiA9IG5ldyBEaXZFdmVudF8xLkRpdkV2ZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpdi5sb2FkKG9uRGl2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uSG92ZXIubG9hZCgoX2MgPSBkYXRhLm9uSG92ZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRhdGEub25ob3Zlcik7XG4gICAgICAgIGlmIChkYXRhLnJlc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSA9IGRhdGEucmVzaXplO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5FdmVudHMgPSBFdmVudHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSG92ZXJFdmVudCA9IHZvaWQgMDtcbmNvbnN0IFBhcmFsbGF4XzEgPSByZXF1aXJlKFwiLi9QYXJhbGxheFwiKTtcbmNsYXNzIEhvdmVyRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vZGUgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJhbGxheCA9IG5ldyBQYXJhbGxheF8xLlBhcmFsbGF4KCk7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBkYXRhLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJhbGxheC5sb2FkKGRhdGEucGFyYWxsYXgpO1xuICAgIH1cbn1cbmV4cG9ydHMuSG92ZXJFdmVudCA9IEhvdmVyRXZlbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyYWxsYXggPSB2b2lkIDA7XG5jbGFzcyBQYXJhbGxheCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9yY2UgPSAyO1xuICAgICAgICB0aGlzLnNtb290aCA9IDEwO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmZvcmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yY2UgPSBkYXRhLmZvcmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNtb290aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNtb290aCA9IGRhdGEuc21vb3RoO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5QYXJhbGxheCA9IFBhcmFsbGF4O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludGVyYWN0aXZpdHkgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL0VudW1zXCIpO1xuY29uc3QgRXZlbnRzXzEgPSByZXF1aXJlKFwiLi9FdmVudHMvRXZlbnRzXCIpO1xuY29uc3QgTW9kZXNfMSA9IHJlcXVpcmUoXCIuL01vZGVzL01vZGVzXCIpO1xuY2xhc3MgSW50ZXJhY3Rpdml0eSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGV0ZWN0c09uID0gRW51bXNfMS5JbnRlcmFjdGl2aXR5RGV0ZWN0LmNhbnZhcztcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnRzXzEuRXZlbnRzKCk7XG4gICAgICAgIHRoaXMubW9kZXMgPSBuZXcgTW9kZXNfMS5Nb2RlcygpO1xuICAgIH1cbiAgICBnZXQgZGV0ZWN0X29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXRlY3RzT247XG4gICAgfVxuICAgIHNldCBkZXRlY3Rfb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXRlY3RzT24gPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGV0ZWN0c09uID0gKF9hID0gZGF0YS5kZXRlY3RzT24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGEuZGV0ZWN0X29uO1xuICAgICAgICBpZiAoZGV0ZWN0c09uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0c09uID0gZGV0ZWN0c09uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzLmxvYWQoZGF0YS5ldmVudHMpO1xuICAgICAgICB0aGlzLm1vZGVzLmxvYWQoZGF0YS5tb2Rlcyk7XG4gICAgICAgIGlmICgoKF9jID0gKF9iID0gZGF0YS5tb2RlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNsb3cpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hY3RpdmUpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMub25Ib3Zlci5tb2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudHMub25Ib3Zlci5tb2RlLmluZGV4T2YoRW51bXNfMS5Ib3Zlck1vZGUuc2xvdykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uSG92ZXIubW9kZS5wdXNoKEVudW1zXzEuSG92ZXJNb2RlLnNsb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZXZlbnRzLm9uSG92ZXIubW9kZSAhPT0gRW51bXNfMS5Ib3Zlck1vZGUuc2xvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uSG92ZXIubW9kZSA9IFt0aGlzLmV2ZW50cy5vbkhvdmVyLm1vZGUsIEVudW1zXzEuSG92ZXJNb2RlLnNsb3ddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmFjdGl2aXR5ID0gSW50ZXJhY3Rpdml0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdHRyYWN0ID0gdm9pZCAwO1xuY2xhc3MgQXR0cmFjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAyMDA7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwLjQ7XG4gICAgICAgIHRoaXMuc3BlZWQgPSAxO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRpc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBkYXRhLmRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNwZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBkYXRhLnNwZWVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BdHRyYWN0ID0gQXR0cmFjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Cb3VuY2UgPSB2b2lkIDA7XG5jbGFzcyBCb3VuY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gMjAwO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRhdGEuZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJvdW5jZSA9IEJvdW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CdWJibGUgPSB2b2lkIDA7XG5jb25zdCBCdWJibGVEaXZfMSA9IHJlcXVpcmUoXCIuL0J1YmJsZURpdlwiKTtcbmNvbnN0IEJ1YmJsZUJhc2VfMSA9IHJlcXVpcmUoXCIuL0J1YmJsZUJhc2VcIik7XG5jbGFzcyBCdWJibGUgZXh0ZW5kcyBCdWJibGVCYXNlXzEuQnViYmxlQmFzZSB7XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHN1cGVyLmxvYWQoZGF0YSk7XG4gICAgICAgIGlmICghKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhLmRpdnMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kaXZzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuZGl2cyA9IGRhdGEuZGl2cy5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgQnViYmxlRGl2XzEuQnViYmxlRGl2KCk7XG4gICAgICAgICAgICAgICAgdG1wLmxvYWQocyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGl2cyBpbnN0YW5jZW9mIEFycmF5IHx8ICF0aGlzLmRpdnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdnMgPSBuZXcgQnViYmxlRGl2XzEuQnViYmxlRGl2KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpdnMubG9hZChkYXRhLmRpdnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CdWJibGUgPSBCdWJibGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnViYmxlQmFzZSA9IHZvaWQgMDtcbmNvbnN0IE9wdGlvbnNDb2xvcl8xID0gcmVxdWlyZShcIi4uLy4uL09wdGlvbnNDb2xvclwiKTtcbmNsYXNzIEJ1YmJsZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gMjAwO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMC40O1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRpc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBkYXRhLmRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmNvbG9yIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yID0gZGF0YS5jb2xvci5tYXAoKHMpID0+IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodW5kZWZpbmVkLCBzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvciBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBuZXcgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IuY3JlYXRlKHRoaXMuY29sb3IsIGRhdGEuY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CdWJibGVCYXNlID0gQnViYmxlQmFzZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CdWJibGVEaXYgPSB2b2lkIDA7XG5jb25zdCBCdWJibGVCYXNlXzEgPSByZXF1aXJlKFwiLi9CdWJibGVCYXNlXCIpO1xuY2xhc3MgQnViYmxlRGl2IGV4dGVuZHMgQnViYmxlQmFzZV8xLkJ1YmJsZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IFtdO1xuICAgIH1cbiAgICBnZXQgaWRzKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RvcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3JzLm1hcCgodCkgPT4gdC5yZXBsYWNlKFwiI1wiLCBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RvcnMucmVwbGFjZShcIiNcIiwgXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0IGlkcyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSB2YWx1ZS5tYXAoKHQpID0+IGAjJHt0fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBgIyR7dmFsdWV9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgc3VwZXIubG9hZChkYXRhKTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmlkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmlkcyA9IGRhdGEuaWRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNlbGVjdG9ycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IGRhdGEuc2VsZWN0b3JzO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CdWJibGVEaXYgPSBCdWJibGVEaXY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdCA9IHZvaWQgMDtcbmNvbnN0IENvbm5lY3RMaW5rc18xID0gcmVxdWlyZShcIi4vQ29ubmVjdExpbmtzXCIpO1xuY2xhc3MgQ29ubmVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSA4MDtcbiAgICAgICAgdGhpcy5saW5rcyA9IG5ldyBDb25uZWN0TGlua3NfMS5Db25uZWN0TGlua3MoKTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSA2MDtcbiAgICB9XG4gICAgZ2V0IGxpbmVfbGlua2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5rcztcbiAgICB9XG4gICAgc2V0IGxpbmVfbGlua2VkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGlua3MgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGxpbmVMaW5rZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtzO1xuICAgIH1cbiAgICBzZXQgbGluZUxpbmtlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmxpbmtzID0gdmFsdWU7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRhdGEuZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5rcy5sb2FkKChfYiA9IChfYSA9IGRhdGEubGlua3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGEubGluZUxpbmtlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGF0YS5saW5lX2xpbmtlZCk7XG4gICAgICAgIGlmIChkYXRhLnJhZGl1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IGRhdGEucmFkaXVzO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0ID0gQ29ubmVjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25uZWN0TGlua3MgPSB2b2lkIDA7XG5jbGFzcyBDb25uZWN0TGlua3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSAwLjU7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YS5vcGFjaXR5ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdExpbmtzID0gQ29ubmVjdExpbmtzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdyYWIgPSB2b2lkIDA7XG5jb25zdCBHcmFiTGlua3NfMSA9IHJlcXVpcmUoXCIuL0dyYWJMaW5rc1wiKTtcbmNsYXNzIEdyYWIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gMTAwO1xuICAgICAgICB0aGlzLmxpbmtzID0gbmV3IEdyYWJMaW5rc18xLkdyYWJMaW5rcygpO1xuICAgIH1cbiAgICBnZXQgbGluZV9saW5rZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtzO1xuICAgIH1cbiAgICBzZXQgbGluZV9saW5rZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5saW5rcyA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgbGluZUxpbmtlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlua3M7XG4gICAgfVxuICAgIHNldCBsaW5lTGlua2VkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGlua3MgPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gZGF0YS5kaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtzLmxvYWQoKF9iID0gKF9hID0gZGF0YS5saW5rcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5saW5lTGlua2VkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkYXRhLmxpbmVfbGlua2VkKTtcbiAgICB9XG59XG5leHBvcnRzLkdyYWIgPSBHcmFiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdyYWJMaW5rcyA9IHZvaWQgMDtcbmNvbnN0IE9wdGlvbnNDb2xvcl8xID0gcmVxdWlyZShcIi4uLy4uL09wdGlvbnNDb2xvclwiKTtcbmNsYXNzIEdyYWJMaW5rcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmxpbmsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25zZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuYmxpbmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5ibGluayA9IGRhdGEuYmxpbms7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY29uc2VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnNlbnQgPSBkYXRhLmNvbnNlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBkYXRhLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkdyYWJMaW5rcyA9IEdyYWJMaW5rcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaWdodCA9IHZvaWQgMDtcbmNvbnN0IExpZ2h0QXJlYV8xID0gcmVxdWlyZShcIi4vTGlnaHRBcmVhXCIpO1xuY29uc3QgTGlnaHRTaGFkb3dfMSA9IHJlcXVpcmUoXCIuL0xpZ2h0U2hhZG93XCIpO1xuY2xhc3MgTGlnaHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFyZWEgPSBuZXcgTGlnaHRBcmVhXzEuTGlnaHRBcmVhKCk7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gbmV3IExpZ2h0U2hhZG93XzEuTGlnaHRTaGFkb3coKTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFyZWEubG9hZChkYXRhLmFyZWEpO1xuICAgICAgICB0aGlzLnNoYWRvdy5sb2FkKGRhdGEuc2hhZG93KTtcbiAgICB9XG59XG5leHBvcnRzLkxpZ2h0ID0gTGlnaHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlnaHRBcmVhID0gdm9pZCAwO1xuY29uc3QgTGlnaHRHcmFkaWVudF8xID0gcmVxdWlyZShcIi4vTGlnaHRHcmFkaWVudFwiKTtcbmNsYXNzIExpZ2h0QXJlYSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSBuZXcgTGlnaHRHcmFkaWVudF8xLkxpZ2h0R3JhZGllbnQoKTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAxMDAwO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhZGllbnQubG9hZChkYXRhLmdyYWRpZW50KTtcbiAgICAgICAgaWYgKGRhdGEucmFkaXVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gZGF0YS5yYWRpdXM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpZ2h0QXJlYSA9IExpZ2h0QXJlYTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaWdodEdyYWRpZW50ID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vT3B0aW9uc0NvbG9yXCIpO1xuY2xhc3MgTGlnaHRHcmFkaWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBuZXcgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yKCk7XG4gICAgICAgIHRoaXMuc3RvcCA9IG5ldyBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IoKTtcbiAgICAgICAgdGhpcy5zdGFydC52YWx1ZSA9IFwiI2ZmZmZmZlwiO1xuICAgICAgICB0aGlzLnN0b3AudmFsdWUgPSBcIiMwMDAwMDBcIjtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0ID0gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh0aGlzLnN0YXJ0LCBkYXRhLnN0YXJ0KTtcbiAgICAgICAgdGhpcy5zdG9wID0gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh0aGlzLnN0b3AsIGRhdGEuc3RvcCk7XG4gICAgfVxufVxuZXhwb3J0cy5MaWdodEdyYWRpZW50ID0gTGlnaHRHcmFkaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaWdodFNoYWRvdyA9IHZvaWQgMDtcbmNvbnN0IE9wdGlvbnNDb2xvcl8xID0gcmVxdWlyZShcIi4uLy4uL09wdGlvbnNDb2xvclwiKTtcbmNsYXNzIExpZ2h0U2hhZG93IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IoKTtcbiAgICAgICAgdGhpcy5jb2xvci52YWx1ZSA9IFwiIzAwMDAwMFwiO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDIwMDA7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaWdodFNoYWRvdyA9IExpZ2h0U2hhZG93O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vZGVzID0gdm9pZCAwO1xuY29uc3QgQnViYmxlXzEgPSByZXF1aXJlKFwiLi9CdWJibGVcIik7XG5jb25zdCBDb25uZWN0XzEgPSByZXF1aXJlKFwiLi9Db25uZWN0XCIpO1xuY29uc3QgR3JhYl8xID0gcmVxdWlyZShcIi4vR3JhYlwiKTtcbmNvbnN0IFJlbW92ZV8xID0gcmVxdWlyZShcIi4vUmVtb3ZlXCIpO1xuY29uc3QgUHVzaF8xID0gcmVxdWlyZShcIi4vUHVzaFwiKTtcbmNvbnN0IFJlcHVsc2VfMSA9IHJlcXVpcmUoXCIuL1JlcHVsc2VcIik7XG5jb25zdCBTbG93XzEgPSByZXF1aXJlKFwiLi9TbG93XCIpO1xuY29uc3QgVHJhaWxfMSA9IHJlcXVpcmUoXCIuL1RyYWlsXCIpO1xuY29uc3QgQXR0cmFjdF8xID0gcmVxdWlyZShcIi4vQXR0cmFjdFwiKTtcbmNvbnN0IExpZ2h0XzEgPSByZXF1aXJlKFwiLi9MaWdodFwiKTtcbmNvbnN0IEJvdW5jZV8xID0gcmVxdWlyZShcIi4vQm91bmNlXCIpO1xuY2xhc3MgTW9kZXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmF0dHJhY3QgPSBuZXcgQXR0cmFjdF8xLkF0dHJhY3QoKTtcbiAgICAgICAgdGhpcy5ib3VuY2UgPSBuZXcgQm91bmNlXzEuQm91bmNlKCk7XG4gICAgICAgIHRoaXMuYnViYmxlID0gbmV3IEJ1YmJsZV8xLkJ1YmJsZSgpO1xuICAgICAgICB0aGlzLmNvbm5lY3QgPSBuZXcgQ29ubmVjdF8xLkNvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5ncmFiID0gbmV3IEdyYWJfMS5HcmFiKCk7XG4gICAgICAgIHRoaXMubGlnaHQgPSBuZXcgTGlnaHRfMS5MaWdodCgpO1xuICAgICAgICB0aGlzLnB1c2ggPSBuZXcgUHVzaF8xLlB1c2goKTtcbiAgICAgICAgdGhpcy5yZW1vdmUgPSBuZXcgUmVtb3ZlXzEuUmVtb3ZlKCk7XG4gICAgICAgIHRoaXMucmVwdWxzZSA9IG5ldyBSZXB1bHNlXzEuUmVwdWxzZSgpO1xuICAgICAgICB0aGlzLnNsb3cgPSBuZXcgU2xvd18xLlNsb3coKTtcbiAgICAgICAgdGhpcy50cmFpbCA9IG5ldyBUcmFpbF8xLlRyYWlsKCk7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRyYWN0LmxvYWQoZGF0YS5hdHRyYWN0KTtcbiAgICAgICAgdGhpcy5idWJibGUubG9hZChkYXRhLmJ1YmJsZSk7XG4gICAgICAgIHRoaXMuY29ubmVjdC5sb2FkKGRhdGEuY29ubmVjdCk7XG4gICAgICAgIHRoaXMuZ3JhYi5sb2FkKGRhdGEuZ3JhYik7XG4gICAgICAgIHRoaXMubGlnaHQubG9hZChkYXRhLmxpZ2h0KTtcbiAgICAgICAgdGhpcy5wdXNoLmxvYWQoZGF0YS5wdXNoKTtcbiAgICAgICAgdGhpcy5yZW1vdmUubG9hZChkYXRhLnJlbW92ZSk7XG4gICAgICAgIHRoaXMucmVwdWxzZS5sb2FkKGRhdGEucmVwdWxzZSk7XG4gICAgICAgIHRoaXMuc2xvdy5sb2FkKGRhdGEuc2xvdyk7XG4gICAgICAgIHRoaXMudHJhaWwubG9hZChkYXRhLnRyYWlsKTtcbiAgICB9XG59XG5leHBvcnRzLk1vZGVzID0gTW9kZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHVzaCA9IHZvaWQgMDtcbmNsYXNzIFB1c2gge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnF1YW50aXR5ID0gNDtcbiAgICB9XG4gICAgZ2V0IHBhcnRpY2xlc19uYigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhbnRpdHk7XG4gICAgfVxuICAgIHNldCBwYXJ0aWNsZXNfbmIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5xdWFudGl0eSA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVhbnRpdHkgPSAoX2EgPSBkYXRhLnF1YW50aXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhLnBhcnRpY2xlc19uYjtcbiAgICAgICAgaWYgKHF1YW50aXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucXVhbnRpdHkgPSBxdWFudGl0eTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHVzaCA9IFB1c2g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVtb3ZlID0gdm9pZCAwO1xuY2xhc3MgUmVtb3ZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5xdWFudGl0eSA9IDI7XG4gICAgfVxuICAgIGdldCBwYXJ0aWNsZXNfbmIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YW50aXR5O1xuICAgIH1cbiAgICBzZXQgcGFydGljbGVzX25iKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucXVhbnRpdHkgPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1YW50aXR5ID0gKF9hID0gZGF0YS5xdWFudGl0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5wYXJ0aWNsZXNfbmI7XG4gICAgICAgIGlmIChxdWFudGl0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnF1YW50aXR5ID0gcXVhbnRpdHk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJlbW92ZSA9IFJlbW92ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXB1bHNlID0gdm9pZCAwO1xuY29uc3QgUmVwdWxzZURpdl8xID0gcmVxdWlyZShcIi4vUmVwdWxzZURpdlwiKTtcbmNvbnN0IFJlcHVsc2VCYXNlXzEgPSByZXF1aXJlKFwiLi9SZXB1bHNlQmFzZVwiKTtcbmNsYXNzIFJlcHVsc2UgZXh0ZW5kcyBSZXB1bHNlQmFzZV8xLlJlcHVsc2VCYXNlIHtcbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgc3VwZXIubG9hZChkYXRhKTtcbiAgICAgICAgaWYgKChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuZGl2cykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRpdnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5kaXZzID0gZGF0YS5kaXZzLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBSZXB1bHNlRGl2XzEuUmVwdWxzZURpdigpO1xuICAgICAgICAgICAgICAgIHRtcC5sb2FkKHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpdnMgaW5zdGFuY2VvZiBBcnJheSB8fCAhdGhpcy5kaXZzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXZzID0gbmV3IFJlcHVsc2VEaXZfMS5SZXB1bHNlRGl2KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpdnMubG9hZChkYXRhLmRpdnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZXB1bHNlID0gUmVwdWxzZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXB1bHNlQmFzZSA9IHZvaWQgMDtcbmNsYXNzIFJlcHVsc2VCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IDIwMDtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDAuNDtcbiAgICAgICAgdGhpcy5zcGVlZCA9IDE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRhdGEuZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc3BlZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IGRhdGEuc3BlZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJlcHVsc2VCYXNlID0gUmVwdWxzZUJhc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVwdWxzZURpdiA9IHZvaWQgMDtcbmNvbnN0IFJlcHVsc2VCYXNlXzEgPSByZXF1aXJlKFwiLi9SZXB1bHNlQmFzZVwiKTtcbmNsYXNzIFJlcHVsc2VEaXYgZXh0ZW5kcyBSZXB1bHNlQmFzZV8xLlJlcHVsc2VCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBbXTtcbiAgICB9XG4gICAgZ2V0IGlkcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3JzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9ycy5tYXAoKHQpID0+IHQucmVwbGFjZShcIiNcIiwgXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3JzLnJlcGxhY2UoXCIjXCIsIFwiXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBpZHModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JzID0gdmFsdWUubWFwKCgpID0+IGAjJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JzID0gYCMke3ZhbHVlfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHN1cGVyLmxvYWQoZGF0YSk7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5pZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pZHMgPSBkYXRhLmlkcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zZWxlY3RvcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBkYXRhLnNlbGVjdG9ycztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmVwdWxzZURpdiA9IFJlcHVsc2VEaXY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2xvdyA9IHZvaWQgMDtcbmNsYXNzIFNsb3cge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZhY3RvciA9IDM7XG4gICAgICAgIHRoaXMucmFkaXVzID0gMjAwO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNldCBhY3RpdmUoX3ZhbHVlKSB7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZmFjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yID0gZGF0YS5mYWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucmFkaXVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gZGF0YS5yYWRpdXM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNsb3cgPSBTbG93O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYWlsID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9VdGlsc1wiKTtcbmNsYXNzIFRyYWlsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kZWxheSA9IDE7XG4gICAgICAgIHRoaXMucXVhbnRpdHkgPSAxO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRlbGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXkgPSBkYXRhLmRlbGF5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnF1YW50aXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucXVhbnRpdHkgPSBkYXRhLnF1YW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnBhcnRpY2xlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcyA9IFV0aWxzXzEuVXRpbHMuZGVlcEV4dGVuZCh7fSwgZGF0YS5wYXJ0aWNsZXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UcmFpbCA9IFRyYWlsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1hbnVhbFBhcnRpY2xlID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNsYXNzIE1hbnVhbFBhcnRpY2xlIHtcbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiAoX2EgPSBkYXRhLnBvc2l0aW9uLngpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDUwLFxuICAgICAgICAgICAgICAgIHk6IChfYiA9IGRhdGEucG9zaXRpb24ueSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogNTAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCBkYXRhLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5NYW51YWxQYXJ0aWNsZSA9IE1hbnVhbFBhcnRpY2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vdGlvbiA9IHZvaWQgMDtcbmNvbnN0IE1vdGlvblJlZHVjZV8xID0gcmVxdWlyZShcIi4vTW90aW9uUmVkdWNlXCIpO1xuY2xhc3MgTW90aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVkdWNlID0gbmV3IE1vdGlvblJlZHVjZV8xLk1vdGlvblJlZHVjZSgpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGlzYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGUgPSBkYXRhLmRpc2FibGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWR1Y2UubG9hZChkYXRhLnJlZHVjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Nb3Rpb24gPSBNb3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW90aW9uUmVkdWNlID0gdm9pZCAwO1xuY2xhc3MgTW90aW9uUmVkdWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mYWN0b3IgPSA0O1xuICAgICAgICB0aGlzLnZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5mYWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mYWN0b3IgPSBkYXRhLmZhY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTW90aW9uUmVkdWNlID0gTW90aW9uUmVkdWNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBJbnRlcmFjdGl2aXR5XzEgPSByZXF1aXJlKFwiLi9JbnRlcmFjdGl2aXR5L0ludGVyYWN0aXZpdHlcIik7XG5jb25zdCBQYXJ0aWNsZXNfMSA9IHJlcXVpcmUoXCIuL1BhcnRpY2xlcy9QYXJ0aWNsZXNcIik7XG5jb25zdCBCYWNrZ3JvdW5kTWFza18xID0gcmVxdWlyZShcIi4vQmFja2dyb3VuZE1hc2svQmFja2dyb3VuZE1hc2tcIik7XG5jb25zdCBCYWNrZ3JvdW5kXzEgPSByZXF1aXJlKFwiLi9CYWNrZ3JvdW5kL0JhY2tncm91bmRcIik7XG5jb25zdCBJbmZlY3Rpb25fMSA9IHJlcXVpcmUoXCIuL0luZmVjdGlvbi9JbmZlY3Rpb25cIik7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY29uc3QgVGhlbWVfMSA9IHJlcXVpcmUoXCIuL1RoZW1lL1RoZW1lXCIpO1xuY29uc3QgTW9kZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9FbnVtcy9Nb2Rlc1wiKTtcbmNvbnN0IEJhY2tncm91bmRNb2RlXzEgPSByZXF1aXJlKFwiLi9CYWNrZ3JvdW5kTW9kZS9CYWNrZ3JvdW5kTW9kZVwiKTtcbmNvbnN0IE1vdGlvbl8xID0gcmVxdWlyZShcIi4vTW90aW9uL01vdGlvblwiKTtcbmNvbnN0IE1hbnVhbFBhcnRpY2xlXzEgPSByZXF1aXJlKFwiLi9NYW51YWxQYXJ0aWNsZVwiKTtcbmNsYXNzIE9wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmF1dG9QbGF5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3IEJhY2tncm91bmRfMS5CYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSBuZXcgQmFja2dyb3VuZE1hc2tfMS5CYWNrZ3JvdW5kTWFzaygpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRNb2RlID0gbmV3IEJhY2tncm91bmRNb2RlXzEuQmFja2dyb3VuZE1vZGUoKTtcbiAgICAgICAgdGhpcy5kZXRlY3RSZXRpbmEgPSB0cnVlO1xuICAgICAgICB0aGlzLmZwc0xpbWl0ID0gMzA7XG4gICAgICAgIHRoaXMuaW5mZWN0aW9uID0gbmV3IEluZmVjdGlvbl8xLkluZmVjdGlvbigpO1xuICAgICAgICB0aGlzLmludGVyYWN0aXZpdHkgPSBuZXcgSW50ZXJhY3Rpdml0eV8xLkludGVyYWN0aXZpdHkoKTtcbiAgICAgICAgdGhpcy5tYW51YWxQYXJ0aWNsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tb3Rpb24gPSBuZXcgTW90aW9uXzEuTW90aW9uKCk7XG4gICAgICAgIHRoaXMucGFydGljbGVzID0gbmV3IFBhcnRpY2xlc18xLlBhcnRpY2xlcygpO1xuICAgICAgICB0aGlzLnBhdXNlT25CbHVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXVzZU9uT3V0c2lkZVZpZXdwb3J0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGhlbWVzID0gW107XG4gICAgfVxuICAgIGdldCBmcHNfbGltaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZwc0xpbWl0O1xuICAgIH1cbiAgICBzZXQgZnBzX2xpbWl0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZnBzTGltaXQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHJldGluYV9kZXRlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRldGVjdFJldGluYTtcbiAgICB9XG4gICAgc2V0IHJldGluYV9kZXRlY3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXRlY3RSZXRpbmEgPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5wcmVzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGRhdGEucHJlc2V0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByZXNldCBvZiBkYXRhLnByZXNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydFByZXNldChwcmVzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0UHJlc2V0KGRhdGEucHJlc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5hdXRvUGxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9QbGF5ID0gZGF0YS5hdXRvUGxheTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXRlY3RSZXRpbmEgPSAoX2EgPSBkYXRhLmRldGVjdFJldGluYSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5yZXRpbmFfZGV0ZWN0O1xuICAgICAgICBpZiAoZGV0ZWN0UmV0aW5hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0UmV0aW5hID0gZGV0ZWN0UmV0aW5hO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZwc0xpbWl0ID0gKF9iID0gZGF0YS5mcHNMaW1pdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGF0YS5mcHNfbGltaXQ7XG4gICAgICAgIGlmIChmcHNMaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZwc0xpbWl0ID0gZnBzTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucGF1c2VPbkJsdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZU9uQmx1ciA9IGRhdGEucGF1c2VPbkJsdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucGF1c2VPbk91dHNpZGVWaWV3cG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlT25PdXRzaWRlVmlld3BvcnQgPSBkYXRhLnBhdXNlT25PdXRzaWRlVmlld3BvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLmxvYWQoZGF0YS5iYWNrZ3JvdW5kKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTW9kZS5sb2FkKGRhdGEuYmFja2dyb3VuZE1vZGUpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLmxvYWQoZGF0YS5iYWNrZ3JvdW5kTWFzayk7XG4gICAgICAgIHRoaXMuaW5mZWN0aW9uLmxvYWQoZGF0YS5pbmZlY3Rpb24pO1xuICAgICAgICB0aGlzLmludGVyYWN0aXZpdHkubG9hZChkYXRhLmludGVyYWN0aXZpdHkpO1xuICAgICAgICBpZiAoZGF0YS5tYW51YWxQYXJ0aWNsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5tYW51YWxQYXJ0aWNsZXMgPSBkYXRhLm1hbnVhbFBhcnRpY2xlcy5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgTWFudWFsUGFydGljbGVfMS5NYW51YWxQYXJ0aWNsZSgpO1xuICAgICAgICAgICAgICAgIHRtcC5sb2FkKHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdGlvbi5sb2FkKGRhdGEubW90aW9uKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMubG9hZChkYXRhLnBhcnRpY2xlcyk7XG4gICAgICAgIFV0aWxzXzEuUGx1Z2lucy5sb2FkT3B0aW9ucyh0aGlzLCBkYXRhKTtcbiAgICAgICAgaWYgKGRhdGEudGhlbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGhlbWUgb2YgZGF0YS50aGVtZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRUaGVtZSA9IG5ldyBUaGVtZV8xLlRoZW1lKCk7XG4gICAgICAgICAgICAgICAgb3B0VGhlbWUubG9hZCh0aGVtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZXMucHVzaChvcHRUaGVtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VGhlbWUobmFtZSkge1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgY29uc3QgY2hvc2VuVGhlbWUgPSB0aGlzLnRoZW1lcy5maW5kKCh0aGVtZSkgPT4gdGhlbWUubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICBpZiAoY2hvc2VuVGhlbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoY2hvc2VuVGhlbWUub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnREYXJrTW9kZSA9IHR5cGVvZiBtYXRjaE1lZGlhICE9PSBcInVuZGVmaW5lZFwiICYmIG1hdGNoTWVkaWEoXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIpLm1hdGNoZXM7XG4gICAgICAgICAgICBsZXQgZGVmYXVsdFRoZW1lID0gdGhpcy50aGVtZXMuZmluZCgodGhlbWUpID0+IHRoZW1lLmRlZmF1bHQudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAoKHRoZW1lLmRlZmF1bHQubW9kZSA9PT0gTW9kZXNfMS5UaGVtZU1vZGUuZGFyayAmJiBjbGllbnREYXJrTW9kZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoZW1lLmRlZmF1bHQubW9kZSA9PT0gTW9kZXNfMS5UaGVtZU1vZGUubGlnaHQgJiYgIWNsaWVudERhcmtNb2RlKSkpO1xuICAgICAgICAgICAgaWYgKCFkZWZhdWx0VGhlbWUpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGhlbWUgPSB0aGlzLnRoZW1lcy5maW5kKCh0aGVtZSkgPT4gdGhlbWUuZGVmYXVsdC52YWx1ZSAmJiB0aGVtZS5kZWZhdWx0Lm1vZGUgPT09IE1vZGVzXzEuVGhlbWVNb2RlLmFueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFRoZW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkKGRlZmF1bHRUaGVtZS5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbXBvcnRQcmVzZXQocHJlc2V0KSB7XG4gICAgICAgIHRoaXMubG9hZChVdGlsc18xLlBsdWdpbnMuZ2V0UHJlc2V0KHByZXNldCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3B0aW9uc0NvbG9yID0gdm9pZCAwO1xuY2xhc3MgT3B0aW9uc0NvbG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiI2ZmZlwiO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHNvdXJjZSwgZGF0YSkge1xuICAgICAgICBjb25zdCBjb2xvciA9IHNvdXJjZSAhPT0gbnVsbCAmJiBzb3VyY2UgIT09IHZvaWQgMCA/IHNvdXJjZSA6IG5ldyBPcHRpb25zQ29sb3IoKTtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29sb3IubG9hZCh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IHsgdmFsdWU6IGRhdGEgfSA6IGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmICgoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnZhbHVlKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5PcHRpb25zQ29sb3IgPSBPcHRpb25zQ29sb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW5pbWF0YWJsZUNvbG9yID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vT3B0aW9uc0NvbG9yXCIpO1xuY29uc3QgQ29sb3JBbmltYXRpb25fMSA9IHJlcXVpcmUoXCIuL0NvbG9yQW5pbWF0aW9uXCIpO1xuY2xhc3MgQW5pbWF0YWJsZUNvbG9yIGV4dGVuZHMgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBuZXcgQ29sb3JBbmltYXRpb25fMS5Db2xvckFuaW1hdGlvbigpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHNvdXJjZSwgZGF0YSkge1xuICAgICAgICBjb25zdCBjb2xvciA9IHNvdXJjZSAhPT0gbnVsbCAmJiBzb3VyY2UgIT09IHZvaWQgMCA/IHNvdXJjZSA6IG5ldyBBbmltYXRhYmxlQ29sb3IoKTtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29sb3IubG9hZCh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IHsgdmFsdWU6IGRhdGEgfSA6IGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHN1cGVyLmxvYWQoZGF0YSk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLmxvYWQoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmFuaW1hdGlvbik7XG4gICAgfVxufVxuZXhwb3J0cy5BbmltYXRhYmxlQ29sb3IgPSBBbmltYXRhYmxlQ29sb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQm91bmNlID0gdm9pZCAwO1xuY29uc3QgQm91bmNlRmFjdG9yXzEgPSByZXF1aXJlKFwiLi9Cb3VuY2VGYWN0b3JcIik7XG5jbGFzcyBCb3VuY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBuZXcgQm91bmNlRmFjdG9yXzEuQm91bmNlRmFjdG9yKCk7XG4gICAgICAgIHRoaXMudmVydGljYWwgPSBuZXcgQm91bmNlRmFjdG9yXzEuQm91bmNlRmFjdG9yKCk7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvcml6b250YWwubG9hZChkYXRhLmhvcml6b250YWwpO1xuICAgICAgICB0aGlzLnZlcnRpY2FsLmxvYWQoZGF0YS52ZXJ0aWNhbCk7XG4gICAgfVxufVxuZXhwb3J0cy5Cb3VuY2UgPSBCb3VuY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQm91bmNlRmFjdG9yID0gdm9pZCAwO1xuY29uc3QgVmFsdWVXaXRoUmFuZG9tXzEgPSByZXF1aXJlKFwiLi4vLi4vVmFsdWVXaXRoUmFuZG9tXCIpO1xuY2xhc3MgQm91bmNlRmFjdG9yIGV4dGVuZHMgVmFsdWVXaXRoUmFuZG9tXzEuVmFsdWVXaXRoUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yYW5kb20ubWluaW11bVZhbHVlID0gMC4xO1xuICAgICAgICB0aGlzLnZhbHVlID0gMTtcbiAgICB9XG59XG5leHBvcnRzLkJvdW5jZUZhY3RvciA9IEJvdW5jZUZhY3RvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2xsaXNpb25zID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9FbnVtc1wiKTtcbmNvbnN0IEJvdW5jZV8xID0gcmVxdWlyZShcIi4vQm91bmNlL0JvdW5jZVwiKTtcbmNsYXNzIENvbGxpc2lvbnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJvdW5jZSA9IG5ldyBCb3VuY2VfMS5Cb3VuY2UoKTtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb2RlID0gRW51bXNfMS5Db2xsaXNpb25Nb2RlLmJvdW5jZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvdW5jZS5sb2FkKGRhdGEuYm91bmNlKTtcbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBkYXRhLm1vZGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNvbGxpc2lvbnMgPSBDb2xsaXNpb25zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbG9yQW5pbWF0aW9uID0gdm9pZCAwO1xuY2xhc3MgQ29sb3JBbmltYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNwZWVkID0gMTtcbiAgICAgICAgdGhpcy5zeW5jID0gdHJ1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zcGVlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gZGF0YS5zcGVlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zeW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3luYyA9IGRhdGEuc3luYztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29sb3JBbmltYXRpb24gPSBDb2xvckFuaW1hdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaWZlID0gdm9pZCAwO1xuY29uc3QgTGlmZURlbGF5XzEgPSByZXF1aXJlKFwiLi9MaWZlRGVsYXlcIik7XG5jb25zdCBMaWZlRHVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL0xpZmVEdXJhdGlvblwiKTtcbmNsYXNzIExpZmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5kZWxheSA9IG5ldyBMaWZlRGVsYXlfMS5MaWZlRGVsYXkoKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IG5ldyBMaWZlRHVyYXRpb25fMS5MaWZlRHVyYXRpb24oKTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5jb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gZGF0YS5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGF5LmxvYWQoZGF0YS5kZWxheSk7XG4gICAgICAgIHRoaXMuZHVyYXRpb24ubG9hZChkYXRhLmR1cmF0aW9uKTtcbiAgICB9XG59XG5leHBvcnRzLkxpZmUgPSBMaWZlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpZmVEZWxheSA9IHZvaWQgMDtcbmNvbnN0IFZhbHVlV2l0aFJhbmRvbV8xID0gcmVxdWlyZShcIi4uLy4uL1ZhbHVlV2l0aFJhbmRvbVwiKTtcbmNsYXNzIExpZmVEZWxheSBleHRlbmRzIFZhbHVlV2l0aFJhbmRvbV8xLlZhbHVlV2l0aFJhbmRvbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubG9hZChkYXRhKTtcbiAgICAgICAgaWYgKGRhdGEuc3luYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnN5bmMgPSBkYXRhLnN5bmM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpZmVEZWxheSA9IExpZmVEZWxheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaWZlRHVyYXRpb24gPSB2b2lkIDA7XG5jb25zdCBWYWx1ZVdpdGhSYW5kb21fMSA9IHJlcXVpcmUoXCIuLi8uLi9WYWx1ZVdpdGhSYW5kb21cIik7XG5jbGFzcyBMaWZlRHVyYXRpb24gZXh0ZW5kcyBWYWx1ZVdpdGhSYW5kb21fMS5WYWx1ZVdpdGhSYW5kb20ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJhbmRvbS5taW5pbXVtVmFsdWUgPSAwLjAwMDE7XG4gICAgICAgIHRoaXMuc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmxvYWQoZGF0YSk7XG4gICAgICAgIGlmIChkYXRhLnN5bmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zeW5jID0gZGF0YS5zeW5jO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaWZlRHVyYXRpb24gPSBMaWZlRHVyYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlua3MgPSB2b2lkIDA7XG5jb25zdCBMaW5rc1NoYWRvd18xID0gcmVxdWlyZShcIi4vTGlua3NTaGFkb3dcIik7XG5jb25zdCBMaW5rc1RyaWFuZ2xlXzEgPSByZXF1aXJlKFwiLi9MaW5rc1RyaWFuZ2xlXCIpO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vT3B0aW9uc0NvbG9yXCIpO1xuY2xhc3MgTGlua3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJsaW5rID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yKCk7XG4gICAgICAgIHRoaXMuY29uc2VudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gMTAwO1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IDE7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gbmV3IExpbmtzU2hhZG93XzEuTGlua3NTaGFkb3coKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZXMgPSBuZXcgTGlua3NUcmlhbmdsZV8xLkxpbmtzVHJpYW5nbGUoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IDE7XG4gICAgICAgIHRoaXMud2FycCA9IGZhbHNlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBkYXRhLmlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmJsaW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmxpbmsgPSBkYXRhLmJsaW5rO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sb3IgPSBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IuY3JlYXRlKHRoaXMuY29sb3IsIGRhdGEuY29sb3IpO1xuICAgICAgICBpZiAoZGF0YS5jb25zZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc2VudCA9IGRhdGEuY29uc2VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gZGF0YS5kaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5mcmVxdWVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBkYXRhLmZyZXF1ZW5jeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGRhdGEub3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoYWRvdy5sb2FkKGRhdGEuc2hhZG93KTtcbiAgICAgICAgdGhpcy50cmlhbmdsZXMubG9hZChkYXRhLnRyaWFuZ2xlcyk7XG4gICAgICAgIGlmIChkYXRhLndpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLndhcnAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy53YXJwID0gZGF0YS53YXJwO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rcyA9IExpbmtzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpbmtzU2hhZG93ID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vT3B0aW9uc0NvbG9yXCIpO1xuY2xhc3MgTGlua3NTaGFkb3cge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJsdXIgPSA1O1xuICAgICAgICB0aGlzLmNvbG9yID0gbmV3IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvcigpO1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbG9yLnZhbHVlID0gXCIjMDBmZjAwXCI7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuYmx1ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmJsdXIgPSBkYXRhLmJsdXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rc1NoYWRvdyA9IExpbmtzU2hhZG93O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpbmtzVHJpYW5nbGUgPSB2b2lkIDA7XG5jb25zdCBPcHRpb25zQ29sb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9PcHRpb25zQ29sb3JcIik7XG5jbGFzcyBMaW5rc1RyaWFuZ2xlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSAxO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IuY3JlYXRlKHRoaXMuY29sb3IsIGRhdGEuY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmZyZXF1ZW5jeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IGRhdGEuZnJlcXVlbmN5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rc1RyaWFuZ2xlID0gTGlua3NUcmlhbmdsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdHRyYWN0ID0gdm9pZCAwO1xuY2xhc3MgQXR0cmFjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucm90YXRlID0ge1xuICAgICAgICAgICAgeDogMzAwMCxcbiAgICAgICAgICAgIHk6IDMwMDAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCByb3RhdGVYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGUueDtcbiAgICB9XG4gICAgc2V0IHJvdGF0ZVgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yb3RhdGUueCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcm90YXRlWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlLnk7XG4gICAgfVxuICAgIHNldCByb3RhdGVZKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucm90YXRlLnkgPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdGF0ZVggPSAoX2IgPSAoX2EgPSBkYXRhLnJvdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLngpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRhdGEucm90YXRlWDtcbiAgICAgICAgaWYgKHJvdGF0ZVggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGUueCA9IHJvdGF0ZVg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm90YXRlWSA9IChfZCA9IChfYyA9IGRhdGEucm90YXRlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MueSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGF0YS5yb3RhdGVZO1xuICAgICAgICBpZiAocm90YXRlWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZS55ID0gcm90YXRlWTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXR0cmFjdCA9IEF0dHJhY3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW92ZSA9IHZvaWQgMDtcbmNvbnN0IEF0dHJhY3RfMSA9IHJlcXVpcmUoXCIuL0F0dHJhY3RcIik7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0VudW1zXCIpO1xuY29uc3QgVHJhaWxfMSA9IHJlcXVpcmUoXCIuL1RyYWlsXCIpO1xuY29uc3QgTm9pc2VfMSA9IHJlcXVpcmUoXCIuL05vaXNlL05vaXNlXCIpO1xuY29uc3QgTW92ZUFuZ2xlXzEgPSByZXF1aXJlKFwiLi9Nb3ZlQW5nbGVcIik7XG5jb25zdCBNb3ZlR3Jhdml0eV8xID0gcmVxdWlyZShcIi4vTW92ZUdyYXZpdHlcIik7XG5jb25zdCBPdXRNb2Rlc18xID0gcmVxdWlyZShcIi4vT3V0TW9kZXNcIik7XG5jbGFzcyBNb3ZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbmdsZSA9IG5ldyBNb3ZlQW5nbGVfMS5Nb3ZlQW5nbGUoKTtcbiAgICAgICAgdGhpcy5hdHRyYWN0ID0gbmV3IEF0dHJhY3RfMS5BdHRyYWN0KCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gRW51bXNfMS5Nb3ZlRGlyZWN0aW9uLm5vbmU7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdyYXZpdHkgPSBuZXcgTW92ZUdyYXZpdHlfMS5Nb3ZlR3Jhdml0eSgpO1xuICAgICAgICB0aGlzLm5vaXNlID0gbmV3IE5vaXNlXzEuTm9pc2UoKTtcbiAgICAgICAgdGhpcy5vdXRNb2RlcyA9IG5ldyBPdXRNb2Rlc18xLk91dE1vZGVzKCk7XG4gICAgICAgIHRoaXMucmFuZG9tID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNwZWVkID0gMjtcbiAgICAgICAgdGhpcy5zdHJhaWdodCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYWlsID0gbmV3IFRyYWlsXzEuVHJhaWwoKTtcbiAgICAgICAgdGhpcy52aWJyYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FycCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgY29sbGlzaW9ucygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZXQgY29sbGlzaW9ucyh2YWx1ZSkge1xuICAgIH1cbiAgICBnZXQgYm91bmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaXNpb25zO1xuICAgIH1cbiAgICBzZXQgYm91bmNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29sbGlzaW9ucyA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgb3V0X21vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dE1vZGU7XG4gICAgfVxuICAgIHNldCBvdXRfbW9kZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLm91dE1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IG91dE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dE1vZGVzLmRlZmF1bHQ7XG4gICAgfVxuICAgIHNldCBvdXRNb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3V0TW9kZXMuZGVmYXVsdCA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmFuZ2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS5hbmdsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5nbGUudmFsdWUgPSBkYXRhLmFuZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmdsZS5sb2FkKGRhdGEuYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0cmFjdC5sb2FkKGRhdGEuYXR0cmFjdCk7XG4gICAgICAgIGlmIChkYXRhLmRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGRhdGEuZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRpc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBkYXRhLmRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3Jhdml0eS5sb2FkKGRhdGEuZ3Jhdml0eSk7XG4gICAgICAgIHRoaXMubm9pc2UubG9hZChkYXRhLm5vaXNlKTtcbiAgICAgICAgY29uc3Qgb3V0TW9kZSA9IChfYSA9IGRhdGEub3V0TW9kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5vdXRfbW9kZTtcbiAgICAgICAgaWYgKGRhdGEub3V0TW9kZXMgIT09IHVuZGVmaW5lZCB8fCBvdXRNb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS5vdXRNb2RlcyA9PT0gXCJzdHJpbmdcIiB8fCAoZGF0YS5vdXRNb2RlcyA9PT0gdW5kZWZpbmVkICYmIG91dE1vZGUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dE1vZGVzLmxvYWQoe1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiAoX2IgPSBkYXRhLm91dE1vZGVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBvdXRNb2RlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRNb2Rlcy5sb2FkKGRhdGEub3V0TW9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnJhbmRvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmRvbSA9IGRhdGEucmFuZG9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNwZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBkYXRhLnNwZWVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnN0cmFpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyYWlnaHQgPSBkYXRhLnN0cmFpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhaWwubG9hZChkYXRhLnRyYWlsKTtcbiAgICAgICAgaWYgKGRhdGEudmlicmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpYnJhdGUgPSBkYXRhLnZpYnJhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEud2FycCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLndhcnAgPSBkYXRhLndhcnA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk1vdmUgPSBNb3ZlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vdmVBbmdsZSA9IHZvaWQgMDtcbmNsYXNzIE1vdmVBbmdsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gNDU7XG4gICAgICAgIHRoaXMudmFsdWUgPSA5MDtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBkYXRhLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTW92ZUFuZ2xlID0gTW92ZUFuZ2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vdmVHcmF2aXR5ID0gdm9pZCAwO1xuY2xhc3MgTW92ZUdyYXZpdHkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IDkuODE7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4U3BlZWQgPSA1MDtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmFjY2VsZXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IGRhdGEuYWNjZWxlcmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm1heFNwZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWF4U3BlZWQgPSBkYXRhLm1heFNwZWVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Nb3ZlR3Jhdml0eSA9IE1vdmVHcmF2aXR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vaXNlID0gdm9pZCAwO1xuY29uc3QgTm9pc2VEZWxheV8xID0gcmVxdWlyZShcIi4vTm9pc2VEZWxheVwiKTtcbmNsYXNzIE5vaXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kZWxheSA9IG5ldyBOb2lzZURlbGF5XzEuTm9pc2VEZWxheSgpO1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsYXkubG9hZChkYXRhLmRlbGF5KTtcbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk5vaXNlID0gTm9pc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm9pc2VEZWxheSA9IHZvaWQgMDtcbmNvbnN0IFZhbHVlV2l0aFJhbmRvbV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL1ZhbHVlV2l0aFJhbmRvbVwiKTtcbmNsYXNzIE5vaXNlRGVsYXkgZXh0ZW5kcyBWYWx1ZVdpdGhSYW5kb21fMS5WYWx1ZVdpdGhSYW5kb20ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9pc2VEZWxheSA9IE5vaXNlRGVsYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3V0TW9kZXMgPSB2b2lkIDA7XG5jb25zdCBNb2Rlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0VudW1zL01vZGVzXCIpO1xuY2xhc3MgT3V0TW9kZXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBNb2Rlc18xLk91dE1vZGUub3V0O1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdCA9IGRhdGEuZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvdHRvbSA9IChfYSA9IGRhdGEuYm90dG9tKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMubGVmdCA9IChfYiA9IGRhdGEubGVmdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGF0YS5kZWZhdWx0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gKF9jID0gZGF0YS5yaWdodCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGF0YS5kZWZhdWx0O1xuICAgICAgICB0aGlzLnRvcCA9IChfZCA9IGRhdGEudG9wKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkYXRhLmRlZmF1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRNb2RlcyA9IE91dE1vZGVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYWlsID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vT3B0aW9uc0NvbG9yXCIpO1xuY2xhc3MgVHJhaWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDEwO1xuICAgICAgICB0aGlzLmZpbGxDb2xvciA9IG5ldyBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IoKTtcbiAgICAgICAgdGhpcy5maWxsQ29sb3IudmFsdWUgPSBcIiMwMDAwMDBcIjtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbGxDb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5maWxsQ29sb3IsIGRhdGEuZmlsbENvbG9yKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlRyYWlsID0gVHJhaWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVuc2l0eSA9IHZvaWQgMDtcbmNsYXNzIERlbnNpdHkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFyZWEgPSA4MDA7XG4gICAgICAgIHRoaXMuZmFjdG9yID0gMTAwMDtcbiAgICB9XG4gICAgZ2V0IHZhbHVlX2FyZWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZWE7XG4gICAgfVxuICAgIHNldCB2YWx1ZV9hcmVhKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXJlYSA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJlYSA9IChfYSA9IGRhdGEuYXJlYSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS52YWx1ZV9hcmVhO1xuICAgICAgICBpZiAoYXJlYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmZhY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZhY3RvciA9IGRhdGEuZmFjdG9yO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EZW5zaXR5ID0gRGVuc2l0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJ0aWNsZXNOdW1iZXIgPSB2b2lkIDA7XG5jb25zdCBEZW5zaXR5XzEgPSByZXF1aXJlKFwiLi9EZW5zaXR5XCIpO1xuY2xhc3MgUGFydGljbGVzTnVtYmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kZW5zaXR5ID0gbmV3IERlbnNpdHlfMS5EZW5zaXR5KCk7XG4gICAgICAgIHRoaXMubGltaXQgPSAwO1xuICAgICAgICB0aGlzLnZhbHVlID0gMTAwO1xuICAgIH1cbiAgICBnZXQgbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW1pdDtcbiAgICB9XG4gICAgc2V0IG1heCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmxpbWl0ID0gdmFsdWU7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbnNpdHkubG9hZChkYXRhLmRlbnNpdHkpO1xuICAgICAgICBjb25zdCBsaW1pdCA9IChfYSA9IGRhdGEubGltaXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGEubWF4O1xuICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5QYXJ0aWNsZXNOdW1iZXIgPSBQYXJ0aWNsZXNOdW1iZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3BhY2l0eSA9IHZvaWQgMDtcbmNvbnN0IE9wYWNpdHlBbmltYXRpb25fMSA9IHJlcXVpcmUoXCIuL09wYWNpdHlBbmltYXRpb25cIik7XG5jb25zdCBWYWx1ZVdpdGhSYW5kb21fMSA9IHJlcXVpcmUoXCIuLi8uLi9WYWx1ZVdpdGhSYW5kb21cIik7XG5jbGFzcyBPcGFjaXR5IGV4dGVuZHMgVmFsdWVXaXRoUmFuZG9tXzEuVmFsdWVXaXRoUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBuZXcgT3BhY2l0eUFuaW1hdGlvbl8xLk9wYWNpdHlBbmltYXRpb24oKTtcbiAgICAgICAgdGhpcy5yYW5kb20ubWluaW11bVZhbHVlID0gMC4xO1xuICAgICAgICB0aGlzLnZhbHVlID0gMTtcbiAgICB9XG4gICAgZ2V0IGFuaW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbjtcbiAgICB9XG4gICAgc2V0IGFuaW0odmFsdWUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubG9hZChkYXRhKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb24ubG9hZCgoX2EgPSBkYXRhLmFuaW1hdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5hbmltKTtcbiAgICB9XG59XG5leHBvcnRzLk9wYWNpdHkgPSBPcGFjaXR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9wYWNpdHlBbmltYXRpb24gPSB2b2lkIDA7XG5jb25zdCBUeXBlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0VudW1zL1R5cGVzXCIpO1xuY2xhc3MgT3BhY2l0eUFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSA9IFR5cGVzXzEuRGVzdHJveVR5cGUubm9uZTtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5taW5pbXVtVmFsdWUgPSAwO1xuICAgICAgICB0aGlzLnNwZWVkID0gMjtcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gVHlwZXNfMS5TdGFydFZhbHVlVHlwZS5yYW5kb207XG4gICAgICAgIHRoaXMuc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgb3BhY2l0eV9taW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbmltdW1WYWx1ZTtcbiAgICB9XG4gICAgc2V0IG9wYWNpdHlfbWluKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWluaW11bVZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSA9IGRhdGEuZGVzdHJveTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW5pbXVtVmFsdWUgPSAoX2EgPSBkYXRhLm1pbmltdW1WYWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5vcGFjaXR5X21pbjtcbiAgICAgICAgaWYgKG1pbmltdW1WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1pbmltdW1WYWx1ZSA9IG1pbmltdW1WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zcGVlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gZGF0YS5zcGVlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zdGFydFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRWYWx1ZSA9IGRhdGEuc3RhcnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zeW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3luYyA9IGRhdGEuc3luYztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuT3BhY2l0eUFuaW1hdGlvbiA9IE9wYWNpdHlBbmltYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFydGljbGVzID0gdm9pZCAwO1xuY29uc3QgTGlua3NfMSA9IHJlcXVpcmUoXCIuL0xpbmtzL0xpbmtzXCIpO1xuY29uc3QgTW92ZV8xID0gcmVxdWlyZShcIi4vTW92ZS9Nb3ZlXCIpO1xuY29uc3QgUGFydGljbGVzTnVtYmVyXzEgPSByZXF1aXJlKFwiLi9OdW1iZXIvUGFydGljbGVzTnVtYmVyXCIpO1xuY29uc3QgT3BhY2l0eV8xID0gcmVxdWlyZShcIi4vT3BhY2l0eS9PcGFjaXR5XCIpO1xuY29uc3QgU2hhcGVfMSA9IHJlcXVpcmUoXCIuL1NoYXBlL1NoYXBlXCIpO1xuY29uc3QgU2l6ZV8xID0gcmVxdWlyZShcIi4vU2l6ZS9TaXplXCIpO1xuY29uc3QgUm90YXRlXzEgPSByZXF1aXJlKFwiLi9Sb3RhdGUvUm90YXRlXCIpO1xuY29uc3QgU2hhZG93XzEgPSByZXF1aXJlKFwiLi9TaGFkb3dcIik7XG5jb25zdCBTdHJva2VfMSA9IHJlcXVpcmUoXCIuL1N0cm9rZVwiKTtcbmNvbnN0IENvbGxpc2lvbnNfMSA9IHJlcXVpcmUoXCIuL0NvbGxpc2lvbnNcIik7XG5jb25zdCBUd2lua2xlXzEgPSByZXF1aXJlKFwiLi9Ud2lua2xlL1R3aW5rbGVcIik7XG5jb25zdCBBbmltYXRhYmxlQ29sb3JfMSA9IHJlcXVpcmUoXCIuL0FuaW1hdGFibGVDb2xvclwiKTtcbmNvbnN0IExpZmVfMSA9IHJlcXVpcmUoXCIuL0xpZmUvTGlmZVwiKTtcbmNvbnN0IEJvdW5jZV8xID0gcmVxdWlyZShcIi4vQm91bmNlL0JvdW5jZVwiKTtcbmNsYXNzIFBhcnRpY2xlcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYm91bmNlID0gbmV3IEJvdW5jZV8xLkJvdW5jZSgpO1xuICAgICAgICB0aGlzLmNvbGxpc2lvbnMgPSBuZXcgQ29sbGlzaW9uc18xLkNvbGxpc2lvbnMoKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBBbmltYXRhYmxlQ29sb3JfMS5BbmltYXRhYmxlQ29sb3IoKTtcbiAgICAgICAgdGhpcy5saWZlID0gbmV3IExpZmVfMS5MaWZlKCk7XG4gICAgICAgIHRoaXMubGlua3MgPSBuZXcgTGlua3NfMS5MaW5rcygpO1xuICAgICAgICB0aGlzLm1vdmUgPSBuZXcgTW92ZV8xLk1vdmUoKTtcbiAgICAgICAgdGhpcy5udW1iZXIgPSBuZXcgUGFydGljbGVzTnVtYmVyXzEuUGFydGljbGVzTnVtYmVyKCk7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IG5ldyBPcGFjaXR5XzEuT3BhY2l0eSgpO1xuICAgICAgICB0aGlzLnJlZHVjZUR1cGxpY2F0ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb3RhdGUgPSBuZXcgUm90YXRlXzEuUm90YXRlKCk7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gbmV3IFNoYWRvd18xLlNoYWRvdygpO1xuICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFNoYXBlXzEuU2hhcGUoKTtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3IFNpemVfMS5TaXplKCk7XG4gICAgICAgIHRoaXMuc3Ryb2tlID0gbmV3IFN0cm9rZV8xLlN0cm9rZSgpO1xuICAgICAgICB0aGlzLnR3aW5rbGUgPSBuZXcgVHdpbmtsZV8xLlR3aW5rbGUoKTtcbiAgICB9XG4gICAgZ2V0IGxpbmVfbGlua2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5rcztcbiAgICB9XG4gICAgc2V0IGxpbmVfbGlua2VkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGlua3MgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGxpbmVMaW5rZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtzO1xuICAgIH1cbiAgICBzZXQgbGluZUxpbmtlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmxpbmtzID0gdmFsdWU7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvdW5jZS5sb2FkKGRhdGEuYm91bmNlKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IEFuaW1hdGFibGVDb2xvcl8xLkFuaW1hdGFibGVDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgIHRoaXMubGlmZS5sb2FkKGRhdGEubGlmZSk7XG4gICAgICAgIGNvbnN0IGxpbmtzID0gKF9iID0gKF9hID0gZGF0YS5saW5rcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5saW5lTGlua2VkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkYXRhLmxpbmVfbGlua2VkO1xuICAgICAgICBpZiAobGlua3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5saW5rcy5sb2FkKGxpbmtzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmUubG9hZChkYXRhLm1vdmUpO1xuICAgICAgICB0aGlzLm51bWJlci5sb2FkKGRhdGEubnVtYmVyKTtcbiAgICAgICAgdGhpcy5vcGFjaXR5LmxvYWQoZGF0YS5vcGFjaXR5KTtcbiAgICAgICAgaWYgKGRhdGEucmVkdWNlRHVwbGljYXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlZHVjZUR1cGxpY2F0ZXMgPSBkYXRhLnJlZHVjZUR1cGxpY2F0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3RhdGUubG9hZChkYXRhLnJvdGF0ZSk7XG4gICAgICAgIHRoaXMuc2hhcGUubG9hZChkYXRhLnNoYXBlKTtcbiAgICAgICAgdGhpcy5zaXplLmxvYWQoZGF0YS5zaXplKTtcbiAgICAgICAgdGhpcy5zaGFkb3cubG9hZChkYXRhLnNoYWRvdyk7XG4gICAgICAgIHRoaXMudHdpbmtsZS5sb2FkKGRhdGEudHdpbmtsZSk7XG4gICAgICAgIGNvbnN0IGNvbGxpc2lvbnMgPSAoX2QgPSAoX2MgPSBkYXRhLm1vdmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jb2xsaXNpb25zKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAoX2UgPSBkYXRhLm1vdmUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5ib3VuY2U7XG4gICAgICAgIGlmIChjb2xsaXNpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9ucy5lbmFibGUgPSBjb2xsaXNpb25zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGlzaW9ucy5sb2FkKGRhdGEuY29sbGlzaW9ucyk7XG4gICAgICAgIGNvbnN0IHN0cm9rZVRvTG9hZCA9IChfZiA9IGRhdGEuc3Ryb2tlKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAoX2cgPSBkYXRhLnNoYXBlKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuc3Ryb2tlO1xuICAgICAgICBpZiAoc3Ryb2tlVG9Mb2FkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Ryb2tlVG9Mb2FkIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlID0gc3Ryb2tlVG9Mb2FkLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBTdHJva2VfMS5TdHJva2UoKTtcbiAgICAgICAgICAgICAgICB0bXAubG9hZChzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJva2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Ryb2tlID0gbmV3IFN0cm9rZV8xLlN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdHJva2UubG9hZChzdHJva2VUb0xvYWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5QYXJ0aWNsZXMgPSBQYXJ0aWNsZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUm90YXRlID0gdm9pZCAwO1xuY29uc3QgUm90YXRlQW5pbWF0aW9uXzEgPSByZXF1aXJlKFwiLi9Sb3RhdGVBbmltYXRpb25cIik7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0VudW1zXCIpO1xuY29uc3QgVmFsdWVXaXRoUmFuZG9tXzEgPSByZXF1aXJlKFwiLi4vLi4vVmFsdWVXaXRoUmFuZG9tXCIpO1xuY2xhc3MgUm90YXRlIGV4dGVuZHMgVmFsdWVXaXRoUmFuZG9tXzEuVmFsdWVXaXRoUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBuZXcgUm90YXRlQW5pbWF0aW9uXzEuUm90YXRlQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gRW51bXNfMS5Sb3RhdGVEaXJlY3Rpb24uY2xvY2t3aXNlO1xuICAgICAgICB0aGlzLnBhdGggPSBmYWxzZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmxvYWQoZGF0YSk7XG4gICAgICAgIGlmIChkYXRhLmRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGRhdGEuZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLmxvYWQoZGF0YS5hbmltYXRpb24pO1xuICAgICAgICBpZiAoZGF0YS5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IGRhdGEucGF0aDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUm90YXRlID0gUm90YXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJvdGF0ZUFuaW1hdGlvbiA9IHZvaWQgMDtcbmNsYXNzIFJvdGF0ZUFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3BlZWQgPSAwO1xuICAgICAgICB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zcGVlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gZGF0YS5zcGVlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zeW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3luYyA9IGRhdGEuc3luYztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUm90YXRlQW5pbWF0aW9uID0gUm90YXRlQW5pbWF0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNoYWRvdyA9IHZvaWQgMDtcbmNvbnN0IE9wdGlvbnNDb2xvcl8xID0gcmVxdWlyZShcIi4uL09wdGlvbnNDb2xvclwiKTtcbmNsYXNzIFNoYWRvdyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmx1ciA9IDA7XG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yKCk7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29sb3IudmFsdWUgPSBcIiMwMDAwMDBcIjtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5ibHVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmx1ciA9IGRhdGEuYmx1cjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbG9yID0gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh0aGlzLmNvbG9yLCBkYXRhLmNvbG9yKTtcbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEub2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5vZmZzZXQueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldC54ID0gZGF0YS5vZmZzZXQueDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5vZmZzZXQueSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldC55ID0gZGF0YS5vZmZzZXQueTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2hhZG93ID0gU2hhZG93O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNoYXBlID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9FbnVtc1wiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vVXRpbHNcIik7XG5jbGFzcyBTaGFwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnR5cGUgPSBFbnVtc18xLlNoYXBlVHlwZS5jaXJjbGU7XG4gICAgfVxuICAgIGdldCBpbWFnZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMub3B0aW9uc1tFbnVtc18xLlNoYXBlVHlwZS5pbWFnZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMub3B0aW9uc1tFbnVtc18xLlNoYXBlVHlwZS5pbWFnZXNdKTtcbiAgICB9XG4gICAgc2V0IGltYWdlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1tFbnVtc18xLlNoYXBlVHlwZS5pbWFnZV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zW0VudW1zXzEuU2hhcGVUeXBlLmltYWdlc10gPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGN1c3RvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICB9XG4gICAgc2V0IGN1c3RvbSh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGltYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMuaW1hZ2UgOiBbdGhpcy5pbWFnZV07XG4gICAgfVxuICAgIHNldCBpbWFnZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbWFnZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgc3Ryb2tlKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHNldCBzdHJva2UoX3ZhbHVlKSB7XG4gICAgfVxuICAgIGdldCBjaGFyYWN0ZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLm9wdGlvbnNbRW51bXNfMS5TaGFwZVR5cGUuY2hhcmFjdGVyXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5vcHRpb25zW0VudW1zXzEuU2hhcGVUeXBlLmNoYXJdKTtcbiAgICB9XG4gICAgc2V0IGNoYXJhY3Rlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnNbRW51bXNfMS5TaGFwZVR5cGUuY2hhcmFjdGVyXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9wdGlvbnNbRW51bXNfMS5TaGFwZVR5cGUuY2hhcl0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHBvbHlnb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLm9wdGlvbnNbRW51bXNfMS5TaGFwZVR5cGUucG9seWdvbl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMub3B0aW9uc1tFbnVtc18xLlNoYXBlVHlwZS5zdGFyXSk7XG4gICAgfVxuICAgIHNldCBwb2x5Z29uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1tFbnVtc18xLlNoYXBlVHlwZS5wb2x5Z29uXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9wdGlvbnNbRW51bXNfMS5TaGFwZVR5cGUuc3Rhcl0gPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IChfYSA9IGRhdGEub3B0aW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5jdXN0b207XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2hhcGUgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBvcHRpb25zW3NoYXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tzaGFwZV0gPSBVdGlsc18xLlV0aWxzLmRlZXBFeHRlbmQoKF9iID0gdGhpcy5vcHRpb25zW3NoYXBlXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30sIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRTaGFwZShkYXRhLmNoYXJhY3RlciwgRW51bXNfMS5TaGFwZVR5cGUuY2hhcmFjdGVyLCBFbnVtc18xLlNoYXBlVHlwZS5jaGFyLCB0cnVlKTtcbiAgICAgICAgdGhpcy5sb2FkU2hhcGUoZGF0YS5wb2x5Z29uLCBFbnVtc18xLlNoYXBlVHlwZS5wb2x5Z29uLCBFbnVtc18xLlNoYXBlVHlwZS5zdGFyLCBmYWxzZSk7XG4gICAgICAgIHRoaXMubG9hZFNoYXBlKChfYyA9IGRhdGEuaW1hZ2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRhdGEuaW1hZ2VzLCBFbnVtc18xLlNoYXBlVHlwZS5pbWFnZSwgRW51bXNfMS5TaGFwZVR5cGUuaW1hZ2VzLCB0cnVlKTtcbiAgICAgICAgaWYgKGRhdGEudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBkYXRhLnR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9hZFNoYXBlKGl0ZW0sIG1haW5LZXksIGFsdEtleSwgYWx0T3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5vcHRpb25zW21haW5LZXldIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW21haW5LZXldID0gW107XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNbYWx0S2V5XSB8fCBhbHRPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbYWx0S2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1ttYWluS2V5XSA9IFV0aWxzXzEuVXRpbHMuZGVlcEV4dGVuZCgoX2EgPSB0aGlzLm9wdGlvbnNbbWFpbktleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLCBpdGVtKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zW2FsdEtleV0gfHwgYWx0T3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbYWx0S2V5XSA9IFV0aWxzXzEuVXRpbHMuZGVlcEV4dGVuZCgoX2IgPSB0aGlzLm9wdGlvbnNbYWx0S2V5XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1ttYWluS2V5XSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW21haW5LZXldID0ge307XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNbYWx0S2V5XSB8fCBhbHRPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbYWx0S2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1ttYWluS2V5XSA9IFV0aWxzXzEuVXRpbHMuZGVlcEV4dGVuZCgoX2MgPSB0aGlzLm9wdGlvbnNbbWFpbktleV0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LCBpdGVtKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zW2FsdEtleV0gfHwgYWx0T3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbYWx0S2V5XSA9IFV0aWxzXzEuVXRpbHMuZGVlcEV4dGVuZCgoX2QgPSB0aGlzLm9wdGlvbnNbYWx0S2V5XSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDoge30sIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TaGFwZSA9IFNoYXBlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpemUgPSB2b2lkIDA7XG5jb25zdCBTaXplQW5pbWF0aW9uXzEgPSByZXF1aXJlKFwiLi9TaXplQW5pbWF0aW9uXCIpO1xuY29uc3QgVmFsdWVXaXRoUmFuZG9tXzEgPSByZXF1aXJlKFwiLi4vLi4vVmFsdWVXaXRoUmFuZG9tXCIpO1xuY2xhc3MgU2l6ZSBleHRlbmRzIFZhbHVlV2l0aFJhbmRvbV8xLlZhbHVlV2l0aFJhbmRvbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IFNpemVBbmltYXRpb25fMS5TaXplQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMucmFuZG9tLm1pbmltdW1WYWx1ZSA9IDE7XG4gICAgICAgIHRoaXMudmFsdWUgPSAzO1xuICAgIH1cbiAgICBnZXQgYW5pbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uO1xuICAgIH1cbiAgICBzZXQgYW5pbSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5sb2FkKGRhdGEpO1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSAoX2EgPSBkYXRhLmFuaW1hdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5hbmltO1xuICAgICAgICBpZiAoYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmxvYWQoYW5pbWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2l6ZSA9IFNpemU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2l6ZUFuaW1hdGlvbiA9IHZvaWQgMDtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vRW51bXNcIik7XG5jbGFzcyBTaXplQW5pbWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gRW51bXNfMS5EZXN0cm95VHlwZS5ub25lO1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1pbmltdW1WYWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuc3BlZWQgPSA1O1xuICAgICAgICB0aGlzLnN0YXJ0VmFsdWUgPSBFbnVtc18xLlN0YXJ0VmFsdWVUeXBlLnJhbmRvbTtcbiAgICAgICAgdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBzaXplX21pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluaW11bVZhbHVlO1xuICAgIH1cbiAgICBzZXQgc2l6ZV9taW4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5taW5pbXVtVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95ID0gZGF0YS5kZXN0cm95O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbmltdW1WYWx1ZSA9IChfYSA9IGRhdGEubWluaW11bVZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhLnNpemVfbWluO1xuICAgICAgICBpZiAobWluaW11bVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWluaW11bVZhbHVlID0gbWluaW11bVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNwZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBkYXRhLnNwZWVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnN0YXJ0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gZGF0YS5zdGFydFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnN5bmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zeW5jID0gZGF0YS5zeW5jO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TaXplQW5pbWF0aW9uID0gU2l6ZUFuaW1hdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJva2UgPSB2b2lkIDA7XG5jb25zdCBBbmltYXRhYmxlQ29sb3JfMSA9IHJlcXVpcmUoXCIuL0FuaW1hdGFibGVDb2xvclwiKTtcbmNsYXNzIFN0cm9rZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBBbmltYXRhYmxlQ29sb3JfMS5BbmltYXRhYmxlQ29sb3IuY3JlYXRlKHRoaXMuY29sb3IsIGRhdGEuY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLndpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdHJva2UgPSBTdHJva2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHdpbmtsZSA9IHZvaWQgMDtcbmNvbnN0IFR3aW5rbGVWYWx1ZXNfMSA9IHJlcXVpcmUoXCIuL1R3aW5rbGVWYWx1ZXNcIik7XG5jbGFzcyBUd2lua2xlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5saW5lcyA9IG5ldyBUd2lua2xlVmFsdWVzXzEuVHdpbmtsZVZhbHVlcygpO1xuICAgICAgICB0aGlzLnBhcnRpY2xlcyA9IG5ldyBUd2lua2xlVmFsdWVzXzEuVHdpbmtsZVZhbHVlcygpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGluZXMubG9hZChkYXRhLmxpbmVzKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMubG9hZChkYXRhLnBhcnRpY2xlcyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ud2lua2xlID0gVHdpbmtsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ud2lua2xlVmFsdWVzID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vT3B0aW9uc0NvbG9yXCIpO1xuY2xhc3MgVHdpbmtsZVZhbHVlcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gMC4wNTtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh0aGlzLmNvbG9yLCBkYXRhLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5mcmVxdWVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBkYXRhLmZyZXF1ZW5jeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGRhdGEub3BhY2l0eTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVHdpbmtsZVZhbHVlcyA9IFR3aW5rbGVWYWx1ZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmFuZG9tID0gdm9pZCAwO1xuY2xhc3MgUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5taW5pbXVtVmFsdWUgPSAwO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubWluaW11bVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWluaW11bVZhbHVlID0gZGF0YS5taW5pbXVtVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJhbmRvbSA9IFJhbmRvbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UaGVtZSA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVXRpbHNcIik7XG5jb25zdCBUaGVtZURlZmF1bHRfMSA9IHJlcXVpcmUoXCIuL1RoZW1lRGVmYXVsdFwiKTtcbmNsYXNzIFRoZW1lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gbmV3IFRoZW1lRGVmYXVsdF8xLlRoZW1lRGVmYXVsdCgpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVmYXVsdC5sb2FkKGRhdGEuZGVmYXVsdCk7XG4gICAgICAgIGlmIChkYXRhLm9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCBkYXRhLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UaGVtZSA9IFRoZW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRoZW1lRGVmYXVsdCA9IHZvaWQgMDtcbmNvbnN0IE1vZGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vRW51bXMvTW9kZXNcIik7XG5jbGFzcyBUaGVtZURlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBNb2Rlc18xLlRoZW1lTW9kZS5hbnk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGRhdGEubW9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVGhlbWVEZWZhdWx0ID0gVGhlbWVEZWZhdWx0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbHVlV2l0aFJhbmRvbSA9IHZvaWQgMDtcbmNvbnN0IFJhbmRvbV8xID0gcmVxdWlyZShcIi4vUmFuZG9tXCIpO1xuY2xhc3MgVmFsdWVXaXRoUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yYW5kb20gPSBuZXcgUmFuZG9tXzEuUmFuZG9tKCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSAwO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLnJhbmRvbSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMucmFuZG9tLmVuYWJsZSA9IGRhdGEucmFuZG9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYW5kb20ubG9hZChkYXRhLnJhbmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlZhbHVlV2l0aFJhbmRvbSA9IFZhbHVlV2l0aFJhbmRvbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BYnNvcmJlckluc3RhbmNlID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNsYXNzIEFic29yYmVySW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGFic29yYmVycywgY29udGFpbmVyLCBvcHRpb25zLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmFic29yYmVycyA9IGFic29yYmVycztcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuaW5pdGlhbFBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0VmFsdWUob3B0aW9ucy5zaXplKSAqIGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5tYXNzID0gdGhpcy5zaXplICogb3B0aW9ucy5zaXplLmRlbnNpdHkgKiBjb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcjtcbiAgICAgICAgY29uc3QgbGltaXQgPSBvcHRpb25zLnNpemUubGltaXQ7XG4gICAgICAgIHRoaXMubGltaXQgPSBsaW1pdCAhPT0gdW5kZWZpbmVkID8gbGltaXQgKiBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW8gKiBjb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvciA6IGxpbWl0O1xuICAgICAgICBjb25zdCBjb2xvciA9IHR5cGVvZiBvcHRpb25zLmNvbG9yID09PSBcInN0cmluZ1wiID8geyB2YWx1ZTogb3B0aW9ucy5jb2xvciB9IDogb3B0aW9ucy5jb2xvcjtcbiAgICAgICAgdGhpcy5jb2xvciA9IChfYSA9IFV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvUmdiKGNvbG9yKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge1xuICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgIGc6IDAsXG4gICAgICAgICAgICByOiAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gKF9iID0gdGhpcy5pbml0aWFsUG9zaXRpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuY2FsY1Bvc2l0aW9uKCk7XG4gICAgfVxuICAgIGF0dHJhY3QocGFydGljbGUpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZSA9IHRoaXMuY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2U7XG4gICAgICAgICAgICBpZiAobW91c2UuY2xpY2tpbmcgJiYgbW91c2UuZG93blBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2VEaXN0ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZSh0aGlzLnBvc2l0aW9uLCBtb3VzZS5kb3duUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZURpc3QgPD0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nICYmIG1vdXNlLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0gbW91c2UucG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSBtb3VzZS5wb3NpdGlvbi55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcyA9IHBhcnRpY2xlLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgZHgsIGR5LCBkaXN0YW5jZSB9ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZXModGhpcy5wb3NpdGlvbiwgcG9zKTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKGR4LCBkeSk7XG4gICAgICAgIGNvbnN0IGFjY2VsZXJhdGlvbiA9ICh0aGlzLm1hc3MgLyBNYXRoLnBvdyhkaXN0YW5jZSwgMikpICogdGhpcy5jb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcjtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgdGhpcy5zaXplICsgcGFydGljbGUuZ2V0UmFkaXVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemVGYWN0b3IgPSBwYXJ0aWNsZS5nZXRSYWRpdXMoKSAqIDAuMDMzICogdGhpcy5jb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgICAgICBpZiAodGhpcy5zaXplID4gcGFydGljbGUuZ2V0UmFkaXVzKCkgJiYgZGlzdGFuY2UgPCB0aGlzLnNpemUgLSBwYXJ0aWNsZS5nZXRSYWRpdXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUubmVlZHNOZXdQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGFydGljbGVQb3NpdGlvbihwYXJ0aWNsZSwgYW5nbGUsIGFjY2VsZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5zaXplLnZhbHVlIC09IHNpemVGYWN0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGFydGljbGVQb3NpdGlvbihwYXJ0aWNsZSwgYW5nbGUsIGFjY2VsZXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5saW1pdCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuc2l6ZSA8IHRoaXMubGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgKz0gc2l6ZUZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWFzcyArPSBzaXplRmFjdG9yICogdGhpcy5vcHRpb25zLnNpemUuZGVuc2l0eSAqIHRoaXMuY29udGFpbmVyLnJldGluYS5yZWR1Y2VGYWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhcnRpY2xlUG9zaXRpb24ocGFydGljbGUsIGFuZ2xlLCBhY2NlbGVyYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2l6ZSgpIHtcbiAgICAgICAgY29uc3QgaW5pdGlhbFBvc2l0aW9uID0gdGhpcy5pbml0aWFsUG9zaXRpb247XG4gICAgICAgIHRoaXMucG9zaXRpb24gPVxuICAgICAgICAgICAgaW5pdGlhbFBvc2l0aW9uICYmIFV0aWxzXzEuVXRpbHMuaXNQb2ludEluc2lkZShpbml0aWFsUG9zaXRpb24sIHRoaXMuY29udGFpbmVyLmNhbnZhcy5zaXplKVxuICAgICAgICAgICAgICAgID8gaW5pdGlhbFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgOiB0aGlzLmNhbGNQb3NpdGlvbigpO1xuICAgIH1cbiAgICBkcmF3KGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUodGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnkpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmFyYygwLCAwLCB0aGlzLnNpemUsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gVXRpbHNfMS5Db2xvclV0aWxzLmdldFN0eWxlRnJvbVJnYih0aGlzLmNvbG9yLCB0aGlzLm9wYWNpdHkpO1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gICAgY2FsY1Bvc2l0aW9uKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcGVyY2VudFBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogKCgoX2EgPSBwZXJjZW50UG9zaXRpb24gPT09IG51bGwgfHwgcGVyY2VudFBvc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJjZW50UG9zaXRpb24ueCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTWF0aC5yYW5kb20oKSAqIDEwMCkgLyAxMDApICogY29udGFpbmVyLmNhbnZhcy5zaXplLndpZHRoLFxuICAgICAgICAgICAgeTogKCgoX2IgPSBwZXJjZW50UG9zaXRpb24gPT09IG51bGwgfHwgcGVyY2VudFBvc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJjZW50UG9zaXRpb24ueSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogTWF0aC5yYW5kb20oKSAqIDEwMCkgLyAxMDApICogY29udGFpbmVyLmNhbnZhcy5zaXplLmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlUGFydGljbGVQb3NpdGlvbihwYXJ0aWNsZSwgYW5nbGUsIGFjY2VsZXJhdGlvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChwYXJ0aWNsZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW52YXNTaXplID0gdGhpcy5jb250YWluZXIuY2FudmFzLnNpemU7XG4gICAgICAgIGlmIChwYXJ0aWNsZS5uZWVkc05ld1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwU2l6ZSA9IHBhcnRpY2xlLmdldFJhZGl1cygpO1xuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueCA9IE1hdGgucmFuZG9tKCkgKiAoY2FudmFzU2l6ZS53aWR0aCAtIHBTaXplICogMikgKyBwU2l6ZTtcbiAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnkgPSBNYXRoLnJhbmRvbSgpICogKGNhbnZhc1NpemUuaGVpZ2h0IC0gcFNpemUgKiAyKSArIHBTaXplO1xuICAgICAgICAgICAgcGFydGljbGUubmVlZHNOZXdQb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3JiaXRzKSB7XG4gICAgICAgICAgICBpZiAocGFydGljbGUub3JiaXRSYWRpdXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLm9yYml0UmFkaXVzID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShwYXJ0aWNsZS5nZXRQb3NpdGlvbigpLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5vcmJpdFJhZGl1cyA8PSB0aGlzLnNpemUgJiYgIXRoaXMub3B0aW9ucy5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUub3JiaXRSYWRpdXMgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5tYXgoY2FudmFzU2l6ZS53aWR0aCwgY2FudmFzU2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnRpY2xlLm9yYml0QW5nbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLm9yYml0QW5nbGUgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcmJpdFJhZGl1cyA9IHBhcnRpY2xlLm9yYml0UmFkaXVzO1xuICAgICAgICAgICAgY29uc3Qgb3JiaXRBbmdsZSA9IHBhcnRpY2xlLm9yYml0QW5nbGU7XG4gICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS5ob3Jpem9udGFsID0gMDtcbiAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnZlcnRpY2FsID0gMDtcbiAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnggPSB0aGlzLnBvc2l0aW9uLnggKyBvcmJpdFJhZGl1cyAqIE1hdGguY29zKG9yYml0QW5nbGUpO1xuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueSA9IHRoaXMucG9zaXRpb24ueSArIG9yYml0UmFkaXVzICogTWF0aC5zaW4ob3JiaXRBbmdsZSk7XG4gICAgICAgICAgICBwYXJ0aWNsZS5vcmJpdFJhZGl1cyAtPSBhY2NlbGVyYXRpb247XG4gICAgICAgICAgICBwYXJ0aWNsZS5vcmJpdEFuZ2xlICs9XG4gICAgICAgICAgICAgICAgKCgoX2EgPSBwYXJ0aWNsZS5tb3ZlU3BlZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuY29udGFpbmVyLnJldGluYS5tb3ZlU3BlZWQpIC8gMTAwKSAqIHRoaXMuY29udGFpbmVyLnJldGluYS5yZWR1Y2VGYWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS5ob3Jpem9udGFsICs9IE1hdGguc2luKGFuZ2xlKSAqIGFjY2VsZXJhdGlvbjtcbiAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnZlcnRpY2FsICs9IE1hdGguY29zKGFuZ2xlKSAqIGFjY2VsZXJhdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzb3JiZXJJbnN0YW5jZSA9IEFic29yYmVySW5zdGFuY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzb3JiZXJzID0gdm9pZCAwO1xuY29uc3QgQWJzb3JiZXJJbnN0YW5jZV8xID0gcmVxdWlyZShcIi4vQWJzb3JiZXJJbnN0YW5jZVwiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jb25zdCBBYnNvcmJlcl8xID0gcmVxdWlyZShcIi4vT3B0aW9ucy9DbGFzc2VzL0Fic29yYmVyXCIpO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xuY2xhc3MgQWJzb3JiZXJzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICAgICAgdGhpcy5hYnNvcmJlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2aXR5QWJzb3JiZXJzID0gW107XG4gICAgICAgIGNvbnN0IG92ZXJyaWRhYmxlQ29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICBvdmVycmlkYWJsZUNvbnRhaW5lci5hZGRBYnNvcmJlciA9IChvcHRpb25zLCBwb3NpdGlvbikgPT4gdGhpcy5hZGRBYnNvcmJlcihvcHRpb25zLCBwb3NpdGlvbik7XG4gICAgfVxuICAgIGluaXQob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hYnNvcmJlcnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFic29yYmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hYnNvcmJlcnMgPSBvcHRpb25zLmFic29yYmVycy5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IEFic29yYmVyXzEuQWJzb3JiZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wLmxvYWQocyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hYnNvcmJlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFic29yYmVycyA9IG5ldyBBYnNvcmJlcl8xLkFic29yYmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWJzb3JiZXJzLmxvYWQob3B0aW9ucy5hYnNvcmJlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludGVyYWN0aXZpdHlBYnNvcmJlcnMgPSAoX2IgPSAoX2EgPSBvcHRpb25zLmludGVyYWN0aXZpdHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFic29yYmVycztcbiAgICAgICAgaWYgKGludGVyYWN0aXZpdHlBYnNvcmJlcnMpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcmFjdGl2aXR5QWJzb3JiZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aXZpdHlBYnNvcmJlcnMgPSBpbnRlcmFjdGl2aXR5QWJzb3JiZXJzLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgQWJzb3JiZXJfMS5BYnNvcmJlcigpO1xuICAgICAgICAgICAgICAgICAgICB0bXAubG9hZChzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVyYWN0aXZpdHlBYnNvcmJlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aXZpdHlBYnNvcmJlcnMgPSBuZXcgQWJzb3JiZXJfMS5BYnNvcmJlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aXZpdHlBYnNvcmJlcnMubG9hZChpbnRlcmFjdGl2aXR5QWJzb3JiZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hYnNvcmJlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhYnNvcmJlck9wdGlvbnMgb2YgdGhpcy5hYnNvcmJlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEFic29yYmVyKGFic29yYmVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZEFic29yYmVyKHRoaXMuYWJzb3JiZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJ0aWNsZVVwZGF0ZShwYXJ0aWNsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGFic29yYmVyIG9mIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIGFic29yYmVyLmF0dHJhY3QocGFydGljbGUpO1xuICAgICAgICAgICAgaWYgKHBhcnRpY2xlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcoY29udGV4dCkge1xuICAgICAgICBmb3IgKGNvbnN0IGFic29yYmVyIG9mIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgYWJzb3JiZXIuZHJhdyhjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICB9XG4gICAgcmVzaXplKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGFic29yYmVyIG9mIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIGFic29yYmVyLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNsaWNrTW9kZShtb2RlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBhYnNvcmJlck9wdGlvbnMgPSB0aGlzLmFic29yYmVycztcbiAgICAgICAgY29uc3QgbW9kZUFic29yYmVycyA9IHRoaXMuaW50ZXJhY3Rpdml0eUFic29yYmVycztcbiAgICAgICAgaWYgKG1vZGUgPT09IEVudW1zXzEuQWJzb3JiZXJDbGlja01vZGUuYWJzb3JiZXIpIHtcbiAgICAgICAgICAgIGxldCBhYnNvcmJlcnNNb2RlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChtb2RlQWJzb3JiZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZUFic29yYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFic29yYmVyc01vZGVPcHRpb25zID0gVXRpbHNfMS5VdGlscy5pdGVtRnJvbUFycmF5KG1vZGVBYnNvcmJlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFic29yYmVyc01vZGVPcHRpb25zID0gbW9kZUFic29yYmVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFic29yYmVyc09wdGlvbnMgPSBhYnNvcmJlcnNNb2RlT3B0aW9ucyAhPT0gbnVsbCAmJiBhYnNvcmJlcnNNb2RlT3B0aW9ucyAhPT0gdm9pZCAwID8gYWJzb3JiZXJzTW9kZU9wdGlvbnMgOiAoYWJzb3JiZXJPcHRpb25zIGluc3RhbmNlb2YgQXJyYXkgPyBVdGlsc18xLlV0aWxzLml0ZW1Gcm9tQXJyYXkoYWJzb3JiZXJPcHRpb25zKSA6IGFic29yYmVyT3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBhUG9zaXRpb24gPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5jbGlja1Bvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5hZGRBYnNvcmJlcihhYnNvcmJlcnNPcHRpb25zLCBhUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEFic29yYmVyKG9wdGlvbnMsIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFic29yYmVyID0gbmV3IEFic29yYmVySW5zdGFuY2VfMS5BYnNvcmJlckluc3RhbmNlKHRoaXMsIHRoaXMuY29udGFpbmVyLCBvcHRpb25zLCBwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuYXJyYXkucHVzaChhYnNvcmJlcik7XG4gICAgICAgIHJldHVybiBhYnNvcmJlcjtcbiAgICB9XG4gICAgcmVtb3ZlQWJzb3JiZXIoYWJzb3JiZXIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmFycmF5LmluZGV4T2YoYWJzb3JiZXIpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5hcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BYnNvcmJlcnMgPSBBYnNvcmJlcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BYnNvcmJlcnNQbHVnaW4gPSB2b2lkIDA7XG5jb25zdCBBYnNvcmJlcnNfMSA9IHJlcXVpcmUoXCIuL0Fic29yYmVyc1wiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4vRW51bXNcIik7XG5jb25zdCBBYnNvcmJlcl8xID0gcmVxdWlyZShcIi4vT3B0aW9ucy9DbGFzc2VzL0Fic29yYmVyXCIpO1xuY2xhc3MgQWJzb3JiZXJzUGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pZCA9IFwiYWJzb3JiZXJzXCI7XG4gICAgfVxuICAgIGdldFBsdWdpbihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBYnNvcmJlcnNfMS5BYnNvcmJlcnMoY29udGFpbmVyKTtcbiAgICB9XG4gICAgbmVlZHNQbHVnaW4ob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFic29yYmVycyA9IG9wdGlvbnMuYWJzb3JiZXJzO1xuICAgICAgICBsZXQgbG9hZEFic29yYmVycyA9IGZhbHNlO1xuICAgICAgICBpZiAoYWJzb3JiZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChhYnNvcmJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9hZEFic29yYmVycyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWJzb3JiZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvYWRBYnNvcmJlcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoX2MgPSAoX2IgPSAoX2EgPSBvcHRpb25zLmludGVyYWN0aXZpdHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmVudHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbkNsaWNrKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubW9kZSkgJiZcbiAgICAgICAgICAgIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuQWJzb3JiZXJDbGlja01vZGUuYWJzb3JiZXIsIG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25DbGljay5tb2RlKSkge1xuICAgICAgICAgICAgbG9hZEFic29yYmVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvYWRBYnNvcmJlcnM7XG4gICAgfVxuICAgIGxvYWRPcHRpb25zKG9wdGlvbnMsIHNvdXJjZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIXRoaXMubmVlZHNQbHVnaW4ob3B0aW9ucykgJiYgIXRoaXMubmVlZHNQbHVnaW4oc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnNDYXN0ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZS5hYnNvcmJlcnMpIHtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlLmFic29yYmVycykgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNDYXN0LmFic29yYmVycyA9IHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZS5hYnNvcmJlcnMubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBBYnNvcmJlcl8xLkFic29yYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5sb2FkKHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGFic29yYmVyT3B0aW9ucyA9IG9wdGlvbnNDYXN0LmFic29yYmVycztcbiAgICAgICAgICAgICAgICBpZiAoKGFic29yYmVyT3B0aW9ucyA9PT0gbnVsbCB8fCBhYnNvcmJlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFic29yYmVyT3B0aW9ucy5sb2FkKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNDYXN0LmFic29yYmVycyA9IGFic29yYmVyT3B0aW9ucyA9IG5ldyBBYnNvcmJlcl8xLkFic29yYmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFic29yYmVyT3B0aW9ucy5sb2FkKHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZS5hYnNvcmJlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludGVyYWN0aXZpdHlBYnNvcmJlcnMgPSAoX2IgPSAoX2EgPSBzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2UuaW50ZXJhY3Rpdml0eSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vZGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJzb3JiZXJzO1xuICAgICAgICBpZiAoaW50ZXJhY3Rpdml0eUFic29yYmVycykge1xuICAgICAgICAgICAgaWYgKGludGVyYWN0aXZpdHlBYnNvcmJlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNDYXN0LmludGVyYWN0aXZpdHkubW9kZXMuYWJzb3JiZXJzID0gaW50ZXJhY3Rpdml0eUFic29yYmVycy5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IEFic29yYmVyXzEuQWJzb3JiZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wLmxvYWQocyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYWJzb3JiZXJPcHRpb25zID0gb3B0aW9uc0Nhc3QuaW50ZXJhY3Rpdml0eS5tb2Rlcy5hYnNvcmJlcnM7XG4gICAgICAgICAgICAgICAgaWYgKChhYnNvcmJlck9wdGlvbnMgPT09IG51bGwgfHwgYWJzb3JiZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYnNvcmJlck9wdGlvbnMubG9hZCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zQ2FzdC5pbnRlcmFjdGl2aXR5Lm1vZGVzLmFic29yYmVycyA9IGFic29yYmVyT3B0aW9ucyA9IG5ldyBBYnNvcmJlcl8xLkFic29yYmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFic29yYmVyT3B0aW9ucy5sb2FkKGludGVyYWN0aXZpdHlBYnNvcmJlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgcGx1Z2luID0gbmV3IEFic29yYmVyc1BsdWdpbigpO1xuZXhwb3J0cy5BYnNvcmJlcnNQbHVnaW4gPSBwbHVnaW47XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRW51bXNcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFic29yYmVyQ2xpY2tNb2RlID0gdm9pZCAwO1xudmFyIEFic29yYmVyQ2xpY2tNb2RlO1xuKGZ1bmN0aW9uIChBYnNvcmJlckNsaWNrTW9kZSkge1xuICAgIEFic29yYmVyQ2xpY2tNb2RlW1wiYWJzb3JiZXJcIl0gPSBcImFic29yYmVyXCI7XG59KShBYnNvcmJlckNsaWNrTW9kZSA9IGV4cG9ydHMuQWJzb3JiZXJDbGlja01vZGUgfHwgKGV4cG9ydHMuQWJzb3JiZXJDbGlja01vZGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9BYnNvcmJlckNsaWNrTW9kZVwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzb3JiZXIgPSB2b2lkIDA7XG5jb25zdCBBYnNvcmJlclNpemVfMSA9IHJlcXVpcmUoXCIuL0Fic29yYmVyU2l6ZVwiKTtcbmNvbnN0IE9wdGlvbnNDb2xvcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL09wdGlvbnMvQ2xhc3Nlcy9PcHRpb25zQ29sb3JcIik7XG5jbGFzcyBBYnNvcmJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yKCk7XG4gICAgICAgIHRoaXMuY29sb3IudmFsdWUgPSBcIiMwMDAwMDBcIjtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcmJpdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3IEFic29yYmVyU2l6ZV8xLkFic29yYmVyU2l6ZSgpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IuY3JlYXRlKHRoaXMuY29sb3IsIGRhdGEuY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRyYWdnYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IGRhdGEuZHJhZ2dhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogZGF0YS5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgIHk6IGRhdGEucG9zaXRpb24ueSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNpemUubG9hZChkYXRhLnNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95ID0gZGF0YS5kZXN0cm95O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm9yYml0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9yYml0cyA9IGRhdGEub3JiaXRzO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BYnNvcmJlciA9IEFic29yYmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFic29yYmVyU2l6ZSA9IHZvaWQgMDtcbmNvbnN0IFZhbHVlV2l0aFJhbmRvbV8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL09wdGlvbnMvQ2xhc3Nlcy9WYWx1ZVdpdGhSYW5kb21cIik7XG5jbGFzcyBBYnNvcmJlclNpemUgZXh0ZW5kcyBWYWx1ZVdpdGhSYW5kb21fMS5WYWx1ZVdpdGhSYW5kb20ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRlbnNpdHkgPSA1O1xuICAgICAgICB0aGlzLnJhbmRvbS5taW5pbXVtVmFsdWUgPSAxO1xuICAgICAgICB0aGlzLnZhbHVlID0gNTA7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5sb2FkKGRhdGEpO1xuICAgICAgICBpZiAoZGF0YS5kZW5zaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVuc2l0eSA9IGRhdGEuZGVuc2l0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5saW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxpbWl0ID0gZGF0YS5saW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5saW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxpbWl0ID0gZGF0YS5saW1pdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzb3JiZXJTaXplID0gQWJzb3JiZXJTaXplO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVtaXR0ZXJJbnN0YW5jZSA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uL0VudW1zXCIpO1xuY29uc3QgRW1pdHRlclNpemVfMSA9IHJlcXVpcmUoXCIuL09wdGlvbnMvQ2xhc3Nlcy9FbWl0dGVyU2l6ZVwiKTtcbmZ1bmN0aW9uIHJhbmRvbUNvb3JkaW5hdGUocG9zaXRpb24sIG9mZnNldCkge1xuICAgIHJldHVybiBwb3NpdGlvbiArIG9mZnNldCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KTtcbn1cbmZ1bmN0aW9uIHJhbmRvbVBvc2l0aW9uKHBvc2l0aW9uLCBvZmZzZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByYW5kb21Db29yZGluYXRlKHBvc2l0aW9uLngsIG9mZnNldC54KSxcbiAgICAgICAgeTogcmFuZG9tQ29vcmRpbmF0ZShwb3NpdGlvbi55LCBvZmZzZXQueSksXG4gICAgfTtcbn1cbmNsYXNzIEVtaXR0ZXJJbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3IoZW1pdHRlcnMsIGNvbnRhaW5lciwgZW1pdHRlck9wdGlvbnMsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLmVtaXR0ZXJzID0gZW1pdHRlcnM7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmluaXRpYWxQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLmVtaXR0ZXJPcHRpb25zID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCBlbWl0dGVyT3B0aW9ucyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAoX2EgPSB0aGlzLmluaXRpYWxQb3NpdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5jYWxjUG9zaXRpb24oKTtcbiAgICAgICAgbGV0IHBhcnRpY2xlc09wdGlvbnMgPSBVdGlsc18xLlV0aWxzLmRlZXBFeHRlbmQoe30sIHRoaXMuZW1pdHRlck9wdGlvbnMucGFydGljbGVzKTtcbiAgICAgICAgaWYgKHBhcnRpY2xlc09wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFydGljbGVzT3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWNsZXNPcHRpb25zLm1vdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFydGljbGVzT3B0aW9ucy5tb3ZlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpY2xlc09wdGlvbnMubW92ZS5kaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFydGljbGVzT3B0aW9ucy5tb3ZlLmRpcmVjdGlvbiA9IHRoaXMuZW1pdHRlck9wdGlvbnMuZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydGljbGVzT3B0aW9ucyA9IHBhcnRpY2xlc09wdGlvbnM7XG4gICAgICAgIHRoaXMuc2l6ZSA9IChfYiA9IHRoaXMuZW1pdHRlck9wdGlvbnMuc2l6ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBuZXcgRW1pdHRlclNpemVfMS5FbWl0dGVyU2l6ZSgpO1xuICAgICAgICAgICAgc2l6ZS5sb2FkKHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgbW9kZTogRW51bXNfMS5TaXplTW9kZS5wZXJjZW50LFxuICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgdGhpcy5saWZlQ291bnQgPSAoX2MgPSB0aGlzLmVtaXR0ZXJPcHRpb25zLmxpZmUuY291bnQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IC0xO1xuICAgICAgICB0aGlzLmltbW9ydGFsID0gdGhpcy5saWZlQ291bnQgPD0gMDtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuICAgIHBsYXkoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yICYmXG4gICAgICAgICAgICAodGhpcy5saWZlQ291bnQgPiAwIHx8IHRoaXMuaW1tb3J0YWwgfHwgIXRoaXMuZW1pdHRlck9wdGlvbnMubGlmZS5jb3VudCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0SW50ZXJ2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gKDEwMDAgKiB0aGlzLmVtaXR0ZXJPcHRpb25zLnJhdGUuZGVsYXkpIC8gdGhpcy5jb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcjtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0SW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoKTtcbiAgICAgICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5saWZlQ291bnQgPiAwIHx8IHRoaXMuaW1tb3J0YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVUb0RpZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMuc3RhcnRJbnRlcnZhbDtcbiAgICAgICAgaWYgKGludGVydmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3RhcnRJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNpemUoKSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxQb3NpdGlvbiA9IHRoaXMuaW5pdGlhbFBvc2l0aW9uO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID1cbiAgICAgICAgICAgIGluaXRpYWxQb3NpdGlvbiAmJiBVdGlsc18xLlV0aWxzLmlzUG9pbnRJbnNpZGUoaW5pdGlhbFBvc2l0aW9uLCB0aGlzLmNvbnRhaW5lci5jYW52YXMuc2l6ZSlcbiAgICAgICAgICAgICAgICA/IGluaXRpYWxQb3NpdGlvblxuICAgICAgICAgICAgICAgIDogdGhpcy5jYWxjUG9zaXRpb24oKTtcbiAgICB9XG4gICAgcHJlcGFyZVRvRGllKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gKF9hID0gdGhpcy5lbWl0dGVyT3B0aW9ucy5saWZlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHVyYXRpb247XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yICYmXG4gICAgICAgICAgICAodGhpcy5saWZlQ291bnQgPiAwIHx8IHRoaXMuaW1tb3J0YWwpICYmXG4gICAgICAgICAgICBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBkdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmltbW9ydGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlmZUNvdW50LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpZmVDb3VudCA+IDAgfHwgdGhpcy5pbW1vcnRhbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5jYWxjUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKCgoX2EgPSB0aGlzLmVtaXR0ZXJPcHRpb25zLmxpZmUuZGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICogMTAwMCkgLyB0aGlzLmNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGR1cmF0aW9uICogMTAwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVycy5yZW1vdmVFbWl0dGVyKHRoaXMpO1xuICAgIH1cbiAgICBjYWxjUG9zaXRpb24oKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBwZXJjZW50UG9zaXRpb24gPSB0aGlzLmVtaXR0ZXJPcHRpb25zLnBvc2l0aW9uO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogKCgoX2EgPSBwZXJjZW50UG9zaXRpb24gPT09IG51bGwgfHwgcGVyY2VudFBvc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJjZW50UG9zaXRpb24ueCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTWF0aC5yYW5kb20oKSAqIDEwMCkgLyAxMDApICogY29udGFpbmVyLmNhbnZhcy5zaXplLndpZHRoLFxuICAgICAgICAgICAgeTogKCgoX2IgPSBwZXJjZW50UG9zaXRpb24gPT09IG51bGwgfHwgcGVyY2VudFBvc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJjZW50UG9zaXRpb24ueSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogTWF0aC5yYW5kb20oKSAqIDEwMCkgLyAxMDApICogY29udGFpbmVyLmNhbnZhcy5zaXplLmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZW1pdCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0ge1xuICAgICAgICAgICAgeDogdGhpcy5zaXplLm1vZGUgPT09IEVudW1zXzEuU2l6ZU1vZGUucGVyY2VudFxuICAgICAgICAgICAgICAgID8gKGNvbnRhaW5lci5jYW52YXMuc2l6ZS53aWR0aCAqIHRoaXMuc2l6ZS53aWR0aCkgLyAxMDBcbiAgICAgICAgICAgICAgICA6IHRoaXMuc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIHk6IHRoaXMuc2l6ZS5tb2RlID09PSBFbnVtc18xLlNpemVNb2RlLnBlcmNlbnRcbiAgICAgICAgICAgICAgICA/IChjb250YWluZXIuY2FudmFzLnNpemUuaGVpZ2h0ICogdGhpcy5zaXplLmhlaWdodCkgLyAxMDBcbiAgICAgICAgICAgICAgICA6IHRoaXMuc2l6ZS5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lbWl0dGVyT3B0aW9ucy5yYXRlLnF1YW50aXR5OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5wYXJ0aWNsZXMuYWRkUGFydGljbGUocmFuZG9tUG9zaXRpb24ocG9zaXRpb24sIG9mZnNldCksIHRoaXMucGFydGljbGVzT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXJJbnN0YW5jZSA9IEVtaXR0ZXJJbnN0YW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbWl0dGVycyA9IHZvaWQgMDtcbmNvbnN0IEVtaXR0ZXJJbnN0YW5jZV8xID0gcmVxdWlyZShcIi4vRW1pdHRlckluc3RhbmNlXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL09wdGlvbnMvQ2xhc3Nlcy9FbWl0dGVyXCIpO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xuY2xhc3MgRW1pdHRlcnMge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5hcnJheSA9IFtdO1xuICAgICAgICB0aGlzLmVtaXR0ZXJzID0gW107XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpdml0eUVtaXR0ZXJzID0gW107XG4gICAgICAgIGNvbnN0IG92ZXJyaWRhYmxlQ29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICBvdmVycmlkYWJsZUNvbnRhaW5lci5hZGRFbWl0dGVyID0gKG9wdGlvbnMsIHBvc2l0aW9uKSA9PiB0aGlzLmFkZEVtaXR0ZXIob3B0aW9ucywgcG9zaXRpb24pO1xuICAgIH1cbiAgICBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW1pdHRlcnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVtaXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXJzID0gb3B0aW9ucy5lbWl0dGVycy5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IEVtaXR0ZXJfMS5FbWl0dGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5sb2FkKHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW1pdHRlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXJzID0gbmV3IEVtaXR0ZXJfMS5FbWl0dGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlcnMubG9hZChvcHRpb25zLmVtaXR0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnRlcmFjdGl2aXR5RW1pdHRlcnMgPSAoX2IgPSAoX2EgPSBvcHRpb25zLmludGVyYWN0aXZpdHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVtaXR0ZXJzO1xuICAgICAgICBpZiAoaW50ZXJhY3Rpdml0eUVtaXR0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpdml0eUVtaXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aXZpdHlFbWl0dGVycyA9IGludGVyYWN0aXZpdHlFbWl0dGVycy5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IEVtaXR0ZXJfMS5FbWl0dGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5sb2FkKHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3Rpdml0eUVtaXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGl2aXR5RW1pdHRlcnMgPSBuZXcgRW1pdHRlcl8xLkVtaXR0ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGl2aXR5RW1pdHRlcnMubG9hZChpbnRlcmFjdGl2aXR5RW1pdHRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVtaXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW1pdHRlck9wdGlvbnMgb2YgdGhpcy5lbWl0dGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRW1pdHRlcihlbWl0dGVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVtaXR0ZXIodGhpcy5lbWl0dGVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGxheSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbWl0dGVyIG9mIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIucGxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVtaXR0ZXIgb2YgdGhpcy5hcnJheSkge1xuICAgICAgICAgICAgZW1pdHRlci5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICB9XG4gICAgaGFuZGxlQ2xpY2tNb2RlKG1vZGUpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IGVtaXR0ZXJPcHRpb25zID0gdGhpcy5lbWl0dGVycztcbiAgICAgICAgY29uc3QgbW9kZUVtaXR0ZXJzID0gdGhpcy5pbnRlcmFjdGl2aXR5RW1pdHRlcnM7XG4gICAgICAgIGlmIChtb2RlID09PSBFbnVtc18xLkVtaXR0ZXJDbGlja01vZGUuZW1pdHRlcikge1xuICAgICAgICAgICAgbGV0IGVtaXR0ZXJNb2RlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChtb2RlRW1pdHRlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlRW1pdHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyTW9kZU9wdGlvbnMgPSBVdGlsc18xLlV0aWxzLml0ZW1Gcm9tQXJyYXkobW9kZUVtaXR0ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyTW9kZU9wdGlvbnMgPSBtb2RlRW1pdHRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbWl0dGVyc09wdGlvbnMgPSBlbWl0dGVyTW9kZU9wdGlvbnMgIT09IG51bGwgJiYgZW1pdHRlck1vZGVPcHRpb25zICE9PSB2b2lkIDAgPyBlbWl0dGVyTW9kZU9wdGlvbnMgOiAoZW1pdHRlck9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSA/IFV0aWxzXzEuVXRpbHMuaXRlbUZyb21BcnJheShlbWl0dGVyT3B0aW9ucykgOiBlbWl0dGVyT3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBlUG9zaXRpb24gPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5jbGlja1Bvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5hZGRFbWl0dGVyKFV0aWxzXzEuVXRpbHMuZGVlcEV4dGVuZCh7fSwgZW1pdHRlcnNPcHRpb25zKSwgZVBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNpemUoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW1pdHRlciBvZiB0aGlzLmFycmF5KSB7XG4gICAgICAgICAgICBlbWl0dGVyLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEVtaXR0ZXIob3B0aW9ucywgcG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVySW5zdGFuY2VfMS5FbWl0dGVySW5zdGFuY2UodGhpcywgdGhpcy5jb250YWluZXIsIG9wdGlvbnMsIHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5hcnJheS5wdXNoKGVtaXR0ZXIpO1xuICAgICAgICByZXR1cm4gZW1pdHRlcjtcbiAgICB9XG4gICAgcmVtb3ZlRW1pdHRlcihlbWl0dGVyKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5hcnJheS5pbmRleE9mKGVtaXR0ZXIpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5hcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5FbWl0dGVycyA9IEVtaXR0ZXJzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1pdHRlcnNQbHVnaW4gPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY29uc3QgRW1pdHRlcnNfMSA9IHJlcXVpcmUoXCIuL0VtaXR0ZXJzXCIpO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xuY29uc3QgRW1pdHRlcl8xID0gcmVxdWlyZShcIi4vT3B0aW9ucy9DbGFzc2VzL0VtaXR0ZXJcIik7XG5jbGFzcyBFbWl0dGVyc1BsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaWQgPSBcImVtaXR0ZXJzXCI7XG4gICAgfVxuICAgIGdldFBsdWdpbihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbWl0dGVyc18xLkVtaXR0ZXJzKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIG5lZWRzUGx1Z2luKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVycyA9IG9wdGlvbnMuZW1pdHRlcnM7XG4gICAgICAgIGxldCBsb2FkRW1pdHRlcnMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGVtaXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChlbWl0dGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb2FkRW1pdHRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVtaXR0ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvYWRFbWl0dGVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChfYyA9IChfYiA9IChfYSA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2ZW50cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9uQ2xpY2spID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tb2RlKSAmJlxuICAgICAgICAgICAgVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoRW51bXNfMS5FbWl0dGVyQ2xpY2tNb2RlLmVtaXR0ZXIsIG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25DbGljay5tb2RlKSkge1xuICAgICAgICAgICAgbG9hZEVtaXR0ZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9hZEVtaXR0ZXJzO1xuICAgIH1cbiAgICBsb2FkT3B0aW9ucyhvcHRpb25zLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLm5lZWRzUGx1Z2luKG9wdGlvbnMpICYmICF0aGlzLm5lZWRzUGx1Z2luKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zQ2FzdCA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2UuZW1pdHRlcnMpIHtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlLmVtaXR0ZXJzKSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc0Nhc3QuZW1pdHRlcnMgPSBzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2UuZW1pdHRlcnMubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBFbWl0dGVyXzEuRW1pdHRlcigpO1xuICAgICAgICAgICAgICAgICAgICB0bXAubG9hZChzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBlbWl0dGVyT3B0aW9ucyA9IG9wdGlvbnNDYXN0LmVtaXR0ZXJzO1xuICAgICAgICAgICAgICAgIGlmICgoZW1pdHRlck9wdGlvbnMgPT09IG51bGwgfHwgZW1pdHRlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVtaXR0ZXJPcHRpb25zLmxvYWQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc0Nhc3QuZW1pdHRlcnMgPSBlbWl0dGVyT3B0aW9ucyA9IG5ldyBFbWl0dGVyXzEuRW1pdHRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbWl0dGVyT3B0aW9ucy5sb2FkKHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZS5lbWl0dGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW50ZXJhY3Rpdml0eUVtaXR0ZXJzID0gKF9iID0gKF9hID0gc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlLmludGVyYWN0aXZpdHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVtaXR0ZXJzO1xuICAgICAgICBpZiAoaW50ZXJhY3Rpdml0eUVtaXR0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpdml0eUVtaXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zQ2FzdC5pbnRlcmFjdGl2aXR5Lm1vZGVzLmVtaXR0ZXJzID0gaW50ZXJhY3Rpdml0eUVtaXR0ZXJzLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgRW1pdHRlcl8xLkVtaXR0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wLmxvYWQocyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZW1pdHRlck9wdGlvbnMgPSBvcHRpb25zQ2FzdC5pbnRlcmFjdGl2aXR5Lm1vZGVzLmVtaXR0ZXJzO1xuICAgICAgICAgICAgICAgIGlmICgoZW1pdHRlck9wdGlvbnMgPT09IG51bGwgfHwgZW1pdHRlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVtaXR0ZXJPcHRpb25zLmxvYWQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc0Nhc3QuaW50ZXJhY3Rpdml0eS5tb2Rlcy5lbWl0dGVycyA9IGVtaXR0ZXJPcHRpb25zID0gbmV3IEVtaXR0ZXJfMS5FbWl0dGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtaXR0ZXJPcHRpb25zLmxvYWQoaW50ZXJhY3Rpdml0eUVtaXR0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IHBsdWdpbiA9IG5ldyBFbWl0dGVyc1BsdWdpbigpO1xuZXhwb3J0cy5FbWl0dGVyc1BsdWdpbiA9IHBsdWdpbjtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9FbnVtc1wiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1pdHRlckNsaWNrTW9kZSA9IHZvaWQgMDtcbnZhciBFbWl0dGVyQ2xpY2tNb2RlO1xuKGZ1bmN0aW9uIChFbWl0dGVyQ2xpY2tNb2RlKSB7XG4gICAgRW1pdHRlckNsaWNrTW9kZVtcImVtaXR0ZXJcIl0gPSBcImVtaXR0ZXJcIjtcbn0pKEVtaXR0ZXJDbGlja01vZGUgPSBleHBvcnRzLkVtaXR0ZXJDbGlja01vZGUgfHwgKGV4cG9ydHMuRW1pdHRlckNsaWNrTW9kZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0VtaXR0ZXJDbGlja01vZGVcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVtaXR0ZXIgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0VudW1zXCIpO1xuY29uc3QgRW1pdHRlclJhdGVfMSA9IHJlcXVpcmUoXCIuL0VtaXR0ZXJSYXRlXCIpO1xuY29uc3QgRW1pdHRlckxpZmVfMSA9IHJlcXVpcmUoXCIuL0VtaXR0ZXJMaWZlXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9VdGlsc1wiKTtcbmNvbnN0IEVtaXR0ZXJTaXplXzEgPSByZXF1aXJlKFwiLi9FbWl0dGVyU2l6ZVwiKTtcbmNsYXNzIEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IEVudW1zXzEuTW92ZURpcmVjdGlvbi5ub25lO1xuICAgICAgICB0aGlzLmxpZmUgPSBuZXcgRW1pdHRlckxpZmVfMS5FbWl0dGVyTGlmZSgpO1xuICAgICAgICB0aGlzLnJhdGUgPSBuZXcgRW1pdHRlclJhdGVfMS5FbWl0dGVyUmF0ZSgpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplID0gbmV3IEVtaXR0ZXJTaXplXzEuRW1pdHRlclNpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2l6ZS5sb2FkKGRhdGEuc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGlyZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGF0YS5kaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saWZlLmxvYWQoZGF0YS5saWZlKTtcbiAgICAgICAgaWYgKGRhdGEucGFydGljbGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCBkYXRhLnBhcnRpY2xlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXRlLmxvYWQoZGF0YS5yYXRlKTtcbiAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBkYXRhLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeTogZGF0YS5wb3NpdGlvbi55LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRW1pdHRlciA9IEVtaXR0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1pdHRlckxpZmUgPSB2b2lkIDA7XG5jbGFzcyBFbWl0dGVyTGlmZSB7XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5jb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gZGF0YS5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kZWxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ID0gZGF0YS5kZWxheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRW1pdHRlckxpZmUgPSBFbWl0dGVyTGlmZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbWl0dGVyUmF0ZSA9IHZvaWQgMDtcbmNsYXNzIEVtaXR0ZXJSYXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5xdWFudGl0eSA9IDE7XG4gICAgICAgIHRoaXMuZGVsYXkgPSAwLjE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucXVhbnRpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5xdWFudGl0eSA9IGRhdGEucXVhbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGVsYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxheSA9IGRhdGEuZGVsYXk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXJSYXRlID0gRW1pdHRlclJhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1pdHRlclNpemUgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0VudW1zXCIpO1xuY2xhc3MgRW1pdHRlclNpemUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBFbnVtc18xLlNpemVNb2RlLnBlcmNlbnQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBkYXRhLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEud2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGg7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXJTaXplID0gRW1pdHRlclNpemU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5saW5lQXJyYW5nZW1lbnQgPSB2b2lkIDA7XG52YXIgSW5saW5lQXJyYW5nZW1lbnQ7XG4oZnVuY3Rpb24gKElubGluZUFycmFuZ2VtZW50KSB7XG4gICAgSW5saW5lQXJyYW5nZW1lbnRbXCJlcXVpZGlzdGFudFwiXSA9IFwiZXF1aWRpc3RhbnRcIjtcbiAgICBJbmxpbmVBcnJhbmdlbWVudFtcIm9uZVBlclBvaW50XCJdID0gXCJvbmUtcGVyLXBvaW50XCI7XG4gICAgSW5saW5lQXJyYW5nZW1lbnRbXCJwZXJQb2ludFwiXSA9IFwicGVyLXBvaW50XCI7XG4gICAgSW5saW5lQXJyYW5nZW1lbnRbXCJyYW5kb21MZW5ndGhcIl0gPSBcInJhbmRvbS1sZW5ndGhcIjtcbiAgICBJbmxpbmVBcnJhbmdlbWVudFtcInJhbmRvbVBvaW50XCJdID0gXCJyYW5kb20tcG9pbnRcIjtcbn0pKElubGluZUFycmFuZ2VtZW50ID0gZXhwb3J0cy5JbmxpbmVBcnJhbmdlbWVudCB8fCAoZXhwb3J0cy5JbmxpbmVBcnJhbmdlbWVudCA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW92ZVR5cGUgPSB2b2lkIDA7XG52YXIgTW92ZVR5cGU7XG4oZnVuY3Rpb24gKE1vdmVUeXBlKSB7XG4gICAgTW92ZVR5cGVbXCJwYXRoXCJdID0gXCJwYXRoXCI7XG4gICAgTW92ZVR5cGVbXCJyYWRpdXNcIl0gPSBcInJhZGl1c1wiO1xufSkoTW92ZVR5cGUgPSBleHBvcnRzLk1vdmVUeXBlIHx8IChleHBvcnRzLk1vdmVUeXBlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlID0gdm9pZCAwO1xudmFyIFR5cGU7XG4oZnVuY3Rpb24gKFR5cGUpIHtcbiAgICBUeXBlW1wiaW5saW5lXCJdID0gXCJpbmxpbmVcIjtcbiAgICBUeXBlW1wiaW5zaWRlXCJdID0gXCJpbnNpZGVcIjtcbiAgICBUeXBlW1wib3V0c2lkZVwiXSA9IFwib3V0c2lkZVwiO1xuICAgIFR5cGVbXCJub25lXCJdID0gXCJub25lXCI7XG59KShUeXBlID0gZXhwb3J0cy5UeXBlIHx8IChleHBvcnRzLlR5cGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JbmxpbmVBcnJhbmdlbWVudFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTW92ZVR5cGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1R5cGVcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRyYXcgPSB2b2lkIDA7XG5jb25zdCBEcmF3U3Ryb2tlXzEgPSByZXF1aXJlKFwiLi9EcmF3U3Ryb2tlXCIpO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vT3B0aW9ucy9DbGFzc2VzL09wdGlvbnNDb2xvclwiKTtcbmNsYXNzIERyYXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0cm9rZSA9IG5ldyBEcmF3U3Ryb2tlXzEuRHJhd1N0cm9rZSgpO1xuICAgIH1cbiAgICBnZXQgbGluZVdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJva2Uud2lkdGg7XG4gICAgfVxuICAgIHNldCBsaW5lV2lkdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdHJva2Uud2lkdGggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGxpbmVDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Ryb2tlLmNvbG9yO1xuICAgIH1cbiAgICBzZXQgbGluZUNvbG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlLmNvbG9yID0gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh0aGlzLnN0cm9rZS5jb2xvciwgdmFsdWUpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJva2UgPSAoX2EgPSBkYXRhLnN0cm9rZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBkYXRhLmxpbmVDb2xvcixcbiAgICAgICAgICAgICAgICB3aWR0aDogZGF0YS5saW5lV2lkdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdHJva2UubG9hZChzdHJva2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EcmF3ID0gRHJhdztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EcmF3U3Ryb2tlID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vT3B0aW9ucy9DbGFzc2VzL09wdGlvbnNDb2xvclwiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vVXRpbHNcIik7XG5jbGFzcyBEcmF3U3Ryb2tlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IDAuNTtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29sb3IudmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSAoX2EgPSBVdGlsc18xLkNvbG9yVXRpbHMuc3RyaW5nVG9BbHBoYSh0aGlzLmNvbG9yLnZhbHVlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEud2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EcmF3U3Ryb2tlID0gRHJhd1N0cm9rZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbmxpbmUgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uL0VudW1zXCIpO1xuY2xhc3MgSW5saW5lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hcnJhbmdlbWVudCA9IEVudW1zXzEuSW5saW5lQXJyYW5nZW1lbnQub25lUGVyUG9pbnQ7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5hcnJhbmdlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcnJhbmdlbWVudCA9IGRhdGEuYXJyYW5nZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLklubGluZSA9IElubGluZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2NhbFN2ZyA9IHZvaWQgMDtcbmNsYXNzIExvY2FsU3ZnIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gW107XG4gICAgICAgIHRoaXMuc2l6ZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGRhdGEucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gZGF0YS5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2l6ZS53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZS53aWR0aCA9IGRhdGEuc2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2l6ZS5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUuaGVpZ2h0ID0gZGF0YS5zaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxvY2FsU3ZnID0gTG9jYWxTdmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW92ZSA9IHZvaWQgMDtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXNcIik7XG5jbGFzcyBNb3ZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAxMDtcbiAgICAgICAgdGhpcy50eXBlID0gRW51bXNfMS5Nb3ZlVHlwZS5wYXRoO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGRhdGEucmFkaXVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cyA9IGRhdGEucmFkaXVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gZGF0YS50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Nb3ZlID0gTW92ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2x5Z29uTWFzayA9IHZvaWQgMDtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXNcIik7XG5jb25zdCBEcmF3XzEgPSByZXF1aXJlKFwiLi9EcmF3XCIpO1xuY29uc3QgTW92ZV8xID0gcmVxdWlyZShcIi4vTW92ZVwiKTtcbmNvbnN0IElubGluZV8xID0gcmVxdWlyZShcIi4vSW5saW5lXCIpO1xuY29uc3QgTG9jYWxTdmdfMSA9IHJlcXVpcmUoXCIuL0xvY2FsU3ZnXCIpO1xuY2xhc3MgUG9seWdvbk1hc2sge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRyYXcgPSBuZXcgRHJhd18xLkRyYXcoKTtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbmxpbmUgPSBuZXcgSW5saW5lXzEuSW5saW5lKCk7XG4gICAgICAgIHRoaXMubW92ZSA9IG5ldyBNb3ZlXzEuTW92ZSgpO1xuICAgICAgICB0aGlzLnNjYWxlID0gMTtcbiAgICAgICAgdGhpcy50eXBlID0gRW51bXNfMS5UeXBlLm5vbmU7XG4gICAgfVxuICAgIGdldCBpbmxpbmVBcnJhbmdlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5saW5lLmFycmFuZ2VtZW50O1xuICAgIH1cbiAgICBzZXQgaW5saW5lQXJyYW5nZW1lbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbmxpbmUuYXJyYW5nZW1lbnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3LmxvYWQoZGF0YS5kcmF3KTtcbiAgICAgICAgICAgIGNvbnN0IGlubGluZSA9IChfYSA9IGRhdGEuaW5saW5lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7XG4gICAgICAgICAgICAgICAgYXJyYW5nZW1lbnQ6IGRhdGEuaW5saW5lQXJyYW5nZW1lbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGlubGluZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmxpbmUubG9hZChpbmxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tb3ZlLmxvYWQoZGF0YS5tb3ZlKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlID0gZGF0YS5zY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IGRhdGEudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gdGhpcy50eXBlICE9PSBFbnVtc18xLlR5cGUubm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cmwgPSBkYXRhLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBMb2NhbFN2Z18xLkxvY2FsU3ZnKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5sb2FkKGRhdGEuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGRhdGEucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogZGF0YS5wb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBvbHlnb25NYXNrID0gUG9seWdvbk1hc2s7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2x5Z29uTWFza0luc3RhbmNlID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IFBvbHlnb25NYXNrXzEgPSByZXF1aXJlKFwiLi9PcHRpb25zL0NsYXNzZXMvUG9seWdvbk1hc2tcIik7XG5mdW5jdGlvbiBwb2x5Z29uQm91bmNlKHBhcnRpY2xlKSB7XG4gICAgcGFydGljbGUudmVsb2NpdHkuaG9yaXpvbnRhbCA9IHBhcnRpY2xlLnZlbG9jaXR5LnZlcnRpY2FsIC8gMiAtIHBhcnRpY2xlLnZlbG9jaXR5Lmhvcml6b250YWw7XG4gICAgcGFydGljbGUudmVsb2NpdHkudmVydGljYWwgPSBwYXJ0aWNsZS52ZWxvY2l0eS5ob3Jpem9udGFsIC8gMiAtIHBhcnRpY2xlLnZlbG9jaXR5LnZlcnRpY2FsO1xufVxuZnVuY3Rpb24gZHJhd1BvbHlnb25NYXNrKGNvbnRleHQsIHJhd0RhdGEsIHN0cm9rZSkge1xuICAgIGNvbnN0IGNvbG9yID0gVXRpbHNfMS5Db2xvclV0aWxzLmNvbG9yVG9SZ2Ioc3Ryb2tlLmNvbG9yKTtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhyYXdEYXRhWzBdLngsIHJhd0RhdGFbMF0ueSk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHJhd0RhdGEpIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8oaXRlbS54LCBpdGVtLnkpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKGNvbG9yKTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0cm9rZS53aWR0aDtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xufVxuZnVuY3Rpb24gZHJhd1BvbHlnb25NYXNrUGF0aChjb250ZXh0LCBwYXRoLCBzdHJva2UsIHBvc2l0aW9uKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgY29uc3QgY29sb3IgPSBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb1JnYihzdHJva2UuY29sb3IpO1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gVXRpbHNfMS5Db2xvclV0aWxzLmdldFN0eWxlRnJvbVJnYihjb2xvciwgc3Ryb2tlLm9wYWNpdHkpO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc3Ryb2tlLndpZHRoO1xuICAgIGNvbnRleHQuc3Ryb2tlKHBhdGgpO1xufVxuZnVuY3Rpb24gcGFyc2VQYXRocyhwYXRocywgc2NhbGUsIG9mZnNldCkge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguZWxlbWVudC5wYXRoU2VnTGlzdDtcbiAgICAgICAgY29uc3QgbGVuID0gc2VnbWVudHMubnVtYmVyT2ZJdGVtcztcbiAgICAgICAgY29uc3QgcCA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHMuZ2V0SXRlbShpKTtcbiAgICAgICAgICAgIGNvbnN0IHN2Z1BhdGhTZWcgPSB3aW5kb3cuU1ZHUGF0aFNlZztcbiAgICAgICAgICAgIHN3aXRjaCAoc2VnbWVudC5wYXRoU2VnVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2Ugc3ZnUGF0aFNlZy5QQVRIU0VHX01PVkVUT19BQlM6XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfTElORVRPX0FCUzpcbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX0NVQklDX0FCUzpcbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX1FVQURSQVRJQ19BQlM6XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfQVJDX0FCUzpcbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX0NVQklDX1NNT09USF9BQlM6XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19RVUFEUkFUSUNfU01PT1RIX0FCUzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhYnNTZWcgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgICAgICBwLnggPSBhYnNTZWcueDtcbiAgICAgICAgICAgICAgICAgICAgcC55ID0gYWJzU2VnLnk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fSE9SSVpPTlRBTF9BQlM6XG4gICAgICAgICAgICAgICAgICAgIHAueCA9IHNlZ21lbnQueDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfTElORVRPX1ZFUlRJQ0FMX0FCUzpcbiAgICAgICAgICAgICAgICAgICAgcC55ID0gc2VnbWVudC55O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fUkVMOlxuICAgICAgICAgICAgICAgIGNhc2Ugc3ZnUGF0aFNlZy5QQVRIU0VHX01PVkVUT19SRUw6XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19DVUJJQ19SRUw6XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19RVUFEUkFUSUNfUkVMOlxuICAgICAgICAgICAgICAgIGNhc2Ugc3ZnUGF0aFNlZy5QQVRIU0VHX0FSQ19SRUw6XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19DVUJJQ19TTU9PVEhfUkVMOlxuICAgICAgICAgICAgICAgIGNhc2Ugc3ZnUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX1NNT09USF9SRUw6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsU2VnID0gc2VnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgcC54ICs9IHJlbFNlZy54O1xuICAgICAgICAgICAgICAgICAgICBwLnkgKz0gcmVsU2VnLnk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fSE9SSVpPTlRBTF9SRUw6XG4gICAgICAgICAgICAgICAgICAgIHAueCArPSBzZWdtZW50Lng7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugc3ZnUGF0aFNlZy5QQVRIU0VHX0xJTkVUT19WRVJUSUNBTF9SRUw6XG4gICAgICAgICAgICAgICAgICAgIHAueSArPSBzZWdtZW50Lnk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugc3ZnUGF0aFNlZy5QQVRIU0VHX1VOS05PV046XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfQ0xPU0VQQVRIOlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiBwLnggKiBzY2FsZSArIG9mZnNldC54LFxuICAgICAgICAgICAgICAgIHk6IHAueSAqIHNjYWxlICsgb2Zmc2V0LnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuY2xhc3MgUG9seWdvbk1hc2tJbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbiA9IHtcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhdGgyRFN1cHBvcnRlZCA9ICEhd2luZG93LlBhdGgyRDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbmV3IFBvbHlnb25NYXNrXzEuUG9seWdvbk1hc2soKTtcbiAgICAgICAgdGhpcy5wb2x5Z29uTWFza01vdmVSYWRpdXMgPSB0aGlzLm9wdGlvbnMubW92ZS5yYWRpdXMgKiBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgfVxuICAgIGluaXRBc3luYyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubG9hZChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucG9seWdvbik7XG4gICAgICAgICAgICBjb25zdCBwb2x5Z29uTWFza09wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLnBvbHlnb25NYXNrTW92ZVJhZGl1cyA9IHBvbHlnb25NYXNrT3B0aW9ucy5tb3ZlLnJhZGl1cyAqIHRoaXMuY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvO1xuICAgICAgICAgICAgaWYgKHBvbHlnb25NYXNrT3B0aW9ucy5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmluaXRSYXdEYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNpemUoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIShvcHRpb25zLmVuYWJsZSAmJiBvcHRpb25zLnR5cGUgIT09IEVudW1zXzEuVHlwZS5ub25lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZHJhd1RpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlZHJhd1RpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkcmF3VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuaW5pdFJhd0RhdGEodHJ1ZSk7XG4gICAgICAgICAgICBjb250YWluZXIucGFydGljbGVzLnJlZHJhdygpO1xuICAgICAgICB9KSwgMjUwKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucmF3O1xuICAgICAgICBkZWxldGUgdGhpcy5wYXRocztcbiAgICB9XG4gICAgcGFydGljbGVzSW5pdGlhbGl6YXRpb24oKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLmVuYWJsZSAmJlxuICAgICAgICAgICAgb3B0aW9ucy50eXBlID09PSBFbnVtc18xLlR5cGUuaW5saW5lICYmXG4gICAgICAgICAgICAob3B0aW9ucy5pbmxpbmUuYXJyYW5nZW1lbnQgPT09IEVudW1zXzEuSW5saW5lQXJyYW5nZW1lbnQub25lUGVyUG9pbnQgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmlubGluZS5hcnJhbmdlbWVudCA9PT0gRW51bXNfMS5JbmxpbmVBcnJhbmdlbWVudC5wZXJQb2ludCkpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1BvaW50cygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBwYXJ0aWNsZVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICghKG9wdGlvbnMuZW5hYmxlICYmICgoX2IgPSAoX2EgPSB0aGlzLnJhdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgPiAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVdGlsc18xLlV0aWxzLmRlZXBFeHRlbmQoe30sIHBvc2l0aW9uID8gcG9zaXRpb24gOiB0aGlzLnJhbmRvbVBvaW50KCkpO1xuICAgIH1cbiAgICBwYXJ0aWNsZUJvdW5jZShwYXJ0aWNsZSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5lbmFibGUgJiYgb3B0aW9ucy50eXBlICE9PSBFbnVtc18xLlR5cGUubm9uZSAmJiBvcHRpb25zLnR5cGUgIT09IEVudW1zXzEuVHlwZS5pbmxpbmUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja0luc2lkZVBvbHlnb24ocGFydGljbGUuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uQm91bmNlKHBhcnRpY2xlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmVuYWJsZSAmJiBvcHRpb25zLnR5cGUgPT09IEVudW1zXzEuVHlwZS5pbmxpbmUgJiYgcGFydGljbGUuaW5pdGlhbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShwYXJ0aWNsZS5pbml0aWFsUG9zaXRpb24sIHBhcnRpY2xlLmdldFBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgaWYgKGRpc3QgPiB0aGlzLnBvbHlnb25NYXNrTW92ZVJhZGl1cykge1xuICAgICAgICAgICAgICAgIHBvbHlnb25Cb3VuY2UocGFydGljbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2xpY2tQb3NpdGlvblZhbGlkKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5lbmFibGUgJiZcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSAhPT0gRW51bXNfMS5UeXBlLm5vbmUgJiZcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSAhPT0gRW51bXNfMS5UeXBlLmlubGluZSAmJlxuICAgICAgICAgICAgdGhpcy5jaGVja0luc2lkZVBvbHlnb24ocG9zaXRpb24pKTtcbiAgICB9XG4gICAgZHJhdyhjb250ZXh0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCEoKF9hID0gdGhpcy5wYXRocykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBwb2x5Z29uRHJhdyA9IG9wdGlvbnMuZHJhdztcbiAgICAgICAgaWYgKCEob3B0aW9ucy5lbmFibGUgJiYgcG9seWdvbkRyYXcuZW5hYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd0RhdGEgPSB0aGlzLnJhdztcbiAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMucGF0aHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGgyZCA9IHBhdGgucGF0aDJkO1xuICAgICAgICAgICAgY29uc3QgcGF0aDJkU3VwcG9ydGVkID0gdGhpcy5wYXRoMkRTdXBwb3J0ZWQ7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRoMmRTdXBwb3J0ZWQgJiYgcGF0aDJkICYmIHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgZHJhd1BvbHlnb25NYXNrUGF0aChjb250ZXh0LCBwYXRoMmQsIHBvbHlnb25EcmF3LnN0cm9rZSwgdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmF3RGF0YSkge1xuICAgICAgICAgICAgICAgIGRyYXdQb2x5Z29uTWFzayhjb250ZXh0LCByYXdEYXRhLCBwb2x5Z29uRHJhdy5zdHJva2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrSW5zaWRlUG9seWdvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKCFvcHRpb25zLmVuYWJsZSB8fCBvcHRpb25zLnR5cGUgPT09IEVudW1zXzEuVHlwZS5ub25lIHx8IG9wdGlvbnMudHlwZSA9PT0gRW51bXNfMS5UeXBlLmlubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJhdykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFV0aWxzXzEuQ29uc3RhbnRzLm5vUG9seWdvbkZvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW52YXNTaXplID0gY29udGFpbmVyLmNhbnZhcy5zaXplO1xuICAgICAgICBjb25zdCB4ID0gKF9hID0gcG9zaXRpb24gPT09IG51bGwgfHwgcG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvc2l0aW9uLngpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE1hdGgucmFuZG9tKCkgKiBjYW52YXNTaXplLndpZHRoO1xuICAgICAgICBjb25zdCB5ID0gKF9iID0gcG9zaXRpb24gPT09IG51bGwgfHwgcG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvc2l0aW9uLnkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE1hdGgucmFuZG9tKCkgKiBjYW52YXNTaXplLmhlaWdodDtcbiAgICAgICAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMucmF3Lmxlbmd0aCAtIDE7IGkgPCB0aGlzLnJhdy5sZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBpID0gdGhpcy5yYXdbaV07XG4gICAgICAgICAgICBjb25zdCBwaiA9IHRoaXMucmF3W2pdO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0ID0gcGkueSA+IHkgIT09IHBqLnkgPiB5ICYmIHggPCAoKHBqLnggLSBwaS54KSAqICh5IC0gcGkueSkpIC8gKHBqLnkgLSBwaS55KSArIHBpLng7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0KSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy50eXBlID09PSBFbnVtc18xLlR5cGUuaW5zaWRlID8gaW5zaWRlIDogb3B0aW9ucy50eXBlID09PSBFbnVtc18xLlR5cGUub3V0c2lkZSA/ICFpbnNpZGUgOiBmYWxzZTtcbiAgICB9XG4gICAgcGFyc2VTdmdQYXRoKHhtbCwgZm9yY2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGZvcmNlRG93bmxvYWQgPSBmb3JjZSAhPT0gbnVsbCAmJiBmb3JjZSAhPT0gdm9pZCAwID8gZm9yY2UgOiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMucGF0aHMgIT09IHVuZGVmaW5lZCAmJiAhZm9yY2VEb3dubG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIGNvbnN0IGRvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCBcImltYWdlL3N2Zyt4bWxcIik7XG4gICAgICAgIGNvbnN0IHN2ZyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXTtcbiAgICAgICAgbGV0IHN2Z1BhdGhzID0gc3ZnLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGF0aFwiKTtcbiAgICAgICAgaWYgKCFzdmdQYXRocy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN2Z1BhdGhzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGF0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGhzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ZnUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBzdmdQYXRocy5pdGVtKGkpO1xuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHBhdGguZ2V0VG90YWxMZW5ndGgoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBweFJhdGlvID0gY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvO1xuICAgICAgICBjb25zdCBzY2FsZSA9IG9wdGlvbnMuc2NhbGUgLyBweFJhdGlvO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbi53aWR0aCA9IHBhcnNlRmxvYXQoKF9hID0gc3ZnLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIjBcIikgKiBzY2FsZTtcbiAgICAgICAgdGhpcy5kaW1lbnNpb24uaGVpZ2h0ID0gcGFyc2VGbG9hdCgoX2IgPSBzdmcuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIjBcIikgKiBzY2FsZTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSAoX2MgPSBvcHRpb25zLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7XG4gICAgICAgICAgICB4OiA1MCxcbiAgICAgICAgICAgIHk6IDUwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9mZnNldCA9IHtcbiAgICAgICAgICAgIHg6IChjb250YWluZXIuY2FudmFzLnNpemUud2lkdGggKiBwb3NpdGlvbi54KSAvICgxMDAgKiBweFJhdGlvKSAtIHRoaXMuZGltZW5zaW9uLndpZHRoIC8gMixcbiAgICAgICAgICAgIHk6IChjb250YWluZXIuY2FudmFzLnNpemUuaGVpZ2h0ICogcG9zaXRpb24ueSkgLyAoMTAwICogcHhSYXRpbykgLSB0aGlzLmRpbWVuc2lvbi5oZWlnaHQgLyAyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFyc2VQYXRocyh0aGlzLnBhdGhzLCBzY2FsZSwgdGhpcy5vZmZzZXQpO1xuICAgIH1cbiAgICBkb3dubG9hZFN2Z1BhdGgoc3ZnVXJsLCBmb3JjZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHN2Z1VybCB8fCBvcHRpb25zLnVybDtcbiAgICAgICAgICAgIGNvbnN0IGZvcmNlRG93bmxvYWQgPSBmb3JjZSAhPT0gbnVsbCAmJiBmb3JjZSAhPT0gdm9pZCAwID8gZm9yY2UgOiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdXJsIHx8ICh0aGlzLnBhdGhzICE9PSB1bmRlZmluZWQgJiYgIWZvcmNlRG93bmxvYWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxID0geWllbGQgZmV0Y2godXJsKTtcbiAgICAgICAgICAgIGlmICghcmVxLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHNQYXJ0aWNsZXMgRXJyb3IgLSBFcnJvciBvY2N1cnJlZCBkdXJpbmcgcG9seWdvbiBtYXNrIGRvd25sb2FkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdmdQYXRoKHlpZWxkIHJlcS50ZXh0KCksIGZvcmNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYXdQb2ludHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5yYXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5yYXcpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnBhcnRpY2xlcy5hZGRQYXJ0aWNsZSh7XG4gICAgICAgICAgICAgICAgeDogaXRlbS54LFxuICAgICAgICAgICAgICAgIHk6IGl0ZW0ueSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJhbmRvbVBvaW50KCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgbGV0IHBvc2l0aW9uO1xuICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSBFbnVtc18xLlR5cGUuaW5saW5lKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnMuaW5saW5lLmFycmFuZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBFbnVtc18xLklubGluZUFycmFuZ2VtZW50LnJhbmRvbVBvaW50OlxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UmFuZG9tUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBFbnVtc18xLklubGluZUFycmFuZ2VtZW50LnJhbmRvbUxlbmd0aDpcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFJhbmRvbVBvaW50QnlMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBFbnVtc18xLklubGluZUFycmFuZ2VtZW50LmVxdWlkaXN0YW50OlxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0RXF1aWRpc3RhbnRQb2ludEJ5SW5kZXgoY29udGFpbmVyLnBhcnRpY2xlcy5jb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5JbmxpbmVBcnJhbmdlbWVudC5vbmVQZXJQb2ludDpcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuSW5saW5lQXJyYW5nZW1lbnQucGVyUG9pbnQ6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50QnlJbmRleChjb250YWluZXIucGFydGljbGVzLmNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IE1hdGgucmFuZG9tKCkgKiBjb250YWluZXIuY2FudmFzLnNpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgeTogTWF0aC5yYW5kb20oKSAqIGNvbnRhaW5lci5jYW52YXMuc2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoZWNrSW5zaWRlUG9seWdvbihwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmRvbVBvaW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmFuZG9tUG9pbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5yYXcgfHwgIXRoaXMucmF3Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFV0aWxzXzEuQ29uc3RhbnRzLm5vUG9seWdvbkRhdGFMb2FkZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IFV0aWxzXzEuVXRpbHMuaXRlbUZyb21BcnJheSh0aGlzLnJhdyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjb29yZHMueCxcbiAgICAgICAgICAgIHk6IGNvb3Jkcy55LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRSYW5kb21Qb2ludEJ5TGVuZ3RoKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKCF0aGlzLnJhdyB8fCAhdGhpcy5yYXcubGVuZ3RoIHx8ICEoKF9hID0gdGhpcy5wYXRocykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihVdGlsc18xLkNvbnN0YW50cy5ub1BvbHlnb25EYXRhTG9hZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoID0gVXRpbHNfMS5VdGlscy5pdGVtRnJvbUFycmF5KHRoaXMucGF0aHMpO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBhdGgubGVuZ3RoKSArIDE7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcGF0aC5lbGVtZW50LmdldFBvaW50QXRMZW5ndGgoZGlzdGFuY2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcG9pbnQueCAqIG9wdGlvbnMuc2NhbGUgKyAoKChfYiA9IHRoaXMub2Zmc2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IueCkgfHwgMCksXG4gICAgICAgICAgICB5OiBwb2ludC55ICogb3B0aW9ucy5zY2FsZSArICgoKF9jID0gdGhpcy5vZmZzZXQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy55KSB8fCAwKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0RXF1aWRpc3RhbnRQb2ludEJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb250YWluZXIub3B0aW9ucztcbiAgICAgICAgY29uc3QgcG9seWdvbk1hc2tPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIXRoaXMucmF3IHx8ICF0aGlzLnJhdy5sZW5ndGggfHwgISgoX2EgPSB0aGlzLnBhdGhzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihVdGlsc18xLkNvbnN0YW50cy5ub1BvbHlnb25EYXRhTG9hZGVkKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCBwb2ludDtcbiAgICAgICAgY29uc3QgdG90YWxMZW5ndGggPSB0aGlzLnBhdGhzLnJlZHVjZSgodG90LCBwYXRoKSA9PiB0b3QgKyBwYXRoLmxlbmd0aCwgMCk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdG90YWxMZW5ndGggLyBvcHRpb25zLnBhcnRpY2xlcy5udW1iZXIudmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiB0aGlzLnBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoRGlzdGFuY2UgPSBkaXN0YW5jZSAqIGluZGV4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHBhdGhEaXN0YW5jZSA8PSBwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcGF0aC5lbGVtZW50LmdldFBvaW50QXRMZW5ndGgocGF0aERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogKChfYiA9IHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb2ludC54KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSAqIHBvbHlnb25NYXNrT3B0aW9ucy5zY2FsZSArICgoX2QgPSAoX2MgPSB0aGlzLm9mZnNldCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLngpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDApLFxuICAgICAgICAgICAgeTogKChfZSA9IHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb2ludC55KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwKSAqIHBvbHlnb25NYXNrT3B0aW9ucy5zY2FsZSArICgoX2cgPSAoX2YgPSB0aGlzLm9mZnNldCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnkpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IDApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRQb2ludEJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJhdyB8fCAhdGhpcy5yYXcubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoVXRpbHNfMS5Db25zdGFudHMubm9Qb2x5Z29uRGF0YUxvYWRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29vcmRzID0gdGhpcy5yYXdbaW5kZXggJSB0aGlzLnJhdy5sZW5ndGhdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY29vcmRzLngsXG4gICAgICAgICAgICB5OiBjb29yZHMueSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlUGF0aDJEKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIXRoaXMucGF0aDJEU3VwcG9ydGVkIHx8ICEoKF9hID0gdGhpcy5wYXRocykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgdGhpcy5wYXRocykge1xuICAgICAgICAgICAgY29uc3QgcGF0aERhdGEgPSAoX2IgPSBwYXRoLmVsZW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRBdHRyaWJ1dGUoXCJkXCIpO1xuICAgICAgICAgICAgaWYgKHBhdGhEYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aDJkID0gbmV3IFBhdGgyRChwYXRoRGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIikuY3JlYXRlU1ZHTWF0cml4KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IG1hdHJpeC5zY2FsZShvcHRpb25zLnNjYWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxQYXRoLmFkZFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxQYXRoLmFkZFBhdGgocGF0aDJkLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnBhdGgyZCA9IGZpbmFsUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXRoLnBhdGgyZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGF0aC5wYXRoMmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0aC5wYXRoMmQgfHwgIXRoaXMucmF3KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRoLnBhdGgyZCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgICAgIHBhdGgucGF0aDJkLm1vdmVUbyh0aGlzLnJhd1swXS54LCB0aGlzLnJhd1swXS55KTtcbiAgICAgICAgICAgIHRoaXMucmF3LmZvckVhY2goKHBvcywgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gcGF0aC5wYXRoMmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5saW5lVG8ocG9zLngsIHBvcy55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhdGgucGF0aDJkLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRSYXdEYXRhKGZvcmNlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYXcgPSB5aWVsZCB0aGlzLmRvd25sb2FkU3ZnUGF0aChvcHRpb25zLnVybCwgZm9yY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgICAgICAgICBsZXQgc3ZnO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZGF0YS5wYXRoIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YS5wYXRoLm1hcCgodCkgPT4gYDxwYXRoIGQ9XCIke3R9XCIgLz5gKS5qb2luKFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGA8cGF0aCBkPVwiJHtkYXRhLnBhdGh9XCIgLz5gO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lc3BhY2VzID0gJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIic7XG4gICAgICAgICAgICAgICAgICAgIHN2ZyA9IGA8c3ZnICR7bmFtZXNwYWNlc30gd2lkdGg9XCIke2RhdGEuc2l6ZS53aWR0aH1cIiBoZWlnaHQ9XCIke2RhdGEuc2l6ZS5oZWlnaHR9XCI+JHtwYXRofTwvc3ZnPmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdmcgPSBkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJhdyA9IHRoaXMucGFyc2VTdmdQYXRoKHN2ZywgZm9yY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVQYXRoMkQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2x5Z29uTWFza0luc3RhbmNlID0gUG9seWdvbk1hc2tJbnN0YW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbHlnb25NYXNrUGx1Z2luID0gdm9pZCAwO1xuY29uc3QgUG9seWdvbk1hc2tJbnN0YW5jZV8xID0gcmVxdWlyZShcIi4vUG9seWdvbk1hc2tJbnN0YW5jZVwiKTtcbmNvbnN0IFBvbHlnb25NYXNrXzEgPSByZXF1aXJlKFwiLi9PcHRpb25zL0NsYXNzZXMvUG9seWdvbk1hc2tcIik7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4vRW51bXNcIik7XG5jbGFzcyBQb2x5Z29uTWFza1BsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaWQgPSBcInBvbHlnb25NYXNrXCI7XG4gICAgfVxuICAgIGdldFBsdWdpbihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uTWFza0luc3RhbmNlXzEuUG9seWdvbk1hc2tJbnN0YW5jZShjb250YWluZXIpO1xuICAgIH1cbiAgICBuZWVkc1BsdWdpbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBvbHlnb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmFibGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICgoKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBvbHlnb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50eXBlKSAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucG9seWdvbi50eXBlICE9PSBFbnVtc18xLlR5cGUubm9uZSk7XG4gICAgfVxuICAgIGxvYWRPcHRpb25zKG9wdGlvbnMsIHNvdXJjZSkge1xuICAgICAgICBpZiAoIXRoaXMubmVlZHNQbHVnaW4oc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnNDYXN0ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IHBvbHlnb25PcHRpb25zID0gb3B0aW9uc0Nhc3QucG9seWdvbjtcbiAgICAgICAgaWYgKChwb2x5Z29uT3B0aW9ucyA9PT0gbnVsbCB8fCBwb2x5Z29uT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9seWdvbk9wdGlvbnMubG9hZCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9uc0Nhc3QucG9seWdvbiA9IHBvbHlnb25PcHRpb25zID0gbmV3IFBvbHlnb25NYXNrXzEuUG9seWdvbk1hc2soKTtcbiAgICAgICAgfVxuICAgICAgICBwb2x5Z29uT3B0aW9ucy5sb2FkKHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZS5wb2x5Z29uKTtcbiAgICB9XG59XG5jb25zdCBwbHVnaW4gPSBuZXcgUG9seWdvbk1hc2tQbHVnaW4oKTtcbmV4cG9ydHMuUG9seWdvbk1hc2tQbHVnaW4gPSBwbHVnaW47XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRW51bXNcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNpcmNsZURyYXdlciA9IHZvaWQgMDtcbmNsYXNzIENpcmNsZURyYXdlciB7XG4gICAgZ2V0U2lkZXNDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIDEyO1xuICAgIH1cbiAgICBkcmF3KGNvbnRleHQsIHBhcnRpY2xlLCByYWRpdXMpIHtcbiAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2lyY2xlRHJhd2VyID0gQ2lyY2xlRHJhd2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW1hZ2VEcmF3ZXIgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi9FbnVtc1wiKTtcbmNsYXNzIEltYWdlRHJhd2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbWFnZXMgPSBbXTtcbiAgICB9XG4gICAgZ2V0U2lkZXNDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIDEyO1xuICAgIH1cbiAgICBnZXRJbWFnZXMoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckltYWdlcyA9IHRoaXMuaW1hZ2VzLmZpbHRlcigodCkgPT4gdC5pZCA9PT0gY29udGFpbmVyLmlkKTtcbiAgICAgICAgaWYgKCFjb250YWluZXJJbWFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogY29udGFpbmVyLmlkLFxuICAgICAgICAgICAgICAgIGltYWdlczogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEltYWdlcyhjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lckltYWdlc1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRJbWFnZShjb250YWluZXIsIGltYWdlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckltYWdlcyA9IHRoaXMuZ2V0SW1hZ2VzKGNvbnRhaW5lcik7XG4gICAgICAgIGNvbnRhaW5lckltYWdlcyA9PT0gbnVsbCB8fCBjb250YWluZXJJbWFnZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRhaW5lckltYWdlcy5pbWFnZXMucHVzaChpbWFnZSk7XG4gICAgfVxuICAgIGluaXQoY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlT3B0aW9ucyA9IG9wdGlvbnMucGFydGljbGVzLnNoYXBlO1xuICAgICAgICAgICAgaWYgKCFVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLlNoYXBlVHlwZS5pbWFnZSwgc2hhcGVPcHRpb25zLnR5cGUpICYmXG4gICAgICAgICAgICAgICAgIVV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuU2hhcGVUeXBlLmltYWdlcywgc2hhcGVPcHRpb25zLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW1hZ2VPcHRpb25zID0gKF9hID0gc2hhcGVPcHRpb25zLm9wdGlvbnNbRW51bXNfMS5TaGFwZVR5cGUuaW1hZ2VzXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2hhcGVPcHRpb25zLm9wdGlvbnNbRW51bXNfMS5TaGFwZVR5cGUuaW1hZ2VdO1xuICAgICAgICAgICAgaWYgKGltYWdlT3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb25zSW1hZ2Ugb2YgaW1hZ2VPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMubG9hZEltYWdlU2hhcGUoY29udGFpbmVyLCBvcHRpb25zSW1hZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMubG9hZEltYWdlU2hhcGUoY29udGFpbmVyLCBpbWFnZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5pbWFnZXMgPSBbXTtcbiAgICB9XG4gICAgbG9hZEltYWdlU2hhcGUoY29udGFpbmVyLCBpbWFnZVNoYXBlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0gaW1hZ2VTaGFwZS5yZXBsYWNlQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgPyB5aWVsZCBVdGlsc18xLlV0aWxzLmRvd25sb2FkU3ZnSW1hZ2UoaW1hZ2VTaGFwZS5zcmMpXG4gICAgICAgICAgICAgICAgICAgIDogeWllbGQgVXRpbHNfMS5VdGlscy5sb2FkSW1hZ2UoaW1hZ2VTaGFwZS5zcmMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW1hZ2UoY29udGFpbmVyLCBpbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYHRzUGFydGljbGVzIGVycm9yIC0gJHtpbWFnZVNoYXBlLnNyY30gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkcmF3KGNvbnRleHQsIHBhcnRpY2xlLCByYWRpdXMsIG9wYWNpdHkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1hZ2UgPSBwYXJ0aWNsZS5pbWFnZTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IChfYSA9IGltYWdlID09PSBudWxsIHx8IGltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbWFnZS5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZWxlbWVudDtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF0aW8gPSAoX2IgPSBpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2UucmF0aW8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XG4gICAgICAgIGNvbnN0IHBvcyA9IHtcbiAgICAgICAgICAgIHg6IC1yYWRpdXMsXG4gICAgICAgICAgICB5OiAtcmFkaXVzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIShpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2UuZGF0YS5zdmdEYXRhKSB8fCAhKGltYWdlID09PSBudWxsIHx8IGltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbWFnZS5yZXBsYWNlQ29sb3IpKSB7XG4gICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShlbGVtZW50LCBwb3MueCwgcG9zLnksIHJhZGl1cyAqIDIsIChyYWRpdXMgKiAyKSAvIHJhdGlvKTtcbiAgICAgICAgaWYgKCEoaW1hZ2UgPT09IG51bGwgfHwgaW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGltYWdlLmRhdGEuc3ZnRGF0YSkgfHwgIShpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2UucmVwbGFjZUNvbG9yKSkge1xuICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkltYWdlRHJhd2VyID0gSW1hZ2VEcmF3ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGluZURyYXdlciA9IHZvaWQgMDtcbmNsYXNzIExpbmVEcmF3ZXIge1xuICAgIGdldFNpZGVzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBkcmF3KGNvbnRleHQsIHBhcnRpY2xlLCByYWRpdXMpIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgLXJhZGl1cyAvIDIpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbygwLCByYWRpdXMgLyAyKTtcbiAgICB9XG59XG5leHBvcnRzLkxpbmVEcmF3ZXIgPSBMaW5lRHJhd2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbHlnb25EcmF3ZXIgPSB2b2lkIDA7XG5jb25zdCBQb2x5Z29uRHJhd2VyQmFzZV8xID0gcmVxdWlyZShcIi4vUG9seWdvbkRyYXdlckJhc2VcIik7XG5jbGFzcyBQb2x5Z29uRHJhd2VyIGV4dGVuZHMgUG9seWdvbkRyYXdlckJhc2VfMS5Qb2x5Z29uRHJhd2VyQmFzZSB7XG4gICAgZ2V0U2lkZXNEYXRhKHBhcnRpY2xlLCByYWRpdXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcG9seWdvbiA9IHBhcnRpY2xlLnNoYXBlRGF0YTtcbiAgICAgICAgY29uc3Qgc2lkZXMgPSAoX2IgPSAoX2EgPSBwb2x5Z29uID09PSBudWxsIHx8IHBvbHlnb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvbHlnb24uc2lkZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvbHlnb24gPT09IG51bGwgfHwgcG9seWdvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9seWdvbi5uYl9zaWRlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogNTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvdW50OiB7XG4gICAgICAgICAgICAgICAgZGVub21pbmF0b3I6IDEsXG4gICAgICAgICAgICAgICAgbnVtZXJhdG9yOiBzaWRlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IChyYWRpdXMgKiAyLjY2KSAvIChzaWRlcyAvIDMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDZW50ZXIocGFydGljbGUsIHJhZGl1cykge1xuICAgICAgICBjb25zdCBzaWRlcyA9IHRoaXMuZ2V0U2lkZXNDb3VudChwYXJ0aWNsZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAtcmFkaXVzIC8gKHNpZGVzIC8gMy41KSxcbiAgICAgICAgICAgIHk6IC1yYWRpdXMgLyAoMi42NiAvIDMuNSksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Qb2x5Z29uRHJhd2VyID0gUG9seWdvbkRyYXdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2x5Z29uRHJhd2VyQmFzZSA9IHZvaWQgMDtcbmNsYXNzIFBvbHlnb25EcmF3ZXJCYXNlIHtcbiAgICBnZXRTaWRlc0NvdW50KHBhcnRpY2xlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHBvbHlnb24gPSBwYXJ0aWNsZS5zaGFwZURhdGE7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBwb2x5Z29uID09PSBudWxsIHx8IHBvbHlnb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvbHlnb24uc2lkZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvbHlnb24gPT09IG51bGwgfHwgcG9seWdvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9seWdvbi5uYl9zaWRlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogNTtcbiAgICB9XG4gICAgZHJhdyhjb250ZXh0LCBwYXJ0aWNsZSwgcmFkaXVzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5nZXRDZW50ZXIocGFydGljbGUsIHJhZGl1cyk7XG4gICAgICAgIGNvbnN0IHNpZGUgPSB0aGlzLmdldFNpZGVzRGF0YShwYXJ0aWNsZSwgcmFkaXVzKTtcbiAgICAgICAgY29uc3Qgc2lkZUNvdW50ID0gc2lkZS5jb3VudC5udW1lcmF0b3IgKiBzaWRlLmNvdW50LmRlbm9taW5hdG9yO1xuICAgICAgICBjb25zdCBkZWNpbWFsU2lkZXMgPSBzaWRlLmNvdW50Lm51bWVyYXRvciAvIHNpZGUuY291bnQuZGVub21pbmF0b3I7XG4gICAgICAgIGNvbnN0IGludGVyaW9yQW5nbGVEZWdyZWVzID0gKDE4MCAqIChkZWNpbWFsU2lkZXMgLSAyKSkgLyBkZWNpbWFsU2lkZXM7XG4gICAgICAgIGNvbnN0IGludGVyaW9yQW5nbGUgPSBNYXRoLlBJIC0gKE1hdGguUEkgKiBpbnRlcmlvckFuZ2xlRGVncmVlcykgLyAxODA7XG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWRlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oc2lkZS5sZW5ndGgsIDApO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoc2lkZS5sZW5ndGgsIDApO1xuICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoaW50ZXJpb3JBbmdsZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBvbHlnb25EcmF3ZXJCYXNlID0gUG9seWdvbkRyYXdlckJhc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3F1YXJlRHJhd2VyID0gdm9pZCAwO1xuY2xhc3MgU3F1YXJlRHJhd2VyIHtcbiAgICBnZXRTaWRlc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgZHJhdyhjb250ZXh0LCBwYXJ0aWNsZSwgcmFkaXVzKSB7XG4gICAgICAgIGNvbnRleHQucmVjdCgtcmFkaXVzLCAtcmFkaXVzLCByYWRpdXMgKiAyLCByYWRpdXMgKiAyKTtcbiAgICB9XG59XG5leHBvcnRzLlNxdWFyZURyYXdlciA9IFNxdWFyZURyYXdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGFyRHJhd2VyID0gdm9pZCAwO1xuY2xhc3MgU3RhckRyYXdlciB7XG4gICAgZ2V0U2lkZXNDb3VudChwYXJ0aWNsZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBzdGFyID0gcGFydGljbGUuc2hhcGVEYXRhO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gc3RhciA9PT0gbnVsbCB8fCBzdGFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGFyLnNpZGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzdGFyID09PSBudWxsIHx8IHN0YXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXIubmJfc2lkZXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDU7XG4gICAgfVxuICAgIGRyYXcoY29udGV4dCwgcGFydGljbGUsIHJhZGl1cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHN0YXIgPSBwYXJ0aWNsZS5zaGFwZURhdGE7XG4gICAgICAgIGNvbnN0IHNpZGVzID0gdGhpcy5nZXRTaWRlc0NvdW50KHBhcnRpY2xlKTtcbiAgICAgICAgY29uc3QgaW5zZXQgPSAoX2EgPSBzdGFyID09PSBudWxsIHx8IHN0YXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXIuaW5zZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDI7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDAgLSByYWRpdXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRleHQucm90YXRlKE1hdGguUEkgLyBzaWRlcyk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAwIC0gcmFkaXVzICogaW5zZXQpO1xuICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoTWF0aC5QSSAvIHNpZGVzKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIDAgLSByYWRpdXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdGFyRHJhd2VyID0gU3RhckRyYXdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRleHREcmF3ZXIgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi9FbnVtc1wiKTtcbmNsYXNzIFRleHREcmF3ZXIge1xuICAgIGdldFNpZGVzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gICAgaW5pdChjb250YWluZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuU2hhcGVUeXBlLmNoYXIsIG9wdGlvbnMucGFydGljbGVzLnNoYXBlLnR5cGUpIHx8XG4gICAgICAgICAgICAgICAgVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoRW51bXNfMS5TaGFwZVR5cGUuY2hhcmFjdGVyLCBvcHRpb25zLnBhcnRpY2xlcy5zaGFwZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYXBlT3B0aW9ucyA9ICgoX2EgPSBvcHRpb25zLnBhcnRpY2xlcy5zaGFwZS5vcHRpb25zW0VudW1zXzEuU2hhcGVUeXBlLmNoYXJhY3Rlcl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdGlvbnMucGFydGljbGVzLnNoYXBlLm9wdGlvbnNbRW51bXNfMS5TaGFwZVR5cGUuY2hhcl0pO1xuICAgICAgICAgICAgICAgIGlmIChzaGFwZU9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoYXJhY3RlciBvZiBzaGFwZU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFV0aWxzXzEuVXRpbHMubG9hZEZvbnQoY2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBVdGlsc18xLlV0aWxzLmxvYWRGb250KHNoYXBlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkcmF3KGNvbnRleHQsIHBhcnRpY2xlLCByYWRpdXMpIHtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyID0gcGFydGljbGUuc2hhcGVEYXRhO1xuICAgICAgICBpZiAoY2hhcmFjdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0RGF0YSA9IGNoYXJhY3Rlci52YWx1ZTtcbiAgICAgICAgaWYgKHRleHREYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0UGFydGljbGUgPSBwYXJ0aWNsZTtcbiAgICAgICAgaWYgKHRleHRQYXJ0aWNsZS50ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRleHRQYXJ0aWNsZS50ZXh0ID1cbiAgICAgICAgICAgICAgICB0ZXh0RGF0YSBpbnN0YW5jZW9mIEFycmF5ID8gVXRpbHNfMS5VdGlscy5pdGVtRnJvbUFycmF5KHRleHREYXRhLCBwYXJ0aWNsZS5yYW5kb21JbmRleERhdGEpIDogdGV4dERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IHRleHRQYXJ0aWNsZS50ZXh0O1xuICAgICAgICBjb25zdCBzdHlsZSA9IGNoYXJhY3Rlci5zdHlsZTtcbiAgICAgICAgY29uc3Qgd2VpZ2h0ID0gY2hhcmFjdGVyLndlaWdodDtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgucm91bmQocmFkaXVzKSAqIDI7XG4gICAgICAgIGNvbnN0IGZvbnQgPSBjaGFyYWN0ZXIuZm9udDtcbiAgICAgICAgY29uc3QgZmlsbCA9IHBhcnRpY2xlLmZpbGw7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSAodGV4dC5sZW5ndGggKiByYWRpdXMpIC8gMjtcbiAgICAgICAgY29udGV4dC5mb250ID0gYCR7c3R5bGV9ICR7d2VpZ2h0fSAke3NpemV9cHggXCIke2ZvbnR9XCJgO1xuICAgICAgICBjb25zdCBwb3MgPSB7XG4gICAgICAgICAgICB4OiAtb2Zmc2V0WCxcbiAgICAgICAgICAgIHk6IHJhZGl1cyAvIDIsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIHBvcy54LCBwb3MueSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGV4dCwgcG9zLngsIHBvcy55KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVGV4dERyYXdlciA9IFRleHREcmF3ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJpYW5nbGVEcmF3ZXIgPSB2b2lkIDA7XG5jb25zdCBQb2x5Z29uRHJhd2VyQmFzZV8xID0gcmVxdWlyZShcIi4vUG9seWdvbkRyYXdlckJhc2VcIik7XG5jbGFzcyBUcmlhbmdsZURyYXdlciBleHRlbmRzIFBvbHlnb25EcmF3ZXJCYXNlXzEuUG9seWdvbkRyYXdlckJhc2Uge1xuICAgIGdldFNpZGVzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgICBnZXRTaWRlc0RhdGEocGFydGljbGUsIHJhZGl1cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY291bnQ6IHtcbiAgICAgICAgICAgICAgICBkZW5vbWluYXRvcjogMixcbiAgICAgICAgICAgICAgICBudW1lcmF0b3I6IDMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiByYWRpdXMgKiAyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDZW50ZXIocGFydGljbGUsIHJhZGl1cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogLXJhZGl1cyxcbiAgICAgICAgICAgIHk6IHJhZGl1cyAvIDEuNjYsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5UcmlhbmdsZURyYXdlciA9IFRyaWFuZ2xlRHJhd2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1JlY3Vyc2l2ZVBhcnRpYWxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1NoYXBlRGF0YVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vU2hhcGVEcmF3ZXJGdW5jdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1NpbmdsZU9yTXVsdGlwbGVcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbnZhc1V0aWxzID0gdm9pZCAwO1xuY29uc3QgQ29sb3JVdGlsc18xID0gcmVxdWlyZShcIi4vQ29sb3JVdGlsc1wiKTtcbmNvbnN0IE51bWJlclV0aWxzXzEgPSByZXF1aXJlKFwiLi9OdW1iZXJVdGlsc1wiKTtcbmZ1bmN0aW9uIGRyYXdMaW5lKGNvbnRleHQsIGJlZ2luLCBlbmQpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKGJlZ2luLngsIGJlZ2luLnkpO1xuICAgIGNvbnRleHQubGluZVRvKGVuZC54LCBlbmQueSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn1cbmZ1bmN0aW9uIGRyYXdUcmlhbmdsZShjb250ZXh0LCBwMSwgcDIsIHAzKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhwMS54LCBwMS55KTtcbiAgICBjb250ZXh0LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICBjb250ZXh0LmxpbmVUbyhwMy54LCBwMy55KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufVxuY2xhc3MgQ2FudmFzVXRpbHMge1xuICAgIHN0YXRpYyBwYWludEJhc2UoY29udGV4dCwgZGltZW5zaW9uLCBiYXNlQ29sb3IpIHtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYmFzZUNvbG9yICE9PSBudWxsICYmIGJhc2VDb2xvciAhPT0gdm9pZCAwID8gYmFzZUNvbG9yIDogXCJyZ2JhKDAsMCwwLDApXCI7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBjbGVhcihjb250ZXh0LCBkaW1lbnNpb24pIHtcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICB9XG4gICAgc3RhdGljIGRyYXdMaW5rTGluZShjb250ZXh0LCB3aWR0aCwgYmVnaW4sIGVuZCwgbWF4RGlzdGFuY2UsIGNhbnZhc1NpemUsIHdhcnAsIGJhY2tncm91bmRNYXNrLCBjb21wb3NpdGUsIGNvbG9yTGluZSwgb3BhY2l0eSwgc2hhZG93KSB7XG4gICAgICAgIGxldCBkcmF3biA9IGZhbHNlO1xuICAgICAgICBpZiAoTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShiZWdpbiwgZW5kKSA8PSBtYXhEaXN0YW5jZSkge1xuICAgICAgICAgICAgZHJhd0xpbmUoY29udGV4dCwgYmVnaW4sIGVuZCk7XG4gICAgICAgICAgICBkcmF3biA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2FycCkge1xuICAgICAgICAgICAgbGV0IHBpMTtcbiAgICAgICAgICAgIGxldCBwaTI7XG4gICAgICAgICAgICBjb25zdCBlbmRORSA9IHtcbiAgICAgICAgICAgICAgICB4OiBlbmQueCAtIGNhbnZhc1NpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgeTogZW5kLnksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZDEgPSBOdW1iZXJVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlcyhiZWdpbiwgZW5kTkUpO1xuICAgICAgICAgICAgaWYgKGQxLmRpc3RhbmNlIDw9IG1heERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeWkgPSBiZWdpbi55IC0gKGQxLmR5IC8gZDEuZHgpICogYmVnaW4ueDtcbiAgICAgICAgICAgICAgICBwaTEgPSB7IHg6IDAsIHk6IHlpIH07XG4gICAgICAgICAgICAgICAgcGkyID0geyB4OiBjYW52YXNTaXplLndpZHRoLCB5OiB5aSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kU1cgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGVuZC54LFxuICAgICAgICAgICAgICAgICAgICB5OiBlbmQueSAtIGNhbnZhc1NpemUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZDIgPSBOdW1iZXJVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlcyhiZWdpbiwgZW5kU1cpO1xuICAgICAgICAgICAgICAgIGlmIChkMi5kaXN0YW5jZSA8PSBtYXhEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5aSA9IGJlZ2luLnkgLSAoZDIuZHkgLyBkMi5keCkgKiBiZWdpbi54O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4aSA9IC15aSAvIChkMi5keSAvIGQyLmR4KTtcbiAgICAgICAgICAgICAgICAgICAgcGkxID0geyB4OiB4aSwgeTogMCB9O1xuICAgICAgICAgICAgICAgICAgICBwaTIgPSB7IHg6IHhpLCB5OiBjYW52YXNTaXplLmhlaWdodCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kU0UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBlbmQueCAtIGNhbnZhc1NpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBlbmQueSAtIGNhbnZhc1NpemUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkMyA9IE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2VzKGJlZ2luLCBlbmRTRSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkMy5kaXN0YW5jZSA8PSBtYXhEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeWkgPSBiZWdpbi55IC0gKGQzLmR5IC8gZDMuZHgpICogYmVnaW4ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHhpID0gLXlpIC8gKGQzLmR5IC8gZDMuZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGkxID0geyB4OiB4aSwgeTogeWkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpMiA9IHsgeDogcGkxLnggKyBjYW52YXNTaXplLndpZHRoLCB5OiBwaTEueSArIGNhbnZhc1NpemUuaGVpZ2h0IH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGkxICYmIHBpMikge1xuICAgICAgICAgICAgICAgIGRyYXdMaW5lKGNvbnRleHQsIGJlZ2luLCBwaTEpO1xuICAgICAgICAgICAgICAgIGRyYXdMaW5lKGNvbnRleHQsIGVuZCwgcGkyKTtcbiAgICAgICAgICAgICAgICBkcmF3biA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkcmF3bikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kTWFzaykge1xuICAgICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IENvbG9yVXRpbHNfMS5Db2xvclV0aWxzLmdldFN0eWxlRnJvbVJnYihjb2xvckxpbmUsIG9wYWNpdHkpO1xuICAgICAgICBpZiAoc2hhZG93LmVuYWJsZSkge1xuICAgICAgICAgICAgY29uc3Qgc2hhZG93Q29sb3IgPSBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvUmdiKHNoYWRvdy5jb2xvcik7XG4gICAgICAgICAgICBpZiAoc2hhZG93Q29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1cjtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gQ29sb3JVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKHNoYWRvd0NvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZHJhd0xpbmtUcmlhbmdsZShjb250ZXh0LCBwb3MxLCBwb3MyLCBwb3MzLCBiYWNrZ3JvdW5kTWFzaywgY29tcG9zaXRlLCBjb2xvclRyaWFuZ2xlLCBvcGFjaXR5VHJpYW5nbGUpIHtcbiAgICAgICAgZHJhd1RyaWFuZ2xlKGNvbnRleHQsIHBvczEsIHBvczIsIHBvczMpO1xuICAgICAgICBpZiAoYmFja2dyb3VuZE1hc2spIHtcbiAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gQ29sb3JVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKGNvbG9yVHJpYW5nbGUsIG9wYWNpdHlUcmlhbmdsZSk7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgICBzdGF0aWMgZHJhd0Nvbm5lY3RMaW5lKGNvbnRleHQsIHdpZHRoLCBsaW5lU3R5bGUsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGRyYXdMaW5lKGNvbnRleHQsIGJlZ2luLCBlbmQpO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gbGluZVN0eWxlO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgc3RhdGljIGdyYWRpZW50KGNvbnRleHQsIHAxLCBwMiwgb3BhY2l0eSkge1xuICAgICAgICBjb25zdCBncmFkU3RvcCA9IE1hdGguZmxvb3IocDIuZ2V0UmFkaXVzKCkgLyBwMS5nZXRSYWRpdXMoKSk7XG4gICAgICAgIGNvbnN0IGNvbG9yMSA9IHAxLmdldEZpbGxDb2xvcigpO1xuICAgICAgICBjb25zdCBjb2xvcjIgPSBwMi5nZXRGaWxsQ29sb3IoKTtcbiAgICAgICAgaWYgKCFjb2xvcjEgfHwgIWNvbG9yMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZVBvcyA9IHAxLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IGRlc3RQb3MgPSBwMi5nZXRQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBtaWRSZ2IgPSBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5taXgoY29sb3IxLCBjb2xvcjIsIHAxLmdldFJhZGl1cygpLCBwMi5nZXRSYWRpdXMoKSk7XG4gICAgICAgIGNvbnN0IGdyYWQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHNvdXJjZVBvcy54LCBzb3VyY2VQb3MueSwgZGVzdFBvcy54LCBkZXN0UG9zLnkpO1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgwLCBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21Ic2woY29sb3IxLCBvcGFjaXR5KSk7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGdyYWRTdG9wID4gMSA/IDEgOiBncmFkU3RvcCwgQ29sb3JVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKG1pZFJnYiwgb3BhY2l0eSkpO1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgxLCBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21Ic2woY29sb3IyLCBvcGFjaXR5KSk7XG4gICAgICAgIHJldHVybiBncmFkO1xuICAgIH1cbiAgICBzdGF0aWMgZHJhd0dyYWJMaW5lKGNvbnRleHQsIHdpZHRoLCBiZWdpbiwgZW5kLCBjb2xvckxpbmUsIG9wYWNpdHkpIHtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGRyYXdMaW5lKGNvbnRleHQsIGJlZ2luLCBlbmQpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gQ29sb3JVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKGNvbG9yTGluZSwgb3BhY2l0eSk7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZHJhd0xpZ2h0KGNvbnRhaW5lciwgY29udGV4dCwgbW91c2VQb3MpIHtcbiAgICAgICAgY29uc3QgbGlnaHRPcHRpb25zID0gY29udGFpbmVyLm9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5saWdodC5hcmVhO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmFyYyhtb3VzZVBvcy54LCBtb3VzZVBvcy55LCBsaWdodE9wdGlvbnMucmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgIGNvbnN0IGdyYWRpZW50QW1iaWVudExpZ2h0ID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChtb3VzZVBvcy54LCBtb3VzZVBvcy55LCAwLCBtb3VzZVBvcy54LCBtb3VzZVBvcy55LCBsaWdodE9wdGlvbnMucmFkaXVzKTtcbiAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBsaWdodE9wdGlvbnMuZ3JhZGllbnQ7XG4gICAgICAgIGNvbnN0IGdyYWRpZW50UmdiID0ge1xuICAgICAgICAgICAgc3RhcnQ6IENvbG9yVXRpbHNfMS5Db2xvclV0aWxzLmNvbG9yVG9SZ2IoZ3JhZGllbnQuc3RhcnQpLFxuICAgICAgICAgICAgc3RvcDogQ29sb3JVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb1JnYihncmFkaWVudC5zdG9wKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFncmFkaWVudFJnYi5zdGFydCB8fCAhZ3JhZGllbnRSZ2Iuc3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdyYWRpZW50QW1iaWVudExpZ2h0LmFkZENvbG9yU3RvcCgwLCBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21SZ2IoZ3JhZGllbnRSZ2Iuc3RhcnQpKTtcbiAgICAgICAgZ3JhZGllbnRBbWJpZW50TGlnaHQuYWRkQ29sb3JTdG9wKDEsIENvbG9yVXRpbHNfMS5Db2xvclV0aWxzLmdldFN0eWxlRnJvbVJnYihncmFkaWVudFJnYi5zdG9wKSk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZ3JhZGllbnRBbWJpZW50TGlnaHQ7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgICBzdGF0aWMgZHJhd1BhcnRpY2xlU2hhZG93KGNvbnRhaW5lciwgY29udGV4dCwgcGFydGljbGUsIG1vdXNlUG9zKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHBhcnRpY2xlLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IHNoYWRvd09wdGlvbnMgPSBjb250YWluZXIub3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLmxpZ2h0LnNoYWRvdztcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IHBhcnRpY2xlLmdldFJhZGl1cygpO1xuICAgICAgICBjb25zdCBzaWRlcyA9IHBhcnRpY2xlLnNpZGVzO1xuICAgICAgICBjb25zdCBmdWxsID0gKE1hdGguUEkgKiAyKSAvIHNpZGVzO1xuICAgICAgICBjb25zdCBhbmdsZSA9IC1wYXJ0aWNsZS5yb3RhdGUudmFsdWUgKyBNYXRoLlBJIC8gNDtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gMTtcbiAgICAgICAgY29uc3QgZG90cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICAgICAgICAgIGRvdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogcG9zLnggKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSArIGZ1bGwgKiBpKSAqIGZhY3RvcixcbiAgICAgICAgICAgICAgICB5OiBwb3MueSArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlICsgZnVsbCAqIGkpICogZmFjdG9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgIGNvbnN0IHNoYWRvd0xlbmd0aCA9IHNoYWRvd09wdGlvbnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGNvbnN0IGRvdCBvZiBkb3RzKSB7XG4gICAgICAgICAgICBjb25zdCBkb3RBbmdsZSA9IE1hdGguYXRhbjIobW91c2VQb3MueSAtIGRvdC55LCBtb3VzZVBvcy54IC0gZG90LngpO1xuICAgICAgICAgICAgY29uc3QgZW5kWCA9IGRvdC54ICsgc2hhZG93TGVuZ3RoICogTWF0aC5zaW4oLWRvdEFuZ2xlIC0gTWF0aC5QSSAvIDIpO1xuICAgICAgICAgICAgY29uc3QgZW5kWSA9IGRvdC55ICsgc2hhZG93TGVuZ3RoICogTWF0aC5jb3MoLWRvdEFuZ2xlIC0gTWF0aC5QSSAvIDIpO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVuZFg6IGVuZFgsXG4gICAgICAgICAgICAgICAgZW5kWTogZW5kWSxcbiAgICAgICAgICAgICAgICBzdGFydFg6IGRvdC54LFxuICAgICAgICAgICAgICAgIHN0YXJ0WTogZG90LnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaGFkb3dSZ2IgPSBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvUmdiKHNoYWRvd09wdGlvbnMuY29sb3IpO1xuICAgICAgICBpZiAoIXNoYWRvd1JnYikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNoYWRvd0NvbG9yID0gQ29sb3JVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKHNoYWRvd1JnYik7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBpID09IHBvaW50cy5sZW5ndGggLSAxID8gMCA6IGkgKyAxO1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1tpXS5zdGFydFgsIHBvaW50c1tpXS5zdGFydFkpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW25dLnN0YXJ0WCwgcG9pbnRzW25dLnN0YXJ0WSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbbl0uZW5kWCwgcG9pbnRzW25dLmVuZFkpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2ldLmVuZFgsIHBvaW50c1tpXS5lbmRZKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc2hhZG93Q29sb3I7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgc3RhdGljIGRyYXdQYXJ0aWNsZShjb250YWluZXIsIGNvbnRleHQsIHBhcnRpY2xlLCBkZWx0YSwgZmlsbENvbG9yVmFsdWUsIHN0cm9rZUNvbG9yVmFsdWUsIGJhY2tncm91bmRNYXNrLCBjb21wb3NpdGUsIHJhZGl1cywgb3BhY2l0eSwgc2hhZG93KSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHBhcnRpY2xlLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShwb3MueCwgcG9zLnkpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IHBhcnRpY2xlLnJvdGF0ZS52YWx1ZSArIChwYXJ0aWNsZS5wYXJ0aWNsZXNPcHRpb25zLnJvdGF0ZS5wYXRoID8gcGFydGljbGUucGF0aEFuZ2xlIDogMCk7XG4gICAgICAgIGlmIChhbmdsZSAhPT0gMCkge1xuICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoYW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kTWFzaykge1xuICAgICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hhZG93Q29sb3IgPSBwYXJ0aWNsZS5zaGFkb3dDb2xvcjtcbiAgICAgICAgaWYgKHNoYWRvdy5lbmFibGUgJiYgc2hhZG93Q29sb3IpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IHNoYWRvdy5ibHVyO1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IENvbG9yVXRpbHNfMS5Db2xvclV0aWxzLmdldFN0eWxlRnJvbVJnYihzaGFkb3dDb2xvcik7XG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSBzaGFkb3cub2Zmc2V0Lng7XG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSBzaGFkb3cub2Zmc2V0Lnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGxDb2xvclZhbHVlKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxDb2xvclZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cm9rZSA9IHBhcnRpY2xlLnN0cm9rZTtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBwYXJ0aWNsZS5zdHJva2VXaWR0aDtcbiAgICAgICAgaWYgKHN0cm9rZUNvbG9yVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvclZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIENhbnZhc1V0aWxzLmRyYXdTaGFwZShjb250YWluZXIsIGNvbnRleHQsIHBhcnRpY2xlLCByYWRpdXMsIG9wYWNpdHksIGRlbHRhKTtcbiAgICAgICAgaWYgKHN0cm9rZS53aWR0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpY2xlLmNsb3NlKSB7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWNsZS5maWxsKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHBvcy54LCBwb3MueSk7XG4gICAgICAgIGlmIChhbmdsZSAhPT0gMCkge1xuICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoYW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kTWFzaykge1xuICAgICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGU7XG4gICAgICAgIH1cbiAgICAgICAgQ2FudmFzVXRpbHMuZHJhd1NoYXBlQWZ0ZXJFZmZlY3QoY29udGFpbmVyLCBjb250ZXh0LCBwYXJ0aWNsZSwgcmFkaXVzLCBvcGFjaXR5LCBkZWx0YSk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZHJhd1NoYXBlKGNvbnRhaW5lciwgY29udGV4dCwgcGFydGljbGUsIHJhZGl1cywgb3BhY2l0eSwgZGVsdGEpIHtcbiAgICAgICAgaWYgKCFwYXJ0aWNsZS5zaGFwZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyYXdlciA9IGNvbnRhaW5lci5kcmF3ZXJzLmdldChwYXJ0aWNsZS5zaGFwZSk7XG4gICAgICAgIGlmICghZHJhd2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZHJhd2VyLmRyYXcoY29udGV4dCwgcGFydGljbGUsIHJhZGl1cywgb3BhY2l0eSwgZGVsdGEudmFsdWUsIGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbyk7XG4gICAgfVxuICAgIHN0YXRpYyBkcmF3U2hhcGVBZnRlckVmZmVjdChjb250YWluZXIsIGNvbnRleHQsIHBhcnRpY2xlLCByYWRpdXMsIG9wYWNpdHksIGRlbHRhKSB7XG4gICAgICAgIGlmICghcGFydGljbGUuc2hhcGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcmF3ZXIgPSBjb250YWluZXIuZHJhd2Vycy5nZXQocGFydGljbGUuc2hhcGUpO1xuICAgICAgICBpZiAoIShkcmF3ZXIgPT09IG51bGwgfHwgZHJhd2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmF3ZXIuYWZ0ZXJFZmZlY3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZHJhd2VyLmFmdGVyRWZmZWN0KGNvbnRleHQsIHBhcnRpY2xlLCByYWRpdXMsIG9wYWNpdHksIGRlbHRhLnZhbHVlLCBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICBzdGF0aWMgZHJhd1BsdWdpbihjb250ZXh0LCBwbHVnaW4sIGRlbHRhKSB7XG4gICAgICAgIGlmIChwbHVnaW4uZHJhdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIHBsdWdpbi5kcmF3KGNvbnRleHQsIGRlbHRhKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYW52YXNVdGlscyA9IENhbnZhc1V0aWxzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNpcmNsZSA9IHZvaWQgMDtcbmNvbnN0IFJhbmdlXzEgPSByZXF1aXJlKFwiLi9SYW5nZVwiKTtcbmNsYXNzIENpcmNsZSBleHRlbmRzIFJhbmdlXzEuUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHJhZGl1cykge1xuICAgICAgICBzdXBlcih4LCB5KTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgfVxuICAgIGNvbnRhaW5zKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IGQgPSBNYXRoLnBvdyhwb2ludC54IC0gdGhpcy5wb3NpdGlvbi54LCAyKSArIE1hdGgucG93KHBvaW50LnkgLSB0aGlzLnBvc2l0aW9uLnksIDIpO1xuICAgICAgICByZXR1cm4gZCA8PSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuICAgIH1cbiAgICBpbnRlcnNlY3RzKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSByYW5nZTtcbiAgICAgICAgY29uc3QgY2lyY2xlID0gcmFuZ2U7XG4gICAgICAgIGNvbnN0IHBvczEgPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCBwb3MyID0gcmFuZ2UucG9zaXRpb247XG4gICAgICAgIGNvbnN0IHhEaXN0ID0gTWF0aC5hYnMocG9zMi54IC0gcG9zMS54KTtcbiAgICAgICAgY29uc3QgeURpc3QgPSBNYXRoLmFicyhwb3MyLnkgLSBwb3MxLnkpO1xuICAgICAgICBjb25zdCByID0gdGhpcy5yYWRpdXM7XG4gICAgICAgIGlmIChjaXJjbGUucmFkaXVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJTdW0gPSByICsgY2lyY2xlLnJhZGl1cztcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoeERpc3QgKiB4RGlzdCArIHlEaXN0ICsgeURpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHJTdW0gPiBkaXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlY3Quc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB3ID0gcmVjdC5zaXplLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgaCA9IHJlY3Quc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBlZGdlcyA9IE1hdGgucG93KHhEaXN0IC0gdywgMikgKyBNYXRoLnBvdyh5RGlzdCAtIGgsIDIpO1xuICAgICAgICAgICAgaWYgKHhEaXN0ID4gciArIHcgfHwgeURpc3QgPiByICsgaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4RGlzdCA8PSB3IHx8IHlEaXN0IDw9IGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlZGdlcyA8PSByICogcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5DaXJjbGUgPSBDaXJjbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2lyY2xlV2FycCA9IHZvaWQgMDtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xuY29uc3QgQ2lyY2xlXzEgPSByZXF1aXJlKFwiLi9DaXJjbGVcIik7XG5jbGFzcyBDaXJjbGVXYXJwIGV4dGVuZHMgQ2lyY2xlXzEuQ2lyY2xlIHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCByYWRpdXMsIGNhbnZhc1NpemUpIHtcbiAgICAgICAgc3VwZXIoeCwgeSwgcmFkaXVzKTtcbiAgICAgICAgdGhpcy5jYW52YXNTaXplID0gY2FudmFzU2l6ZTtcbiAgICAgICAgdGhpcy5jYW52YXNTaXplID0ge1xuICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXNTaXplLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiBjYW52YXNTaXplLndpZHRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb250YWlucyhwb2ludCkge1xuICAgICAgICBpZiAoc3VwZXIuY29udGFpbnMocG9pbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NORSA9IHtcbiAgICAgICAgICAgIHg6IHBvaW50LnggLSB0aGlzLmNhbnZhc1NpemUud2lkdGgsXG4gICAgICAgICAgICB5OiBwb2ludC55LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc3VwZXIuY29udGFpbnMocG9zTkUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NTRSA9IHtcbiAgICAgICAgICAgIHg6IHBvaW50LnggLSB0aGlzLmNhbnZhc1NpemUud2lkdGgsXG4gICAgICAgICAgICB5OiBwb2ludC55IC0gdGhpcy5jYW52YXNTaXplLmhlaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHN1cGVyLmNvbnRhaW5zKHBvc1NFKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zU1cgPSB7XG4gICAgICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICAgICAgeTogcG9pbnQueSAtIHRoaXMuY2FudmFzU2l6ZS5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdXBlci5jb250YWlucyhwb3NTVyk7XG4gICAgfVxuICAgIGludGVyc2VjdHMocmFuZ2UpIHtcbiAgICAgICAgaWYgKHN1cGVyLmludGVyc2VjdHMocmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWN0ID0gcmFuZ2U7XG4gICAgICAgIGNvbnN0IGNpcmNsZSA9IHJhbmdlO1xuICAgICAgICBjb25zdCBuZXdQb3MgPSB7XG4gICAgICAgICAgICB4OiByYW5nZS5wb3NpdGlvbi54IC0gdGhpcy5jYW52YXNTaXplLndpZHRoLFxuICAgICAgICAgICAgeTogcmFuZ2UucG9zaXRpb24ueSAtIHRoaXMuY2FudmFzU2l6ZS5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjaXJjbGUucmFkaXVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpZ2dlckNpcmNsZSA9IG5ldyBDaXJjbGVfMS5DaXJjbGUobmV3UG9zLngsIG5ld1Bvcy55LCBjaXJjbGUucmFkaXVzICogMik7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuaW50ZXJzZWN0cyhiaWdnZXJDaXJjbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlY3Quc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByZWN0U1cgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKG5ld1Bvcy54LCBuZXdQb3MueSwgcmVjdC5zaXplLndpZHRoICogMiwgcmVjdC5zaXplLmhlaWdodCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmludGVyc2VjdHMocmVjdFNXKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5DaXJjbGVXYXJwID0gQ2lyY2xlV2FycDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2xvclV0aWxzID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuL1V0aWxzXCIpO1xuY29uc3QgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9Db25zdGFudHNcIik7XG5jb25zdCBOdW1iZXJVdGlsc18xID0gcmVxdWlyZShcIi4vTnVtYmVyVXRpbHNcIik7XG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICBsZXQgdENhbGMgPSB0O1xuICAgIGlmICh0Q2FsYyA8IDApIHtcbiAgICAgICAgdENhbGMgKz0gMTtcbiAgICB9XG4gICAgaWYgKHRDYWxjID4gMSkge1xuICAgICAgICB0Q2FsYyAtPSAxO1xuICAgIH1cbiAgICBpZiAodENhbGMgPCAxIC8gNikge1xuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdENhbGM7XG4gICAgfVxuICAgIGlmICh0Q2FsYyA8IDEgLyAyKSB7XG4gICAgICAgIHJldHVybiBxO1xuICAgIH1cbiAgICBpZiAodENhbGMgPCAyIC8gMykge1xuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0Q2FsYykgKiA2O1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvUmdiYShpbnB1dCkge1xuICAgIGlmIChpbnB1dC5zdGFydHNXaXRoKFwicmdiXCIpKSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gL3JnYmE/XFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyooLFxccyooW1xcZC5dKylcXHMqKT9cXCkvaTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVnZXguZXhlYyhpbnB1dCk7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGE6IHJlc3VsdC5sZW5ndGggPiA0ID8gcGFyc2VGbG9hdChyZXN1bHRbNV0pIDogMSxcbiAgICAgICAgICAgICAgICBiOiBwYXJzZUludChyZXN1bHRbM10sIDEwKSxcbiAgICAgICAgICAgICAgICBnOiBwYXJzZUludChyZXN1bHRbMl0sIDEwKSxcbiAgICAgICAgICAgICAgICByOiBwYXJzZUludChyZXN1bHRbMV0sIDEwKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbnB1dC5zdGFydHNXaXRoKFwiaHNsXCIpKSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gL2hzbGE/XFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKSVcXHMqLFxccyooXFxkKyklXFxzKigsXFxzKihbXFxkLl0rKVxccyopP1xcKS9pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWdleC5leGVjKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgPyBDb2xvclV0aWxzLmhzbGFUb1JnYmEoe1xuICAgICAgICAgICAgICAgIGE6IHJlc3VsdC5sZW5ndGggPiA0ID8gcGFyc2VGbG9hdChyZXN1bHRbNV0pIDogMSxcbiAgICAgICAgICAgICAgICBoOiBwYXJzZUludChyZXN1bHRbMV0sIDEwKSxcbiAgICAgICAgICAgICAgICBsOiBwYXJzZUludChyZXN1bHRbM10sIDEwKSxcbiAgICAgICAgICAgICAgICBzOiBwYXJzZUludChyZXN1bHRbMl0sIDEwKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQuc3RhcnRzV2l0aChcImhzdlwiKSkge1xuICAgICAgICBjb25zdCByZWdleCA9IC9oc3ZhP1xcKFxccyooXFxkKynCsFxccyosXFxzKihcXGQrKSVcXHMqLFxccyooXFxkKyklXFxzKigsXFxzKihbXFxkLl0rKVxccyopP1xcKS9pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWdleC5leGVjKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgPyBDb2xvclV0aWxzLmhzdmFUb1JnYmEoe1xuICAgICAgICAgICAgICAgIGE6IHJlc3VsdC5sZW5ndGggPiA0ID8gcGFyc2VGbG9hdChyZXN1bHRbNV0pIDogMSxcbiAgICAgICAgICAgICAgICBoOiBwYXJzZUludChyZXN1bHRbMV0sIDEwKSxcbiAgICAgICAgICAgICAgICBzOiBwYXJzZUludChyZXN1bHRbMl0sIDEwKSxcbiAgICAgICAgICAgICAgICB2OiBwYXJzZUludChyZXN1bHRbM10sIDEwKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHNob3J0aGFuZFJlZ2V4ID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSk/JC9pO1xuICAgICAgICBjb25zdCBoZXhGaXhlZCA9IGlucHV0LnJlcGxhY2Uoc2hvcnRoYW5kUmVnZXgsIChfbSwgciwgZywgYiwgYSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHIgKyByICsgZyArIGcgKyBiICsgYiArIChhICE9PSB1bmRlZmluZWQgPyBhICsgYSA6IFwiXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVnZXggPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KT8kL2k7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZ2V4LmV4ZWMoaGV4Rml4ZWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBhOiByZXN1bHRbNF0gIT09IHVuZGVmaW5lZCA/IHBhcnNlSW50KHJlc3VsdFs0XSwgMTYpIC8gMHhmZiA6IDEsXG4gICAgICAgICAgICAgICAgYjogcGFyc2VJbnQocmVzdWx0WzNdLCAxNiksXG4gICAgICAgICAgICAgICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxNiksXG4gICAgICAgICAgICAgICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG5jbGFzcyBDb2xvclV0aWxzIHtcbiAgICBzdGF0aWMgY29sb3JUb1JnYihpbnB1dCwgaW5kZXgsIHVzZUluZGV4ID0gdHJ1ZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xvciA9IHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiA/IHsgdmFsdWU6IGlucHV0IH0gOiBpbnB1dDtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvci52YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGNvbG9yLnZhbHVlID09PSBDb25zdGFudHNfMS5Db25zdGFudHMucmFuZG9tQ29sb3JWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IENvbG9yVXRpbHMuZ2V0UmFuZG9tUmdiQ29sb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IENvbG9yVXRpbHMuc3RyaW5nVG9SZ2IoY29sb3IudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbG9yLnZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvclNlbGVjdGVkID0gVXRpbHNfMS5VdGlscy5pdGVtRnJvbUFycmF5KGNvbG9yLnZhbHVlLCBpbmRleCwgdXNlSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJlcyA9IENvbG9yVXRpbHMuY29sb3JUb1JnYih7IHZhbHVlOiBjb2xvclNlbGVjdGVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IGNvbG9yLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJnYkNvbG9yID0gKF9hID0gY29sb3JWYWx1ZS5yZ2IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbG9yLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChyZ2JDb2xvci5yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmdiQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoc2xDb2xvciA9IChfYiA9IGNvbG9yVmFsdWUuaHNsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb2xvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhzbENvbG9yLmggIT09IHVuZGVmaW5lZCAmJiBoc2xDb2xvci5sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IENvbG9yVXRpbHMuaHNsVG9SZ2IoaHNsQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaHN2Q29sb3IgPSAoX2MgPSBjb2xvclZhbHVlLmhzdikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY29sb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHN2Q29sb3IuaCAhPT0gdW5kZWZpbmVkICYmIGhzdkNvbG9yLnYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IENvbG9yVXRpbHMuaHN2VG9SZ2IoaHN2Q29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBjb2xvclRvSHNsKGNvbG9yLCBpbmRleCwgdXNlSW5kZXggPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHJnYiA9IENvbG9yVXRpbHMuY29sb3JUb1JnYihjb2xvciwgaW5kZXgsIHVzZUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHJnYiAhPT0gdW5kZWZpbmVkID8gQ29sb3JVdGlscy5yZ2JUb0hzbChyZ2IpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzdGF0aWMgcmdiVG9Ic2woY29sb3IpIHtcbiAgICAgICAgY29uc3QgcjEgPSBjb2xvci5yIC8gMjU1O1xuICAgICAgICBjb25zdCBnMSA9IGNvbG9yLmcgLyAyNTU7XG4gICAgICAgIGNvbnN0IGIxID0gY29sb3IuYiAvIDI1NTtcbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgocjEsIGcxLCBiMSk7XG4gICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHIxLCBnMSwgYjEpO1xuICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICBoOiAwLFxuICAgICAgICAgICAgbDogKG1heCArIG1pbikgLyAyLFxuICAgICAgICAgICAgczogMCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1heCAhPSBtaW4pIHtcbiAgICAgICAgICAgIHJlcy5zID0gcmVzLmwgPCAwLjUgPyAobWF4IC0gbWluKSAvIChtYXggKyBtaW4pIDogKG1heCAtIG1pbikgLyAoMi4wIC0gbWF4IC0gbWluKTtcbiAgICAgICAgICAgIHJlcy5oID1cbiAgICAgICAgICAgICAgICByMSA9PT0gbWF4XG4gICAgICAgICAgICAgICAgICAgID8gKGcxIC0gYjEpIC8gKG1heCAtIG1pbilcbiAgICAgICAgICAgICAgICAgICAgOiAocmVzLmggPSBnMSA9PT0gbWF4ID8gMi4wICsgKGIxIC0gcjEpIC8gKG1heCAtIG1pbikgOiA0LjAgKyAocjEgLSBnMSkgLyAobWF4IC0gbWluKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLmwgKj0gMTAwO1xuICAgICAgICByZXMucyAqPSAxMDA7XG4gICAgICAgIHJlcy5oICo9IDYwO1xuICAgICAgICBpZiAocmVzLmggPCAwKSB7XG4gICAgICAgICAgICByZXMuaCArPSAzNjA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIHN0cmluZ1RvQWxwaGEoaW5wdXQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gc3RyaW5nVG9SZ2JhKGlucHV0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmE7XG4gICAgfVxuICAgIHN0YXRpYyBzdHJpbmdUb1JnYihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9SZ2JhKGlucHV0KTtcbiAgICB9XG4gICAgc3RhdGljIGhzbFRvUmdiKGhzbCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGI6IDAsIGc6IDAsIHI6IDAgfTtcbiAgICAgICAgY29uc3QgaHNsUGVyY2VudCA9IHtcbiAgICAgICAgICAgIGg6IGhzbC5oIC8gMzYwLFxuICAgICAgICAgICAgbDogaHNsLmwgLyAxMDAsXG4gICAgICAgICAgICBzOiBoc2wucyAvIDEwMCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhzbFBlcmNlbnQucyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LmIgPSBoc2xQZXJjZW50Lmw7XG4gICAgICAgICAgICByZXN1bHQuZyA9IGhzbFBlcmNlbnQubDtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaHNsUGVyY2VudC5sO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcSA9IGhzbFBlcmNlbnQubCA8IDAuNVxuICAgICAgICAgICAgICAgID8gaHNsUGVyY2VudC5sICogKDEgKyBoc2xQZXJjZW50LnMpXG4gICAgICAgICAgICAgICAgOiBoc2xQZXJjZW50LmwgKyBoc2xQZXJjZW50LnMgLSBoc2xQZXJjZW50LmwgKiBoc2xQZXJjZW50LnM7XG4gICAgICAgICAgICBjb25zdCBwID0gMiAqIGhzbFBlcmNlbnQubCAtIHE7XG4gICAgICAgICAgICByZXN1bHQuciA9IGh1ZTJyZ2IocCwgcSwgaHNsUGVyY2VudC5oICsgMSAvIDMpO1xuICAgICAgICAgICAgcmVzdWx0LmcgPSBodWUycmdiKHAsIHEsIGhzbFBlcmNlbnQuaCk7XG4gICAgICAgICAgICByZXN1bHQuYiA9IGh1ZTJyZ2IocCwgcSwgaHNsUGVyY2VudC5oIC0gMSAvIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5yID0gTWF0aC5mbG9vcihyZXN1bHQuciAqIDI1NSk7XG4gICAgICAgIHJlc3VsdC5nID0gTWF0aC5mbG9vcihyZXN1bHQuZyAqIDI1NSk7XG4gICAgICAgIHJlc3VsdC5iID0gTWF0aC5mbG9vcihyZXN1bHQuYiAqIDI1NSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBoc2xhVG9SZ2JhKGhzbGEpIHtcbiAgICAgICAgY29uc3QgcmdiUmVzdWx0ID0gQ29sb3JVdGlscy5oc2xUb1JnYihoc2xhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IGhzbGEuYSxcbiAgICAgICAgICAgIGI6IHJnYlJlc3VsdC5iLFxuICAgICAgICAgICAgZzogcmdiUmVzdWx0LmcsXG4gICAgICAgICAgICByOiByZ2JSZXN1bHQucixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGhzbFRvSHN2KGhzbCkge1xuICAgICAgICBjb25zdCBsID0gaHNsLmwgLyAxMDAsIHNsID0gaHNsLnMgLyAxMDA7XG4gICAgICAgIGNvbnN0IHYgPSBsICsgc2wgKiBNYXRoLm1pbihsLCAxIC0gbCksIHN2ID0gIXYgPyAwIDogMiAqICgxIC0gbCAvIHYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaDogaHNsLmgsXG4gICAgICAgICAgICBzOiBzdiAqIDEwMCxcbiAgICAgICAgICAgIHY6IHYgKiAxMDAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBoc2xhVG9Ic3ZhKGhzbGEpIHtcbiAgICAgICAgY29uc3QgaHN2UmVzdWx0ID0gQ29sb3JVdGlscy5oc2xUb0hzdihoc2xhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IGhzbGEuYSxcbiAgICAgICAgICAgIGg6IGhzdlJlc3VsdC5oLFxuICAgICAgICAgICAgczogaHN2UmVzdWx0LnMsXG4gICAgICAgICAgICB2OiBoc3ZSZXN1bHQudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGhzdlRvSHNsKGhzdikge1xuICAgICAgICBjb25zdCB2ID0gaHN2LnYgLyAxMDAsIHN2ID0gaHN2LnMgLyAxMDA7XG4gICAgICAgIGNvbnN0IGwgPSB2ICogKDEgLSBzdiAvIDIpLCBzbCA9IGwgPT09IDAgfHwgbCA9PT0gMSA/IDAgOiAodiAtIGwpIC8gTWF0aC5taW4obCwgMSAtIGwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaDogaHN2LmgsXG4gICAgICAgICAgICBsOiBsICogMTAwLFxuICAgICAgICAgICAgczogc2wgKiAxMDAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBoc3ZhVG9Ic2xhKGhzdmEpIHtcbiAgICAgICAgY29uc3QgaHNsUmVzdWx0ID0gQ29sb3JVdGlscy5oc3ZUb0hzbChoc3ZhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IGhzdmEuYSxcbiAgICAgICAgICAgIGg6IGhzbFJlc3VsdC5oLFxuICAgICAgICAgICAgbDogaHNsUmVzdWx0LmwsXG4gICAgICAgICAgICBzOiBoc2xSZXN1bHQucyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGhzdlRvUmdiKGhzdikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGI6IDAsIGc6IDAsIHI6IDAgfTtcbiAgICAgICAgY29uc3QgaHN2UGVyY2VudCA9IHtcbiAgICAgICAgICAgIGg6IGhzdi5oIC8gNjAsXG4gICAgICAgICAgICBzOiBoc3YucyAvIDEwMCxcbiAgICAgICAgICAgIHY6IGhzdi52IC8gMTAwLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjID0gaHN2UGVyY2VudC52ICogaHN2UGVyY2VudC5zLCB4ID0gYyAqICgxIC0gTWF0aC5hYnMoKGhzdlBlcmNlbnQuaCAlIDIpIC0gMSkpO1xuICAgICAgICBsZXQgdGVtcFJnYjtcbiAgICAgICAgaWYgKGhzdlBlcmNlbnQuaCA+PSAwICYmIGhzdlBlcmNlbnQuaCA8PSAxKSB7XG4gICAgICAgICAgICB0ZW1wUmdiID0ge1xuICAgICAgICAgICAgICAgIHI6IGMsXG4gICAgICAgICAgICAgICAgZzogeCxcbiAgICAgICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoc3ZQZXJjZW50LmggPiAxICYmIGhzdlBlcmNlbnQuaCA8PSAyKSB7XG4gICAgICAgICAgICB0ZW1wUmdiID0ge1xuICAgICAgICAgICAgICAgIHI6IHgsXG4gICAgICAgICAgICAgICAgZzogYyxcbiAgICAgICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoc3ZQZXJjZW50LmggPiAyICYmIGhzdlBlcmNlbnQuaCA8PSAzKSB7XG4gICAgICAgICAgICB0ZW1wUmdiID0ge1xuICAgICAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICAgICAgZzogYyxcbiAgICAgICAgICAgICAgICBiOiB4LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoc3ZQZXJjZW50LmggPiAzICYmIGhzdlBlcmNlbnQuaCA8PSA0KSB7XG4gICAgICAgICAgICB0ZW1wUmdiID0ge1xuICAgICAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICAgICAgZzogeCxcbiAgICAgICAgICAgICAgICBiOiBjLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoc3ZQZXJjZW50LmggPiA0ICYmIGhzdlBlcmNlbnQuaCA8PSA1KSB7XG4gICAgICAgICAgICB0ZW1wUmdiID0ge1xuICAgICAgICAgICAgICAgIHI6IHgsXG4gICAgICAgICAgICAgICAgZzogMCxcbiAgICAgICAgICAgICAgICBiOiBjLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoc3ZQZXJjZW50LmggPiA1ICYmIGhzdlBlcmNlbnQuaCA8PSA2KSB7XG4gICAgICAgICAgICB0ZW1wUmdiID0ge1xuICAgICAgICAgICAgICAgIHI6IGMsXG4gICAgICAgICAgICAgICAgZzogMCxcbiAgICAgICAgICAgICAgICBiOiB4LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVtcFJnYikge1xuICAgICAgICAgICAgY29uc3QgbSA9IGhzdlBlcmNlbnQudiAtIGM7XG4gICAgICAgICAgICByZXN1bHQuciA9IE1hdGguZmxvb3IoKHRlbXBSZ2IuciArIG0pICogMjU1KTtcbiAgICAgICAgICAgIHJlc3VsdC5nID0gTWF0aC5mbG9vcigodGVtcFJnYi5nICsgbSkgKiAyNTUpO1xuICAgICAgICAgICAgcmVzdWx0LmIgPSBNYXRoLmZsb29yKCh0ZW1wUmdiLmIgKyBtKSAqIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGhzdmFUb1JnYmEoaHN2YSkge1xuICAgICAgICBjb25zdCByZ2JSZXN1bHQgPSBDb2xvclV0aWxzLmhzdlRvUmdiKGhzdmEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYTogaHN2YS5hLFxuICAgICAgICAgICAgYjogcmdiUmVzdWx0LmIsXG4gICAgICAgICAgICBnOiByZ2JSZXN1bHQuZyxcbiAgICAgICAgICAgIHI6IHJnYlJlc3VsdC5yLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgcmdiVG9Ic3YocmdiKSB7XG4gICAgICAgIGNvbnN0IHJnYlBlcmNlbnQgPSB7XG4gICAgICAgICAgICByOiByZ2IuciAvIDI1NSxcbiAgICAgICAgICAgIGc6IHJnYi5nIC8gMjU1LFxuICAgICAgICAgICAgYjogcmdiLmIgLyAyNTUsXG4gICAgICAgIH0sIHhNYXggPSBNYXRoLm1heChyZ2JQZXJjZW50LnIsIHJnYlBlcmNlbnQuZywgcmdiUGVyY2VudC5iKSwgeE1pbiA9IE1hdGgubWluKHJnYlBlcmNlbnQuciwgcmdiUGVyY2VudC5nLCByZ2JQZXJjZW50LmIpLCB2ID0geE1heCwgYyA9IHhNYXggLSB4TWluO1xuICAgICAgICBsZXQgaCA9IDA7XG4gICAgICAgIGlmICh2ID09PSByZ2JQZXJjZW50LnIpIHtcbiAgICAgICAgICAgIGggPSA2MCAqICgocmdiUGVyY2VudC5nIC0gcmdiUGVyY2VudC5iKSAvIGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPT09IHJnYlBlcmNlbnQuZykge1xuICAgICAgICAgICAgaCA9IDYwICogKDIgKyAocmdiUGVyY2VudC5iIC0gcmdiUGVyY2VudC5yKSAvIGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPT09IHJnYlBlcmNlbnQuYikge1xuICAgICAgICAgICAgaCA9IDYwICogKDQgKyAocmdiUGVyY2VudC5yIC0gcmdiUGVyY2VudC5nKSAvIGMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHMgPSAhdiA/IDAgOiBjIC8gdjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICBzOiBzICogMTAwLFxuICAgICAgICAgICAgdjogdiAqIDEwMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHJnYmFUb0hzdmEocmdiYSkge1xuICAgICAgICBjb25zdCBoc3ZSZXN1bHQgPSBDb2xvclV0aWxzLnJnYlRvSHN2KHJnYmEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYTogcmdiYS5hLFxuICAgICAgICAgICAgaDogaHN2UmVzdWx0LmgsXG4gICAgICAgICAgICBzOiBoc3ZSZXN1bHQucyxcbiAgICAgICAgICAgIHY6IGhzdlJlc3VsdC52LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UmFuZG9tUmdiQ29sb3IobWluKSB7XG4gICAgICAgIGNvbnN0IGZpeGVkTWluID0gbWluICE9PSBudWxsICYmIG1pbiAhPT0gdm9pZCAwID8gbWluIDogMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGI6IE1hdGguZmxvb3IoTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5yYW5kb21JblJhbmdlKGZpeGVkTWluLCAyNTYpKSxcbiAgICAgICAgICAgIGc6IE1hdGguZmxvb3IoTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5yYW5kb21JblJhbmdlKGZpeGVkTWluLCAyNTYpKSxcbiAgICAgICAgICAgIHI6IE1hdGguZmxvb3IoTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5yYW5kb21JblJhbmdlKGZpeGVkTWluLCAyNTYpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGdldFN0eWxlRnJvbVJnYihjb2xvciwgb3BhY2l0eSkge1xuICAgICAgICByZXR1cm4gYHJnYmEoJHtjb2xvci5yfSwgJHtjb2xvci5nfSwgJHtjb2xvci5ifSwgJHtvcGFjaXR5ICE9PSBudWxsICYmIG9wYWNpdHkgIT09IHZvaWQgMCA/IG9wYWNpdHkgOiAxfSlgO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0U3R5bGVGcm9tSHNsKGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgICAgIHJldHVybiBgaHNsYSgke2NvbG9yLmh9LCAke2NvbG9yLnN9JSwgJHtjb2xvci5sfSUsICR7b3BhY2l0eSAhPT0gbnVsbCAmJiBvcGFjaXR5ICE9PSB2b2lkIDAgPyBvcGFjaXR5IDogMX0pYDtcbiAgICB9XG4gICAgc3RhdGljIGdldFN0eWxlRnJvbUhzdihjb2xvciwgb3BhY2l0eSkge1xuICAgICAgICByZXR1cm4gQ29sb3JVdGlscy5nZXRTdHlsZUZyb21Ic2woQ29sb3JVdGlscy5oc3ZUb0hzbChjb2xvciksIG9wYWNpdHkpO1xuICAgIH1cbiAgICBzdGF0aWMgbWl4KGNvbG9yMSwgY29sb3IyLCBzaXplMSwgc2l6ZTIpIHtcbiAgICAgICAgbGV0IHJnYjEgPSBjb2xvcjE7XG4gICAgICAgIGxldCByZ2IyID0gY29sb3IyO1xuICAgICAgICBpZiAocmdiMS5yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJnYjEgPSBDb2xvclV0aWxzLmhzbFRvUmdiKGNvbG9yMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJnYjIuciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZ2IyID0gQ29sb3JVdGlscy5oc2xUb1JnYihjb2xvcjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiOiBOdW1iZXJVdGlsc18xLk51bWJlclV0aWxzLm1peChyZ2IxLmIsIHJnYjIuYiwgc2l6ZTEsIHNpemUyKSxcbiAgICAgICAgICAgIGc6IE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMubWl4KHJnYjEuZywgcmdiMi5nLCBzaXplMSwgc2l6ZTIpLFxuICAgICAgICAgICAgcjogTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5taXgocmdiMS5yLCByZ2IyLnIsIHNpemUxLCBzaXplMiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyByZXBsYWNlQ29sb3JTdmcoaW1hZ2UsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgICAgIGlmICghaW1hZ2Uuc3ZnRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ZnWG1sID0gaW1hZ2Uuc3ZnRGF0YTtcbiAgICAgICAgY29uc3QgcmdiSGV4ID0gLyMoWzAtOUEtRl17Myw2fSkvZ2k7XG4gICAgICAgIHJldHVybiBzdmdYbWwucmVwbGFjZShyZ2JIZXgsICgpID0+IENvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tSHNsKGNvbG9yLCBvcGFjaXR5KSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRMaW5rQ29sb3IocDEsIHAyLCBsaW5rQ29sb3IpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGxpbmtDb2xvciA9PT0gQ29uc3RhbnRzXzEuQ29uc3RhbnRzLnJhbmRvbUNvbG9yVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBDb2xvclV0aWxzLmdldFJhbmRvbVJnYkNvbG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGlua0NvbG9yID09PSBcIm1pZFwiKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VDb2xvciA9IChfYSA9IHAxLmdldEZpbGxDb2xvcigpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwMS5nZXRTdHJva2VDb2xvcigpO1xuICAgICAgICAgICAgY29uc3QgZGVzdENvbG9yID0gKF9iID0gcDIgPT09IG51bGwgfHwgcDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHAyLmdldEZpbGxDb2xvcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBwMiA9PT0gbnVsbCB8fCBwMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcDIuZ2V0U3Ryb2tlQ29sb3IoKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VDb2xvciAmJiBkZXN0Q29sb3IgJiYgcDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sb3JVdGlscy5taXgoc291cmNlQ29sb3IsIGRlc3RDb2xvciwgcDEuZ2V0UmFkaXVzKCksIHAyLmdldFJhZGl1cygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhzbENvbG9yID0gc291cmNlQ29sb3IgIT09IG51bGwgJiYgc291cmNlQ29sb3IgIT09IHZvaWQgMCA/IHNvdXJjZUNvbG9yIDogZGVzdENvbG9yO1xuICAgICAgICAgICAgICAgIGlmIChoc2xDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29sb3JVdGlscy5oc2xUb1JnYihoc2xDb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmtDb2xvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0TGlua1JhbmRvbUNvbG9yKG9wdENvbG9yLCBibGluaywgY29uc2VudCkge1xuICAgICAgICBjb25zdCBjb2xvciA9IHR5cGVvZiBvcHRDb2xvciA9PT0gXCJzdHJpbmdcIiA/IG9wdENvbG9yIDogb3B0Q29sb3IudmFsdWU7XG4gICAgICAgIGlmIChjb2xvciA9PT0gQ29uc3RhbnRzXzEuQ29uc3RhbnRzLnJhbmRvbUNvbG9yVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjb25zZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbG9yVXRpbHMuY29sb3JUb1JnYih7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJsaW5rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50c18xLkNvbnN0YW50cy5yYW5kb21Db2xvclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50c18xLkNvbnN0YW50cy5taWRDb2xvclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIENvbG9yVXRpbHMuY29sb3JUb1JnYih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGNvbG9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNvbG9yVXRpbHMgPSBDb2xvclV0aWxzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnN0YW50cyA9IHZvaWQgMDtcbmNsYXNzIENvbnN0YW50cyB7XG59XG5leHBvcnRzLkNvbnN0YW50cyA9IENvbnN0YW50cztcbkNvbnN0YW50cy5jYW52YXNDbGFzcyA9IFwidHNwYXJ0aWNsZXMtY2FudmFzLWVsXCI7XG5Db25zdGFudHMucmFuZG9tQ29sb3JWYWx1ZSA9IFwicmFuZG9tXCI7XG5Db25zdGFudHMubWlkQ29sb3JWYWx1ZSA9IFwibWlkXCI7XG5Db25zdGFudHMudG91Y2hFbmRFdmVudCA9IFwidG91Y2hlbmRcIjtcbkNvbnN0YW50cy5tb3VzZURvd25FdmVudCA9IFwibW91c2Vkb3duXCI7XG5Db25zdGFudHMubW91c2VVcEV2ZW50ID0gXCJtb3VzZXVwXCI7XG5Db25zdGFudHMubW91c2VNb3ZlRXZlbnQgPSBcIm1vdXNlbW92ZVwiO1xuQ29uc3RhbnRzLnRvdWNoU3RhcnRFdmVudCA9IFwidG91Y2hzdGFydFwiO1xuQ29uc3RhbnRzLnRvdWNoTW92ZUV2ZW50ID0gXCJ0b3VjaG1vdmVcIjtcbkNvbnN0YW50cy5tb3VzZUxlYXZlRXZlbnQgPSBcIm1vdXNlbGVhdmVcIjtcbkNvbnN0YW50cy5tb3VzZU91dEV2ZW50ID0gXCJtb3VzZW91dFwiO1xuQ29uc3RhbnRzLnRvdWNoQ2FuY2VsRXZlbnQgPSBcInRvdWNoY2FuY2VsXCI7XG5Db25zdGFudHMucmVzaXplRXZlbnQgPSBcInJlc2l6ZVwiO1xuQ29uc3RhbnRzLnZpc2liaWxpdHlDaGFuZ2VFdmVudCA9IFwidmlzaWJpbGl0eWNoYW5nZVwiO1xuQ29uc3RhbnRzLm5vUG9seWdvbkRhdGFMb2FkZWQgPSBcIk5vIHBvbHlnb24gZGF0YSBsb2FkZWQuXCI7XG5Db25zdGFudHMubm9Qb2x5Z29uRm91bmQgPSBcIk5vIHBvbHlnb24gZm91bmQsIHlvdSBuZWVkIHRvIHNwZWNpZnkgU1ZHIHVybCBpbiBjb25maWcuXCI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXZlbnRMaXN0ZW5lcnMgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uL0VudW1zXCIpO1xuY29uc3QgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9Db25zdGFudHNcIik7XG5mdW5jdGlvbiBtYW5hZ2VMaXN0ZW5lcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgYWRkLCBvcHRpb25zKSB7XG4gICAgaWYgKGFkZCkge1xuICAgICAgICBsZXQgYWRkT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBhZGRPcHRpb25zLmNhcHR1cmUgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWRkT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBhZGRPcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHJlbW92ZU9wdGlvbnMpO1xuICAgIH1cbn1cbmNsYXNzIEV2ZW50TGlzdGVuZXJzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IHRydWU7XG4gICAgICAgIHRoaXMubW91c2VNb3ZlSGFuZGxlciA9IChlKSA9PiB0aGlzLm1vdXNlVG91Y2hNb3ZlKGUpO1xuICAgICAgICB0aGlzLnRvdWNoU3RhcnRIYW5kbGVyID0gKGUpID0+IHRoaXMubW91c2VUb3VjaE1vdmUoZSk7XG4gICAgICAgIHRoaXMudG91Y2hNb3ZlSGFuZGxlciA9IChlKSA9PiB0aGlzLm1vdXNlVG91Y2hNb3ZlKGUpO1xuICAgICAgICB0aGlzLnRvdWNoRW5kSGFuZGxlciA9ICgpID0+IHRoaXMubW91c2VUb3VjaEZpbmlzaCgpO1xuICAgICAgICB0aGlzLm1vdXNlTGVhdmVIYW5kbGVyID0gKCkgPT4gdGhpcy5tb3VzZVRvdWNoRmluaXNoKCk7XG4gICAgICAgIHRoaXMudG91Y2hDYW5jZWxIYW5kbGVyID0gKCkgPT4gdGhpcy5tb3VzZVRvdWNoRmluaXNoKCk7XG4gICAgICAgIHRoaXMudG91Y2hFbmRDbGlja0hhbmRsZXIgPSAoZSkgPT4gdGhpcy5tb3VzZVRvdWNoQ2xpY2soZSk7XG4gICAgICAgIHRoaXMubW91c2VVcEhhbmRsZXIgPSAoZSkgPT4gdGhpcy5tb3VzZVRvdWNoQ2xpY2soZSk7XG4gICAgICAgIHRoaXMubW91c2VEb3duSGFuZGxlciA9ICgpID0+IHRoaXMubW91c2VEb3duKCk7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZUhhbmRsZXIgPSAoKSA9PiB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5yZXNpemVIYW5kbGVyID0gKCkgPT4gdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUoKTtcbiAgICB9XG4gICAgYWRkTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLm1hbmFnZUxpc3RlbmVycyh0cnVlKTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLm1hbmFnZUxpc3RlbmVycyhmYWxzZSk7XG4gICAgfVxuICAgIG1hbmFnZUxpc3RlbmVycyhhZGQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCBkZXRlY3RUeXBlID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5LmRldGVjdHNPbjtcbiAgICAgICAgbGV0IG1vdXNlTGVhdmVFdmVudCA9IENvbnN0YW50c18xLkNvbnN0YW50cy5tb3VzZUxlYXZlRXZlbnQ7XG4gICAgICAgIGlmIChkZXRlY3RUeXBlID09PSBFbnVtc18xLkludGVyYWN0aXZpdHlEZXRlY3Qud2luZG93KSB7XG4gICAgICAgICAgICBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5lbGVtZW50ID0gd2luZG93O1xuICAgICAgICAgICAgbW91c2VMZWF2ZUV2ZW50ID0gQ29uc3RhbnRzXzEuQ29uc3RhbnRzLm1vdXNlT3V0RXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGV0ZWN0VHlwZSA9PT0gRW51bXNfMS5JbnRlcmFjdGl2aXR5RGV0ZWN0LnBhcmVudCAmJiBjb250YWluZXIuY2FudmFzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc0VsID0gY29udGFpbmVyLmNhbnZhcy5lbGVtZW50O1xuICAgICAgICAgICAgY29udGFpbmVyLmludGVyYWN0aXZpdHkuZWxlbWVudCA9IChfYSA9IGNhbnZhc0VsLnBhcmVudEVsZW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNhbnZhc0VsLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5lbGVtZW50ID0gY29udGFpbmVyLmNhbnZhcy5lbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludGVyYWN0aXZpdHlFbCA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5LmVsZW1lbnQ7XG4gICAgICAgIGlmICghaW50ZXJhY3Rpdml0eUVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaHRtbCA9IGludGVyYWN0aXZpdHlFbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25Ib3Zlci5lbmFibGUgfHwgb3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cy5vbkNsaWNrLmVuYWJsZSkge1xuICAgICAgICAgICAgbWFuYWdlTGlzdGVuZXIoaW50ZXJhY3Rpdml0eUVsLCBDb25zdGFudHNfMS5Db25zdGFudHMubW91c2VNb3ZlRXZlbnQsIHRoaXMubW91c2VNb3ZlSGFuZGxlciwgYWRkKTtcbiAgICAgICAgICAgIG1hbmFnZUxpc3RlbmVyKGludGVyYWN0aXZpdHlFbCwgQ29uc3RhbnRzXzEuQ29uc3RhbnRzLnRvdWNoU3RhcnRFdmVudCwgdGhpcy50b3VjaFN0YXJ0SGFuZGxlciwgYWRkKTtcbiAgICAgICAgICAgIG1hbmFnZUxpc3RlbmVyKGludGVyYWN0aXZpdHlFbCwgQ29uc3RhbnRzXzEuQ29uc3RhbnRzLnRvdWNoTW92ZUV2ZW50LCB0aGlzLnRvdWNoTW92ZUhhbmRsZXIsIGFkZCk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25DbGljay5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VMaXN0ZW5lcihpbnRlcmFjdGl2aXR5RWwsIENvbnN0YW50c18xLkNvbnN0YW50cy50b3VjaEVuZEV2ZW50LCB0aGlzLnRvdWNoRW5kSGFuZGxlciwgYWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hbmFnZUxpc3RlbmVyKGludGVyYWN0aXZpdHlFbCwgQ29uc3RhbnRzXzEuQ29uc3RhbnRzLnRvdWNoRW5kRXZlbnQsIHRoaXMudG91Y2hFbmRDbGlja0hhbmRsZXIsIGFkZCk7XG4gICAgICAgICAgICAgICAgbWFuYWdlTGlzdGVuZXIoaW50ZXJhY3Rpdml0eUVsLCBDb25zdGFudHNfMS5Db25zdGFudHMubW91c2VVcEV2ZW50LCB0aGlzLm1vdXNlVXBIYW5kbGVyLCBhZGQpO1xuICAgICAgICAgICAgICAgIG1hbmFnZUxpc3RlbmVyKGludGVyYWN0aXZpdHlFbCwgQ29uc3RhbnRzXzEuQ29uc3RhbnRzLm1vdXNlRG93bkV2ZW50LCB0aGlzLm1vdXNlRG93bkhhbmRsZXIsIGFkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYW5hZ2VMaXN0ZW5lcihpbnRlcmFjdGl2aXR5RWwsIG1vdXNlTGVhdmVFdmVudCwgdGhpcy5tb3VzZUxlYXZlSGFuZGxlciwgYWRkKTtcbiAgICAgICAgICAgIG1hbmFnZUxpc3RlbmVyKGludGVyYWN0aXZpdHlFbCwgQ29uc3RhbnRzXzEuQ29uc3RhbnRzLnRvdWNoQ2FuY2VsRXZlbnQsIHRoaXMudG91Y2hDYW5jZWxIYW5kbGVyLCBhZGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWluZXIuY2FudmFzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jYW52YXMuZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gaHRtbCA9PT0gY29udGFpbmVyLmNhbnZhcy5lbGVtZW50ID8gXCJpbml0aWFsXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cy5yZXNpemUpIHtcbiAgICAgICAgICAgIG1hbmFnZUxpc3RlbmVyKHdpbmRvdywgQ29uc3RhbnRzXzEuQ29uc3RhbnRzLnJlc2l6ZUV2ZW50LCB0aGlzLnJlc2l6ZUhhbmRsZXIsIGFkZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICBtYW5hZ2VMaXN0ZW5lcihkb2N1bWVudCwgQ29uc3RhbnRzXzEuQ29uc3RhbnRzLnZpc2liaWxpdHlDaGFuZ2VFdmVudCwgdGhpcy52aXNpYmlsaXR5Q2hhbmdlSGFuZGxlciwgYWRkLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlV2luZG93UmVzaXplKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY29udGFpbmVyLmNhbnZhcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpbmRvd1Jlc2l6ZSgpO1xuICAgIH1cbiAgICBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICB0aGlzLm1vdXNlVG91Y2hGaW5pc2goKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnBhdXNlT25CbHVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50ID09PSBudWxsIHx8IGRvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5wYWdlSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyLnBhZ2VIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuZ2V0QW5pbWF0aW9uU3RhdHVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucGxheSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5kcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2VEb3duKCkge1xuICAgICAgICBjb25zdCBpbnRlcmFjdGl2aXR5ID0gdGhpcy5jb250YWluZXIuaW50ZXJhY3Rpdml0eTtcbiAgICAgICAgaWYgKGludGVyYWN0aXZpdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlID0gaW50ZXJhY3Rpdml0eS5tb3VzZTtcbiAgICAgICAgICAgIG1vdXNlLmNsaWNraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIG1vdXNlLmRvd25Qb3NpdGlvbiA9IG1vdXNlLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdXNlVG91Y2hNb3ZlKGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBpZiAoKChfYSA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZWxlbWVudCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlLmluc2lkZSA9IHRydWU7XG4gICAgICAgIGxldCBwb3M7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRhaW5lci5jYW52YXMuZWxlbWVudDtcbiAgICAgICAgaWYgKGUudHlwZS5zdGFydHNXaXRoKFwibW91c2VcIikpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuUHVzaCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBtb3VzZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuaW50ZXJhY3Rpdml0eS5lbGVtZW50ID09PSB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IG1vdXNlRXZlbnQuY2xpZW50WCAtIGNsaWVudFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG1vdXNlRXZlbnQuY2xpZW50WSAtIGNsaWVudFJlY3QudG9wLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5kZXRlY3RzT24gPT09IEVudW1zXzEuSW50ZXJhY3Rpdml0eURldGVjdC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBtb3VzZUV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBtb3VzZUV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzRWwgPSBjb250YWluZXIuY2FudmFzLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSAmJiB0YXJnZXQgJiYgY2FudmFzRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlUmVjdCA9IHNvdXJjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBtb3VzZUV2ZW50Lm9mZnNldFggKyAyICogc291cmNlUmVjdC5sZWZ0IC0gKHRhcmdldFJlY3QubGVmdCArIGNhbnZhc1JlY3QubGVmdCksXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBtb3VzZUV2ZW50Lm9mZnNldFkgKyAyICogc291cmNlUmVjdC50b3AgLSAodGFyZ2V0UmVjdC50b3AgKyBjYW52YXNSZWN0LnRvcCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAoX2IgPSBtb3VzZUV2ZW50Lm9mZnNldFgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG1vdXNlRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IChfYyA9IG1vdXNlRXZlbnQub2Zmc2V0WSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbW91c2VFdmVudC5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZUV2ZW50LnRhcmdldCA9PT0gY29udGFpbmVyLmNhbnZhcy5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IChfZCA9IG1vdXNlRXZlbnQub2Zmc2V0WCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbW91c2VFdmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogKF9lID0gbW91c2VFdmVudC5vZmZzZXRZKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBtb3VzZUV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYW5QdXNoID0gZS50eXBlICE9PSBcInRvdWNobW92ZVwiO1xuICAgICAgICAgICAgY29uc3QgdG91Y2hFdmVudCA9IGU7XG4gICAgICAgICAgICBjb25zdCBsYXN0VG91Y2ggPSB0b3VjaEV2ZW50LnRvdWNoZXNbdG91Y2hFdmVudC50b3VjaGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcyA9PT0gbnVsbCB8fCBjYW52YXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHBvcyA9IHtcbiAgICAgICAgICAgICAgICB4OiBsYXN0VG91Y2guY2xpZW50WCAtICgoX2YgPSBjYW52YXNSZWN0ID09PSBudWxsIHx8IGNhbnZhc1JlY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbnZhc1JlY3QubGVmdCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMCksXG4gICAgICAgICAgICAgICAgeTogbGFzdFRvdWNoLmNsaWVudFkgLSAoKF9nID0gY2FudmFzUmVjdCA9PT0gbnVsbCB8fCBjYW52YXNSZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYW52YXNSZWN0LnRvcCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogMCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB4UmF0aW8gPSBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgIHBvcy54ICo9IHB4UmF0aW87XG4gICAgICAgICAgICBwb3MueSAqPSBweFJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlLnBvc2l0aW9uID0gcG9zO1xuICAgICAgICBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5zdGF0dXMgPSBDb25zdGFudHNfMS5Db25zdGFudHMubW91c2VNb3ZlRXZlbnQ7XG4gICAgfVxuICAgIG1vdXNlVG91Y2hGaW5pc2goKSB7XG4gICAgICAgIGNvbnN0IGludGVyYWN0aXZpdHkgPSB0aGlzLmNvbnRhaW5lci5pbnRlcmFjdGl2aXR5O1xuICAgICAgICBpZiAoaW50ZXJhY3Rpdml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW91c2UgPSBpbnRlcmFjdGl2aXR5Lm1vdXNlO1xuICAgICAgICBkZWxldGUgbW91c2UucG9zaXRpb247XG4gICAgICAgIGRlbGV0ZSBtb3VzZS5jbGlja1Bvc2l0aW9uO1xuICAgICAgICBkZWxldGUgbW91c2UuZG93blBvc2l0aW9uO1xuICAgICAgICBpbnRlcmFjdGl2aXR5LnN0YXR1cyA9IENvbnN0YW50c18xLkNvbnN0YW50cy5tb3VzZUxlYXZlRXZlbnQ7XG4gICAgICAgIG1vdXNlLmluc2lkZSA9IGZhbHNlO1xuICAgICAgICBtb3VzZS5jbGlja2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICBtb3VzZVRvdWNoQ2xpY2soZSkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5vcHRpb25zO1xuICAgICAgICBjb25zdCBtb3VzZSA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlO1xuICAgICAgICBtb3VzZS5pbnNpZGUgPSB0cnVlO1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtb3VzZVBvc2l0aW9uID0gbW91c2UucG9zaXRpb247XG4gICAgICAgIGlmIChtb3VzZVBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgIW9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25DbGljay5lbmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgY29udGFpbmVyLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4uY2xpY2tQb3NpdGlvblZhbGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gcGx1Z2luLmNsaWNrUG9zaXRpb25WYWxpZChtb3VzZVBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYW5kbGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRvTW91c2VUb3VjaENsaWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIG1vdXNlLmNsaWNraW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGRvTW91c2VUb3VjaENsaWNrKGUpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIub3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuY2FuUHVzaCkge1xuICAgICAgICAgICAgY29uc3QgbW91c2VQb3MgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGlmIChtb3VzZVBvcykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlLmNsaWNrUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IG1vdXNlUG9zLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IG1vdXNlUG9zLnksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlLmNsaWNrVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgY29uc3Qgb25DbGljayA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25DbGljaztcbiAgICAgICAgICAgIGlmIChvbkNsaWNrLm1vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbW9kZSBvZiBvbkNsaWNrLm1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGlja01vZGUobW9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGlja01vZGUob25DbGljay5tb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50eXBlID09PSBcInRvdWNoZW5kXCIpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5tb3VzZVRvdWNoRmluaXNoKCksIDUwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQ2xpY2tNb2RlKG1vZGUpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIub3B0aW9ucztcbiAgICAgICAgY29uc3QgcHVzaE5iID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLnB1c2gucXVhbnRpdHk7XG4gICAgICAgIGNvbnN0IHJlbW92ZU5iID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLnJlbW92ZS5xdWFudGl0eTtcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEVudW1zXzEuQ2xpY2tNb2RlLnB1c2g6IHtcbiAgICAgICAgICAgICAgICBpZiAocHVzaE5iID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucGFydGljbGVzLnB1c2gocHVzaE5iLCBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFbnVtc18xLkNsaWNrTW9kZS5yZW1vdmU6XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcnRpY2xlcy5yZW1vdmVRdWFudGl0eShyZW1vdmVOYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVudW1zXzEuQ2xpY2tNb2RlLmJ1YmJsZTpcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYnViYmxlLmNsaWNraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRW51bXNfMS5DbGlja01vZGUucmVwdWxzZTpcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVwdWxzZS5jbGlja2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlcHVsc2UuY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydGljbGUgb2YgY29udGFpbmVyLnJlcHVsc2UucGFydGljbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5Lmhvcml6b250YWwgPSBwYXJ0aWNsZS5pbml0aWFsVmVsb2NpdHkuaG9yaXpvbnRhbDtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUudmVsb2NpdHkudmVydGljYWwgPSBwYXJ0aWNsZS5pbml0aWFsVmVsb2NpdHkudmVydGljYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZXB1bHNlLnBhcnRpY2xlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZXB1bHNlLmZpbmlzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZXB1bHNlLmNsaWNraW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMucmVwdWxzZS5kdXJhdGlvbiAqIDEwMDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFbnVtc18xLkNsaWNrTW9kZS5hdHRyYWN0OlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hdHRyYWN0LmNsaWNraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXR0cmFjdC5jb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0aWNsZSBvZiBjb250YWluZXIuYXR0cmFjdC5wYXJ0aWNsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUudmVsb2NpdHkuaG9yaXpvbnRhbCA9IHBhcnRpY2xlLmluaXRpYWxWZWxvY2l0eS5ob3Jpem9udGFsO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS52ZXJ0aWNhbCA9IHBhcnRpY2xlLmluaXRpYWxWZWxvY2l0eS52ZXJ0aWNhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmF0dHJhY3QucGFydGljbGVzID0gW107XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmF0dHJhY3QuZmluaXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVyLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmF0dHJhY3QuY2xpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5hdHRyYWN0LmR1cmF0aW9uICogMTAwMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVudW1zXzEuQ2xpY2tNb2RlLnBhdXNlOlxuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIuZ2V0QW5pbWF0aW9uU3RhdHVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucGxheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgY29udGFpbmVyLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4uaGFuZGxlQ2xpY2tNb2RlKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLmhhbmRsZUNsaWNrTW9kZShtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRXZlbnRMaXN0ZW5lcnMgPSBFdmVudExpc3RlbmVycztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OdW1iZXJVdGlscyA9IHZvaWQgMDtcbmNvbnN0IERpcmVjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9FbnVtcy9EaXJlY3Rpb25zXCIpO1xuY2xhc3MgTnVtYmVyVXRpbHMge1xuICAgIHN0YXRpYyBjbGFtcChudW0sIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChudW0sIG1pbiksIG1heCk7XG4gICAgfVxuICAgIHN0YXRpYyBtaXgoY29tcDEsIGNvbXAyLCB3ZWlnaHQxLCB3ZWlnaHQyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKChjb21wMSAqIHdlaWdodDEgKyBjb21wMiAqIHdlaWdodDIpIC8gKHdlaWdodDEgKyB3ZWlnaHQyKSk7XG4gICAgfVxuICAgIHN0YXRpYyByYW5kb21JblJhbmdlKHIxLCByMikge1xuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChyMSwgcjIpLCBtaW4gPSBNYXRoLm1pbihyMSwgcjIpO1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VmFsdWUob3B0aW9ucykge1xuICAgICAgICBjb25zdCByYW5kb20gPSBvcHRpb25zLnJhbmRvbTtcbiAgICAgICAgY29uc3QgeyBlbmFibGUsIG1pbmltdW1WYWx1ZSB9ID0gdHlwZW9mIHJhbmRvbSA9PT0gXCJib29sZWFuXCIgPyB7IGVuYWJsZTogcmFuZG9tLCBtaW5pbXVtVmFsdWU6IDAgfSA6IHJhbmRvbTtcbiAgICAgICAgcmV0dXJuIGVuYWJsZSA/IE51bWJlclV0aWxzLnJhbmRvbUluUmFuZ2UobWluaW11bVZhbHVlLCBvcHRpb25zLnZhbHVlKSA6IG9wdGlvbnMudmFsdWU7XG4gICAgfVxuICAgIHN0YXRpYyBnZXREaXN0YW5jZXMocG9pbnRBLCBwb2ludEIpIHtcbiAgICAgICAgY29uc3QgZHggPSBwb2ludEEueCAtIHBvaW50Qi54O1xuICAgICAgICBjb25zdCBkeSA9IHBvaW50QS55IC0gcG9pbnRCLnk7XG4gICAgICAgIHJldHVybiB7IGR4OiBkeCwgZHk6IGR5LCBkaXN0YW5jZTogTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGlzdGFuY2UocG9pbnRBLCBwb2ludEIpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlclV0aWxzLmdldERpc3RhbmNlcyhwb2ludEEsIHBvaW50QikuZGlzdGFuY2U7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRQYXJ0aWNsZUJhc2VWZWxvY2l0eShwYXJ0aWNsZSkge1xuICAgICAgICBsZXQgdmVsb2NpdHlCYXNlO1xuICAgICAgICBzd2l0Y2ggKHBhcnRpY2xlLmRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb25zXzEuTW92ZURpcmVjdGlvbi50b3A6XG4gICAgICAgICAgICAgICAgdmVsb2NpdHlCYXNlID0geyB4OiAwLCB5OiAtMSB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb25zXzEuTW92ZURpcmVjdGlvbi50b3BSaWdodDpcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eUJhc2UgPSB7IHg6IDAuNSwgeTogLTAuNSB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb25zXzEuTW92ZURpcmVjdGlvbi5yaWdodDpcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eUJhc2UgPSB7IHg6IDEsIHk6IC0wIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERpcmVjdGlvbnNfMS5Nb3ZlRGlyZWN0aW9uLmJvdHRvbVJpZ2h0OlxuICAgICAgICAgICAgICAgIHZlbG9jaXR5QmFzZSA9IHsgeDogMC41LCB5OiAwLjUgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGlyZWN0aW9uc18xLk1vdmVEaXJlY3Rpb24uYm90dG9tOlxuICAgICAgICAgICAgICAgIHZlbG9jaXR5QmFzZSA9IHsgeDogMCwgeTogMSB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb25zXzEuTW92ZURpcmVjdGlvbi5ib3R0b21MZWZ0OlxuICAgICAgICAgICAgICAgIHZlbG9jaXR5QmFzZSA9IHsgeDogLTAuNSwgeTogMSB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb25zXzEuTW92ZURpcmVjdGlvbi5sZWZ0OlxuICAgICAgICAgICAgICAgIHZlbG9jaXR5QmFzZSA9IHsgeDogLTEsIHk6IDAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGlyZWN0aW9uc18xLk1vdmVEaXJlY3Rpb24udG9wTGVmdDpcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eUJhc2UgPSB7IHg6IC0wLjUsIHk6IC0wLjUgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmVsb2NpdHlCYXNlID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlbG9jaXR5QmFzZTtcbiAgICB9XG4gICAgc3RhdGljIHJvdGF0ZVZlbG9jaXR5KHZlbG9jaXR5LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG9yaXpvbnRhbDogdmVsb2NpdHkuaG9yaXpvbnRhbCAqIE1hdGguY29zKGFuZ2xlKSAtIHZlbG9jaXR5LnZlcnRpY2FsICogTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgdmVydGljYWw6IHZlbG9jaXR5Lmhvcml6b250YWwgKiBNYXRoLnNpbihhbmdsZSkgKyB2ZWxvY2l0eS52ZXJ0aWNhbCAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGNvbGxpc2lvblZlbG9jaXR5KHYxLCB2MiwgbTEsIG0yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBob3Jpem9udGFsOiAodjEuaG9yaXpvbnRhbCAqIChtMSAtIG0yKSkgLyAobTEgKyBtMikgKyAodjIuaG9yaXpvbnRhbCAqIDIgKiBtMikgLyAobTEgKyBtMiksXG4gICAgICAgICAgICB2ZXJ0aWNhbDogdjEudmVydGljYWwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5OdW1iZXJVdGlscyA9IE51bWJlclV0aWxzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBsdWdpbnMgPSB2b2lkIDA7XG5jb25zdCBwbHVnaW5zID0gW107XG5jb25zdCBwcmVzZXRzID0gbmV3IE1hcCgpO1xuY29uc3QgZHJhd2VycyA9IG5ldyBNYXAoKTtcbmNsYXNzIFBsdWdpbnMge1xuICAgIHN0YXRpYyBnZXRQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW5zLmZpbmQoKHQpID0+IHQuaWQgPT09IHBsdWdpbik7XG4gICAgfVxuICAgIHN0YXRpYyBhZGRQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmICghUGx1Z2lucy5nZXRQbHVnaW4ocGx1Z2luLmlkKSkge1xuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldEF2YWlsYWJsZVBsdWdpbnMoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKCFwbHVnaW4ubmVlZHNQbHVnaW4oY29udGFpbmVyLm9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMuc2V0KHBsdWdpbi5pZCwgcGx1Z2luLmdldFBsdWdpbihjb250YWluZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBzdGF0aWMgbG9hZE9wdGlvbnMob3B0aW9ucywgc291cmNlT3B0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgICAgICBwbHVnaW4ubG9hZE9wdGlvbnMob3B0aW9ucywgc291cmNlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldFByZXNldChwcmVzZXQpIHtcbiAgICAgICAgcmV0dXJuIHByZXNldHMuZ2V0KHByZXNldCk7XG4gICAgfVxuICAgIHN0YXRpYyBhZGRQcmVzZXQocHJlc2V0S2V5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghUGx1Z2lucy5nZXRQcmVzZXQocHJlc2V0S2V5KSkge1xuICAgICAgICAgICAgcHJlc2V0cy5zZXQocHJlc2V0S2V5LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgYWRkU2hhcGVEcmF3ZXIodHlwZSwgZHJhd2VyKSB7XG4gICAgICAgIGlmICghUGx1Z2lucy5nZXRTaGFwZURyYXdlcih0eXBlKSkge1xuICAgICAgICAgICAgZHJhd2Vycy5zZXQodHlwZSwgZHJhd2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0U2hhcGVEcmF3ZXIodHlwZSkge1xuICAgICAgICByZXR1cm4gZHJhd2Vycy5nZXQodHlwZSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTdXBwb3J0ZWRTaGFwZXMoKSB7XG4gICAgICAgIHJldHVybiBkcmF3ZXJzLmtleXMoKTtcbiAgICB9XG59XG5leHBvcnRzLlBsdWdpbnMgPSBQbHVnaW5zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvaW50ID0gdm9pZCAwO1xuY2xhc3MgUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uLCBwYXJ0aWNsZSkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHRoaXMucGFydGljbGUgPSBwYXJ0aWNsZTtcbiAgICB9XG59XG5leHBvcnRzLlBvaW50ID0gUG9pbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXVhZFRyZWUgPSB2b2lkIDA7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcbmNvbnN0IENpcmNsZV8xID0gcmVxdWlyZShcIi4vQ2lyY2xlXCIpO1xuY29uc3QgQ2lyY2xlV2FycF8xID0gcmVxdWlyZShcIi4vQ2lyY2xlV2FycFwiKTtcbmNsYXNzIFF1YWRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihyZWN0YW5nbGUsIGNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMucmVjdGFuZ2xlID0gcmVjdGFuZ2xlO1xuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuZGl2aWRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBzdWJkaXZpZGUoKSB7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLnJlY3RhbmdsZS5wb3NpdGlvbi54O1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5yZWN0YW5nbGUucG9zaXRpb24ueTtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMucmVjdGFuZ2xlLnNpemUud2lkdGg7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLnJlY3RhbmdsZS5zaXplLmhlaWdodDtcbiAgICAgICAgY29uc3QgY2FwYWNpdHkgPSB0aGlzLmNhcGFjaXR5O1xuICAgICAgICB0aGlzLm5vcnRoRWFzdCA9IG5ldyBRdWFkVHJlZShuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKHgsIHksIHcgLyAyLCBoIC8gMiksIGNhcGFjaXR5KTtcbiAgICAgICAgdGhpcy5ub3J0aFdlc3QgPSBuZXcgUXVhZFRyZWUobmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSh4ICsgdyAvIDIsIHksIHcgLyAyLCBoIC8gMiksIGNhcGFjaXR5KTtcbiAgICAgICAgdGhpcy5zb3V0aEVhc3QgPSBuZXcgUXVhZFRyZWUobmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSh4LCB5ICsgaCAvIDIsIHcgLyAyLCBoIC8gMiksIGNhcGFjaXR5KTtcbiAgICAgICAgdGhpcy5zb3V0aFdlc3QgPSBuZXcgUXVhZFRyZWUobmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSh4ICsgdyAvIDIsIHkgKyBoIC8gMiwgdyAvIDIsIGggLyAyKSwgY2FwYWNpdHkpO1xuICAgICAgICB0aGlzLmRpdmlkZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpbnNlcnQocG9pbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgaWYgKCF0aGlzLnJlY3RhbmdsZS5jb250YWlucyhwb2ludC5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoIDwgdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICAgICAgdGhpcy5wb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZGl2aWRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdWJkaXZpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKChfZSA9ICgoKF9hID0gdGhpcy5ub3J0aEVhc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnNlcnQocG9pbnQpKSB8fCAoKF9iID0gdGhpcy5ub3J0aFdlc3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbnNlcnQocG9pbnQpKSB8fCAoKF9jID0gdGhpcy5zb3V0aEVhc3QpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pbnNlcnQocG9pbnQpKSB8fCAoKF9kID0gdGhpcy5zb3V0aFdlc3QpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5pbnNlcnQocG9pbnQpKSkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGZhbHNlKTtcbiAgICB9XG4gICAgcXVlcnlDaXJjbGUocG9zaXRpb24sIHJhZGl1cykge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeShuZXcgQ2lyY2xlXzEuQ2lyY2xlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHJhZGl1cykpO1xuICAgIH1cbiAgICBxdWVyeUNpcmNsZVdhcnAocG9zaXRpb24sIHJhZGl1cywgY29udGFpbmVyT3JTaXplKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lck9yU2l6ZTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGNvbnRhaW5lck9yU2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnkobmV3IENpcmNsZVdhcnBfMS5DaXJjbGVXYXJwKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHJhZGl1cywgY29udGFpbmVyLmNhbnZhcyAhPT0gdW5kZWZpbmVkID8gY29udGFpbmVyLmNhbnZhcy5zaXplIDogc2l6ZSkpO1xuICAgIH1cbiAgICBxdWVyeVJlY3RhbmdsZShwb3NpdGlvbiwgc2l6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeShuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KSk7XG4gICAgfVxuICAgIHF1ZXJ5KHJhbmdlLCBmb3VuZCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IHJlcyA9IGZvdW5kICE9PSBudWxsICYmIGZvdW5kICE9PSB2b2lkIDAgPyBmb3VuZCA6IFtdO1xuICAgICAgICBpZiAoIXJhbmdlLmludGVyc2VjdHModGhpcy5yZWN0YW5nbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wb2ludHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlLmNvbnRhaW5zKHAucG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMucHVzaChwLnBhcnRpY2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRpdmlkZWQpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLm5vcnRoRWFzdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnF1ZXJ5KHJhbmdlLCByZXMpO1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMubm9ydGhXZXN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucXVlcnkocmFuZ2UsIHJlcyk7XG4gICAgICAgICAgICAgICAgKF9jID0gdGhpcy5zb3V0aEVhc3QpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5xdWVyeShyYW5nZSwgcmVzKTtcbiAgICAgICAgICAgICAgICAoX2QgPSB0aGlzLnNvdXRoV2VzdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnF1ZXJ5KHJhbmdlLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuZXhwb3J0cy5RdWFkVHJlZSA9IFF1YWRUcmVlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJhbmdlID0gdm9pZCAwO1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWN0YW5nbGUgPSB2b2lkIDA7XG5jb25zdCBSYW5nZV8xID0gcmVxdWlyZShcIi4vUmFuZ2VcIik7XG5jbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBSYW5nZV8xLlJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKHgsIHkpO1xuICAgICAgICB0aGlzLnNpemUgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29udGFpbnMocG9pbnQpIHtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMuc2l6ZS53aWR0aDtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuc2l6ZS5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHJldHVybiBwb2ludC54ID49IHBvcy54ICYmIHBvaW50LnggPD0gcG9zLnggKyB3ICYmIHBvaW50LnkgPj0gcG9zLnkgJiYgcG9pbnQueSA8PSBwb3MueSArIGg7XG4gICAgfVxuICAgIGludGVyc2VjdHMocmFuZ2UpIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IHJhbmdlO1xuICAgICAgICBjb25zdCBjaXJjbGUgPSByYW5nZTtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMuc2l6ZS53aWR0aDtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuc2l6ZS5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHBvczEgPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCBwb3MyID0gcmFuZ2UucG9zaXRpb247XG4gICAgICAgIGlmIChjaXJjbGUucmFkaXVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaXJjbGUuaW50ZXJzZWN0cyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWN0LnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZTIgPSByZWN0LnNpemU7XG4gICAgICAgICAgICBjb25zdCB3MiA9IHNpemUyLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgaDIgPSBzaXplMi5oZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gcG9zMi54IDwgcG9zMS54ICsgdyAmJiBwb3MyLnggKyB3MiA+IHBvczEueCAmJiBwb3MyLnkgPCBwb3MxLnkgKyBoICYmIHBvczIueSArIGgyID4gcG9zMS55O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlV0aWxzID0gdm9pZCAwO1xuY29uc3QgT3V0TW9kZURpcmVjdGlvbl8xID0gcmVxdWlyZShcIi4uL0VudW1zL0RpcmVjdGlvbnMvT3V0TW9kZURpcmVjdGlvblwiKTtcbmNvbnN0IE51bWJlclV0aWxzXzEgPSByZXF1aXJlKFwiLi9OdW1iZXJVdGlsc1wiKTtcbmZ1bmN0aW9uIHJlY3RTaWRlQm91bmNlKHBTaWRlLCBwT3RoZXJTaWRlLCByZWN0U2lkZSwgcmVjdE90aGVyU2lkZSwgdmVsb2NpdHksIGZhY3Rvcikge1xuICAgIGNvbnN0IHJlcyA9IHsgYm91bmNlZDogZmFsc2UgfTtcbiAgICBpZiAocE90aGVyU2lkZS5taW4gPj0gcmVjdE90aGVyU2lkZS5taW4gJiZcbiAgICAgICAgcE90aGVyU2lkZS5taW4gPD0gcmVjdE90aGVyU2lkZS5tYXggJiZcbiAgICAgICAgcE90aGVyU2lkZS5tYXggPj0gcmVjdE90aGVyU2lkZS5taW4gJiZcbiAgICAgICAgcE90aGVyU2lkZS5tYXggPD0gcmVjdE90aGVyU2lkZS5tYXgpIHtcbiAgICAgICAgaWYgKChwU2lkZS5tYXggPj0gcmVjdFNpZGUubWluICYmIHBTaWRlLm1heCA8PSAocmVjdFNpZGUubWF4ICsgcmVjdFNpZGUubWluKSAvIDIgJiYgdmVsb2NpdHkgPiAwKSB8fFxuICAgICAgICAgICAgKHBTaWRlLm1pbiA8PSByZWN0U2lkZS5tYXggJiYgcFNpZGUubWluID4gKHJlY3RTaWRlLm1heCArIHJlY3RTaWRlLm1pbikgLyAyICYmIHZlbG9jaXR5IDwgMCkpIHtcbiAgICAgICAgICAgIHJlcy52ZWxvY2l0eSA9IHZlbG9jaXR5ICogLWZhY3RvcjtcbiAgICAgICAgICAgIHJlcy5ib3VuY2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY2hlY2tTZWxlY3RvcihlbGVtZW50LCBzZWxlY3RvcnMpIHtcbiAgICBpZiAoc2VsZWN0b3JzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBzZWxlY3RvcnMpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcnMpO1xuICAgIH1cbn1cbmNsYXNzIFV0aWxzIHtcbiAgICBzdGF0aWMgaXNTc3IoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICF3aW5kb3c7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgYW5pbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLmlzU3NyKClcbiAgICAgICAgICAgID8gKGNhbGxiYWNrKSA9PiBzZXRUaW1lb3V0KGNhbGxiYWNrKVxuICAgICAgICAgICAgOiAoY2FsbGJhY2spID0+ICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KShjYWxsYmFjayk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY2FuY2VsQW5pbWF0aW9uKCkge1xuICAgICAgICByZXR1cm4gVXRpbHMuaXNTc3IoKVxuICAgICAgICAgICAgPyAoaGFuZGxlKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKVxuICAgICAgICAgICAgOiAoaGFuZGxlKSA9PiAod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93LndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgIHdpbmRvdy5tb3pDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICB3aW5kb3cub0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgIHdpbmRvdy5tc0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQpKGhhbmRsZSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luQXJyYXkodmFsdWUsIGFycmF5KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gYXJyYXkgfHwgKGFycmF5IGluc3RhbmNlb2YgQXJyYXkgJiYgYXJyYXkuaW5kZXhPZih2YWx1ZSkgPiAtMSk7XG4gICAgfVxuICAgIHN0YXRpYyBsb2FkRm9udChjaGFyYWN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgZG9jdW1lbnQuZm9udHMubG9hZChgJHtjaGFyYWN0ZXIud2VpZ2h0fSAzNnB4ICcke2NoYXJhY3Rlci5mb250fSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGFycmF5UmFuZG9tSW5kZXgoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFycmF5Lmxlbmd0aCk7XG4gICAgfVxuICAgIHN0YXRpYyBpdGVtRnJvbUFycmF5KGFycmF5LCBpbmRleCwgdXNlSW5kZXggPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGZpeGVkSW5kZXggPSBpbmRleCAhPT0gdW5kZWZpbmVkICYmIHVzZUluZGV4ID8gaW5kZXggJSBhcnJheS5sZW5ndGggOiBVdGlscy5hcnJheVJhbmRvbUluZGV4KGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2ZpeGVkSW5kZXhdO1xuICAgIH1cbiAgICBzdGF0aWMgaXNQb2ludEluc2lkZShwb2ludCwgc2l6ZSwgcmFkaXVzLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLmFyZUJvdW5kc0luc2lkZShVdGlscy5jYWxjdWxhdGVCb3VuZHMocG9pbnQsIHJhZGl1cyAhPT0gbnVsbCAmJiByYWRpdXMgIT09IHZvaWQgMCA/IHJhZGl1cyA6IDApLCBzaXplLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICBzdGF0aWMgYXJlQm91bmRzSW5zaWRlKGJvdW5kcywgc2l6ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGxldCBpbnNpZGUgPSB0cnVlO1xuICAgICAgICBpZiAoIWRpcmVjdGlvbiB8fCBkaXJlY3Rpb24gPT09IE91dE1vZGVEaXJlY3Rpb25fMS5PdXRNb2RlRGlyZWN0aW9uLmJvdHRvbSkge1xuICAgICAgICAgICAgaW5zaWRlID0gYm91bmRzLnRvcCA8IHNpemUuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnNpZGUgJiYgKCFkaXJlY3Rpb24gfHwgZGlyZWN0aW9uID09PSBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi5sZWZ0KSkge1xuICAgICAgICAgICAgaW5zaWRlID0gYm91bmRzLnJpZ2h0ID4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zaWRlICYmICghZGlyZWN0aW9uIHx8IGRpcmVjdGlvbiA9PT0gT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24ucmlnaHQpKSB7XG4gICAgICAgICAgICBpbnNpZGUgPSBib3VuZHMubGVmdCA8IHNpemUud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc2lkZSAmJiAoIWRpcmVjdGlvbiB8fCBkaXJlY3Rpb24gPT09IE91dE1vZGVEaXJlY3Rpb25fMS5PdXRNb2RlRGlyZWN0aW9uLnRvcCkpIHtcbiAgICAgICAgICAgIGluc2lkZSA9IGJvdW5kcy5ib3R0b20gPiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfVxuICAgIHN0YXRpYyBjYWxjdWxhdGVCb3VuZHMocG9pbnQsIHJhZGl1cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYm90dG9tOiBwb2ludC55ICsgcmFkaXVzLFxuICAgICAgICAgICAgbGVmdDogcG9pbnQueCAtIHJhZGl1cyxcbiAgICAgICAgICAgIHJpZ2h0OiBwb2ludC54ICsgcmFkaXVzLFxuICAgICAgICAgICAgdG9wOiBwb2ludC55IC0gcmFkaXVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgbG9hZEltYWdlKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJFcnJvciB0c1BhcnRpY2xlcyAtIE5vIGltYWdlLnNyY1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBzb3VyY2Uuc3Vic3RyKHNvdXJjZS5sZW5ndGggLSAzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaW1hZ2UuZWxlbWVudCA9IGltZztcbiAgICAgICAgICAgICAgICByZXNvbHZlKGltYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGBFcnJvciB0c1BhcnRpY2xlcyAtIGxvYWRpbmcgaW1hZ2U6ICR7c291cmNlfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbWcuc3JjID0gc291cmNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGRvd25sb2FkU3ZnSW1hZ2Uoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHRzUGFydGljbGVzIC0gTm8gaW1hZ2Uuc3JjXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgdHlwZTogc291cmNlLnN1YnN0cihzb3VyY2UubGVuZ3RoIC0gMyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGltYWdlLnR5cGUgIT09IFwic3ZnXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMubG9hZEltYWdlKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKGltYWdlLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdHNQYXJ0aWNsZXMgLSBJbWFnZSBub3QgZm91bmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWFnZS5zdmdEYXRhID0geWllbGQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGRlZXBFeHRlbmQoZGVzdGluYXRpb24sIC4uLnNvdXJjZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IHNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbiA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoc291cmNlSXNBcnJheSAmJiAodHlwZW9mIGRlc3RpbmF0aW9uICE9PSBcIm9iamVjdFwiIHx8ICFkZXN0aW5hdGlvbiB8fCAhQXJyYXkuaXNBcnJheShkZXN0aW5hdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFzb3VyY2VJc0FycmF5ICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBkZXN0aW5hdGlvbiAhPT0gXCJvYmplY3RcIiB8fCAhZGVzdGluYXRpb24gfHwgQXJyYXkuaXNBcnJheShkZXN0aW5hdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZURpY3QgPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzb3VyY2VEaWN0W2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgaXNPYmplY3QgPSB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzdERpY3QgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgICBkZXN0RGljdFtrZXldID1cbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWUubWFwKCh2KSA9PiBVdGlscy5kZWVwRXh0ZW5kKGRlc3REaWN0W2tleV0sIHYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBVdGlscy5kZWVwRXh0ZW5kKGRlc3REaWN0W2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuICAgIHN0YXRpYyBpc0Rpdk1vZGVFbmFibGVkKG1vZGUsIGRpdnMpIHtcbiAgICAgICAgcmV0dXJuIGRpdnMgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgPyAhIWRpdnMuZmluZCgodCkgPT4gdC5lbmFibGUgJiYgVXRpbHMuaXNJbkFycmF5KG1vZGUsIHQubW9kZSkpXG4gICAgICAgICAgICA6IFV0aWxzLmlzSW5BcnJheShtb2RlLCBkaXZzLm1vZGUpO1xuICAgIH1cbiAgICBzdGF0aWMgZGl2TW9kZUV4ZWN1dGUobW9kZSwgZGl2cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGRpdnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkaXYgb2YgZGl2cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpdk1vZGUgPSBkaXYubW9kZTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXZFbmFibGVkID0gZGl2LmVuYWJsZTtcbiAgICAgICAgICAgICAgICBpZiAoZGl2RW5hYmxlZCAmJiBVdGlscy5pc0luQXJyYXkobW9kZSwgZGl2TW9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMuc2luZ2xlRGl2TW9kZUV4ZWN1dGUoZGl2LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGl2TW9kZSA9IGRpdnMubW9kZTtcbiAgICAgICAgICAgIGNvbnN0IGRpdkVuYWJsZWQgPSBkaXZzLmVuYWJsZTtcbiAgICAgICAgICAgIGlmIChkaXZFbmFibGVkICYmIFV0aWxzLmlzSW5BcnJheShtb2RlLCBkaXZNb2RlKSkge1xuICAgICAgICAgICAgICAgIFV0aWxzLnNpbmdsZURpdk1vZGVFeGVjdXRlKGRpdnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgc2luZ2xlRGl2TW9kZUV4ZWN1dGUoZGl2LCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBzZWxlY3RvcnMgPSBkaXYuc2VsZWN0b3JzO1xuICAgICAgICBpZiAoc2VsZWN0b3JzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2VsZWN0b3Igb2Ygc2VsZWN0b3JzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc2VsZWN0b3IsIGRpdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhzZWxlY3RvcnMsIGRpdik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGRpdk1vZGUoZGl2cywgZWxlbWVudCkge1xuICAgICAgICBpZiAoIWVsZW1lbnQgfHwgIWRpdnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGl2cyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gZGl2cy5maW5kKChkKSA9PiBjaGVja1NlbGVjdG9yKGVsZW1lbnQsIGQuc2VsZWN0b3JzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hlY2tTZWxlY3RvcihlbGVtZW50LCBkaXZzLnNlbGVjdG9ycykpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXZzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjaXJjbGVCb3VuY2VEYXRhRnJvbVBhcnRpY2xlKHApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwLmdldFBvc2l0aW9uKCksXG4gICAgICAgICAgICByYWRpdXM6IHAuZ2V0UmFkaXVzKCksXG4gICAgICAgICAgICB2ZWxvY2l0eTogcC52ZWxvY2l0eSxcbiAgICAgICAgICAgIGZhY3Rvcjoge1xuICAgICAgICAgICAgICAgIGhvcml6b250YWw6IE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0VmFsdWUocC5wYXJ0aWNsZXNPcHRpb25zLmJvdW5jZS5ob3Jpem9udGFsKSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRWYWx1ZShwLnBhcnRpY2xlc09wdGlvbnMuYm91bmNlLnZlcnRpY2FsKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBjaXJjbGVCb3VuY2UocDEsIHAyKSB7XG4gICAgICAgIGNvbnN0IHhWZWxvY2l0eURpZmYgPSBwMS52ZWxvY2l0eS5ob3Jpem9udGFsO1xuICAgICAgICBjb25zdCB5VmVsb2NpdHlEaWZmID0gcDEudmVsb2NpdHkudmVydGljYWw7XG4gICAgICAgIGNvbnN0IHBvczEgPSBwMS5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgcG9zMiA9IHAyLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCB4RGlzdCA9IHBvczIueCAtIHBvczEueDtcbiAgICAgICAgY29uc3QgeURpc3QgPSBwb3MyLnkgLSBwb3MxLnk7XG4gICAgICAgIGlmICh4VmVsb2NpdHlEaWZmICogeERpc3QgKyB5VmVsb2NpdHlEaWZmICogeURpc3QgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSAtTWF0aC5hdGFuMihwb3MyLnkgLSBwb3MxLnksIHBvczIueCAtIHBvczEueCk7XG4gICAgICAgICAgICBjb25zdCBtMSA9IHAxLnJhZGl1cztcbiAgICAgICAgICAgIGNvbnN0IG0yID0gcDIucmFkaXVzO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBOdW1iZXJVdGlsc18xLk51bWJlclV0aWxzLnJvdGF0ZVZlbG9jaXR5KHAxLnZlbG9jaXR5LCBhbmdsZSk7XG4gICAgICAgICAgICBjb25zdCB1MiA9IE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMucm90YXRlVmVsb2NpdHkocDIudmVsb2NpdHksIGFuZ2xlKTtcbiAgICAgICAgICAgIGNvbnN0IHYxID0gTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5jb2xsaXNpb25WZWxvY2l0eSh1MSwgdTIsIG0xLCBtMik7XG4gICAgICAgICAgICBjb25zdCB2MiA9IE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMuY29sbGlzaW9uVmVsb2NpdHkodTIsIHUxLCBtMSwgbTIpO1xuICAgICAgICAgICAgY29uc3QgdkZpbmFsMSA9IE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMucm90YXRlVmVsb2NpdHkodjEsIC1hbmdsZSk7XG4gICAgICAgICAgICBjb25zdCB2RmluYWwyID0gTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5yb3RhdGVWZWxvY2l0eSh2MiwgLWFuZ2xlKTtcbiAgICAgICAgICAgIHAxLnZlbG9jaXR5Lmhvcml6b250YWwgPSB2RmluYWwxLmhvcml6b250YWwgKiBwMS5mYWN0b3IuaG9yaXpvbnRhbDtcbiAgICAgICAgICAgIHAxLnZlbG9jaXR5LnZlcnRpY2FsID0gdkZpbmFsMS52ZXJ0aWNhbCAqIHAxLmZhY3Rvci52ZXJ0aWNhbDtcbiAgICAgICAgICAgIHAyLnZlbG9jaXR5Lmhvcml6b250YWwgPSB2RmluYWwyLmhvcml6b250YWwgKiBwMi5mYWN0b3IuaG9yaXpvbnRhbDtcbiAgICAgICAgICAgIHAyLnZlbG9jaXR5LnZlcnRpY2FsID0gdkZpbmFsMi52ZXJ0aWNhbCAqIHAyLmZhY3Rvci52ZXJ0aWNhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcmVjdEJvdW5jZShwYXJ0aWNsZSwgZGl2Qm91bmRzKSB7XG4gICAgICAgIGNvbnN0IHBQb3MgPSBwYXJ0aWNsZS5nZXRQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBzaXplID0gcGFydGljbGUuZ2V0UmFkaXVzKCk7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IFV0aWxzLmNhbGN1bGF0ZUJvdW5kcyhwUG9zLCBzaXplKTtcbiAgICAgICAgY29uc3QgcmVzSCA9IHJlY3RTaWRlQm91bmNlKHtcbiAgICAgICAgICAgIG1pbjogYm91bmRzLmxlZnQsXG4gICAgICAgICAgICBtYXg6IGJvdW5kcy5yaWdodCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWluOiBib3VuZHMudG9wLFxuICAgICAgICAgICAgbWF4OiBib3VuZHMuYm90dG9tLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtaW46IGRpdkJvdW5kcy5sZWZ0LFxuICAgICAgICAgICAgbWF4OiBkaXZCb3VuZHMucmlnaHQsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1pbjogZGl2Qm91bmRzLnRvcCxcbiAgICAgICAgICAgIG1heDogZGl2Qm91bmRzLmJvdHRvbSxcbiAgICAgICAgfSwgcGFydGljbGUudmVsb2NpdHkuaG9yaXpvbnRhbCwgTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRWYWx1ZShwYXJ0aWNsZS5wYXJ0aWNsZXNPcHRpb25zLmJvdW5jZS5ob3Jpem9udGFsKSk7XG4gICAgICAgIGlmIChyZXNILmJvdW5jZWQpIHtcbiAgICAgICAgICAgIGlmIChyZXNILnZlbG9jaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS5ob3Jpem9udGFsID0gcmVzSC52ZWxvY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNILnBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi54ID0gcmVzSC5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNWID0gcmVjdFNpZGVCb3VuY2Uoe1xuICAgICAgICAgICAgbWluOiBib3VuZHMudG9wLFxuICAgICAgICAgICAgbWF4OiBib3VuZHMuYm90dG9tLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtaW46IGJvdW5kcy5sZWZ0LFxuICAgICAgICAgICAgbWF4OiBib3VuZHMucmlnaHQsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1pbjogZGl2Qm91bmRzLnRvcCxcbiAgICAgICAgICAgIG1heDogZGl2Qm91bmRzLmJvdHRvbSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWluOiBkaXZCb3VuZHMubGVmdCxcbiAgICAgICAgICAgIG1heDogZGl2Qm91bmRzLnJpZ2h0LFxuICAgICAgICB9LCBwYXJ0aWNsZS52ZWxvY2l0eS52ZXJ0aWNhbCwgTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRWYWx1ZShwYXJ0aWNsZS5wYXJ0aWNsZXNPcHRpb25zLmJvdW5jZS52ZXJ0aWNhbCkpO1xuICAgICAgICBpZiAocmVzVi5ib3VuY2VkKSB7XG4gICAgICAgICAgICBpZiAocmVzVi52ZWxvY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUudmVsb2NpdHkudmVydGljYWwgPSByZXNWLnZlbG9jaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc1YucG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnkgPSByZXNWLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5VdGlscyA9IFV0aWxzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9DYW52YXNVdGlsc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ2lyY2xlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9DaXJjbGVXYXJwXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db2xvclV0aWxzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db25zdGFudHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0V2ZW50TGlzdGVuZXJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9OdW1iZXJVdGlsc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUGx1Z2luc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUG9pbnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1F1YWRUcmVlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9SYW5nZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9VdGlsc1wiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50c1BhcnRpY2xlcyA9IGV4cG9ydHMucEpTRG9tID0gZXhwb3J0cy5wYXJ0aWNsZXNKUyA9IGV4cG9ydHMuVXRpbHMgPSBleHBvcnRzLkNvbnN0YW50cyA9IGV4cG9ydHMuQ29sb3JVdGlscyA9IGV4cG9ydHMuQ2FudmFzVXRpbHMgPSB2b2lkIDA7XG5jb25zdCBwanNfMSA9IHJlcXVpcmUoXCIuL3Bqc1wiKTtcbmNvbnN0IG1haW5fMSA9IHJlcXVpcmUoXCIuL21haW5cIik7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4vVXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW52YXNVdGlsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVXRpbHNfMS5DYW52YXNVdGlsczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbG9yVXRpbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFV0aWxzXzEuQ29sb3JVdGlsczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnN0YW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVXRpbHNfMS5Db25zdGFudHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVdGlsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVXRpbHNfMS5VdGlsczsgfSB9KTtcbmNvbnN0IHRzUGFydGljbGVzID0gbmV3IG1haW5fMS5NYWluKCk7XG5leHBvcnRzLnRzUGFydGljbGVzID0gdHNQYXJ0aWNsZXM7XG50c1BhcnRpY2xlcy5pbml0KCk7XG5jb25zdCB7IHBhcnRpY2xlc0pTLCBwSlNEb20gfSA9IHBqc18xLmluaXRQanModHNQYXJ0aWNsZXMpO1xuZXhwb3J0cy5wYXJ0aWNsZXNKUyA9IHBhcnRpY2xlc0pTO1xuZXhwb3J0cy5wSlNEb20gPSBwSlNEb207XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29yZS9Db250YWluZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0VudW1zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9QbHVnaW5zL0Fic29yYmVycy9FbnVtc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUGx1Z2lucy9FbWl0dGVycy9FbnVtc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUGx1Z2lucy9Qb2x5Z29uTWFzay9FbnVtc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVHlwZXNcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBtYWluX3NsaW1fMSA9IHJlcXVpcmUoXCIuL21haW4uc2xpbVwiKTtcbmNvbnN0IEFic29yYmVyc1BsdWdpbl8xID0gcmVxdWlyZShcIi4vUGx1Z2lucy9BYnNvcmJlcnMvQWJzb3JiZXJzUGx1Z2luXCIpO1xuY29uc3QgRW1pdHRlcnNQbHVnaW5fMSA9IHJlcXVpcmUoXCIuL1BsdWdpbnMvRW1pdHRlcnMvRW1pdHRlcnNQbHVnaW5cIik7XG5jb25zdCBQb2x5Z29uTWFza1BsdWdpbl8xID0gcmVxdWlyZShcIi4vUGx1Z2lucy9Qb2x5Z29uTWFzay9Qb2x5Z29uTWFza1BsdWdpblwiKTtcbmNsYXNzIE1haW4gZXh0ZW5kcyBtYWluX3NsaW1fMS5NYWluU2xpbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYWRkUGx1Z2luKEFic29yYmVyc1BsdWdpbl8xLkFic29yYmVyc1BsdWdpbik7XG4gICAgICAgIHRoaXMuYWRkUGx1Z2luKEVtaXR0ZXJzUGx1Z2luXzEuRW1pdHRlcnNQbHVnaW4pO1xuICAgICAgICB0aGlzLmFkZFBsdWdpbihQb2x5Z29uTWFza1BsdWdpbl8xLlBvbHlnb25NYXNrUGx1Z2luKTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWFpblNsaW0gPSB2b2lkIDA7XG5jb25zdCBTcXVhcmVEcmF3ZXJfMSA9IHJlcXVpcmUoXCIuL1NoYXBlRHJhd2Vycy9TcXVhcmVEcmF3ZXJcIik7XG5jb25zdCBUZXh0RHJhd2VyXzEgPSByZXF1aXJlKFwiLi9TaGFwZURyYXdlcnMvVGV4dERyYXdlclwiKTtcbmNvbnN0IEltYWdlRHJhd2VyXzEgPSByZXF1aXJlKFwiLi9TaGFwZURyYXdlcnMvSW1hZ2VEcmF3ZXJcIik7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4vVXRpbHNcIik7XG5jb25zdCBUeXBlc18xID0gcmVxdWlyZShcIi4vRW51bXMvVHlwZXNcIik7XG5jb25zdCBMaW5lRHJhd2VyXzEgPSByZXF1aXJlKFwiLi9TaGFwZURyYXdlcnMvTGluZURyYXdlclwiKTtcbmNvbnN0IENpcmNsZURyYXdlcl8xID0gcmVxdWlyZShcIi4vU2hhcGVEcmF3ZXJzL0NpcmNsZURyYXdlclwiKTtcbmNvbnN0IFRyaWFuZ2xlRHJhd2VyXzEgPSByZXF1aXJlKFwiLi9TaGFwZURyYXdlcnMvVHJpYW5nbGVEcmF3ZXJcIik7XG5jb25zdCBTdGFyRHJhd2VyXzEgPSByZXF1aXJlKFwiLi9TaGFwZURyYXdlcnMvU3RhckRyYXdlclwiKTtcbmNvbnN0IFBvbHlnb25EcmF3ZXJfMSA9IHJlcXVpcmUoXCIuL1NoYXBlRHJhd2Vycy9Qb2x5Z29uRHJhd2VyXCIpO1xuY29uc3QgTG9hZGVyXzEgPSByZXF1aXJlKFwiLi9Db3JlL0xvYWRlclwiKTtcbmNsYXNzIE1haW5TbGltIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzcXVhcmVEcmF3ZXIgPSBuZXcgU3F1YXJlRHJhd2VyXzEuU3F1YXJlRHJhd2VyKCk7XG4gICAgICAgIGNvbnN0IHRleHREcmF3ZXIgPSBuZXcgVGV4dERyYXdlcl8xLlRleHREcmF3ZXIoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VEcmF3ZXIgPSBuZXcgSW1hZ2VEcmF3ZXJfMS5JbWFnZURyYXdlcigpO1xuICAgICAgICBVdGlsc18xLlBsdWdpbnMuYWRkU2hhcGVEcmF3ZXIoVHlwZXNfMS5TaGFwZVR5cGUubGluZSwgbmV3IExpbmVEcmF3ZXJfMS5MaW5lRHJhd2VyKCkpO1xuICAgICAgICBVdGlsc18xLlBsdWdpbnMuYWRkU2hhcGVEcmF3ZXIoVHlwZXNfMS5TaGFwZVR5cGUuY2lyY2xlLCBuZXcgQ2lyY2xlRHJhd2VyXzEuQ2lyY2xlRHJhd2VyKCkpO1xuICAgICAgICBVdGlsc18xLlBsdWdpbnMuYWRkU2hhcGVEcmF3ZXIoVHlwZXNfMS5TaGFwZVR5cGUuZWRnZSwgc3F1YXJlRHJhd2VyKTtcbiAgICAgICAgVXRpbHNfMS5QbHVnaW5zLmFkZFNoYXBlRHJhd2VyKFR5cGVzXzEuU2hhcGVUeXBlLnNxdWFyZSwgc3F1YXJlRHJhd2VyKTtcbiAgICAgICAgVXRpbHNfMS5QbHVnaW5zLmFkZFNoYXBlRHJhd2VyKFR5cGVzXzEuU2hhcGVUeXBlLnRyaWFuZ2xlLCBuZXcgVHJpYW5nbGVEcmF3ZXJfMS5UcmlhbmdsZURyYXdlcigpKTtcbiAgICAgICAgVXRpbHNfMS5QbHVnaW5zLmFkZFNoYXBlRHJhd2VyKFR5cGVzXzEuU2hhcGVUeXBlLnN0YXIsIG5ldyBTdGFyRHJhd2VyXzEuU3RhckRyYXdlcigpKTtcbiAgICAgICAgVXRpbHNfMS5QbHVnaW5zLmFkZFNoYXBlRHJhd2VyKFR5cGVzXzEuU2hhcGVUeXBlLnBvbHlnb24sIG5ldyBQb2x5Z29uRHJhd2VyXzEuUG9seWdvbkRyYXdlcigpKTtcbiAgICAgICAgVXRpbHNfMS5QbHVnaW5zLmFkZFNoYXBlRHJhd2VyKFR5cGVzXzEuU2hhcGVUeXBlLmNoYXIsIHRleHREcmF3ZXIpO1xuICAgICAgICBVdGlsc18xLlBsdWdpbnMuYWRkU2hhcGVEcmF3ZXIoVHlwZXNfMS5TaGFwZVR5cGUuY2hhcmFjdGVyLCB0ZXh0RHJhd2VyKTtcbiAgICAgICAgVXRpbHNfMS5QbHVnaW5zLmFkZFNoYXBlRHJhd2VyKFR5cGVzXzEuU2hhcGVUeXBlLmltYWdlLCBpbWFnZURyYXdlcik7XG4gICAgICAgIFV0aWxzXzEuUGx1Z2lucy5hZGRTaGFwZURyYXdlcihUeXBlc18xLlNoYXBlVHlwZS5pbWFnZXMsIGltYWdlRHJhd2VyKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2FkRnJvbUFycmF5KHRhZ0lkLCBvcHRpb25zLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIExvYWRlcl8xLkxvYWRlci5sb2FkKHRhZ0lkLCBvcHRpb25zLCBpbmRleCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkKHRhZ0lkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9hZGVyXzEuTG9hZGVyLmxvYWQodGFnSWQsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0KGlkLCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9hZGVyXzEuTG9hZGVyLnNldChpZCwgZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkSlNPTih0YWdJZCwgcGF0aENvbmZpZ0pzb24sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBMb2FkZXJfMS5Mb2FkZXIubG9hZEpTT04odGFnSWQsIHBhdGhDb25maWdKc29uLCBpbmRleCk7XG4gICAgfVxuICAgIHNldE9uQ2xpY2tIYW5kbGVyKGNhbGxiYWNrKSB7XG4gICAgICAgIExvYWRlcl8xLkxvYWRlci5zZXRPbkNsaWNrSGFuZGxlcihjYWxsYmFjayk7XG4gICAgfVxuICAgIGRvbSgpIHtcbiAgICAgICAgcmV0dXJuIExvYWRlcl8xLkxvYWRlci5kb20oKTtcbiAgICB9XG4gICAgZG9tSXRlbShpbmRleCkge1xuICAgICAgICByZXR1cm4gTG9hZGVyXzEuTG9hZGVyLmRvbUl0ZW0oaW5kZXgpO1xuICAgIH1cbiAgICBhZGRTaGFwZShzaGFwZSwgZHJhd2VyLCBpbml0LCBhZnRlckVmZmVjdCwgZGVzdHJveSkge1xuICAgICAgICBsZXQgY3VzdG9tRHJhd2VyO1xuICAgICAgICBpZiAodHlwZW9mIGRyYXdlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjdXN0b21EcmF3ZXIgPSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXJFZmZlY3Q6IGFmdGVyRWZmZWN0LFxuICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICAgICAgICAgICAgZHJhdzogZHJhd2VyLFxuICAgICAgICAgICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VzdG9tRHJhd2VyID0gZHJhd2VyO1xuICAgICAgICB9XG4gICAgICAgIFV0aWxzXzEuUGx1Z2lucy5hZGRTaGFwZURyYXdlcihzaGFwZSwgY3VzdG9tRHJhd2VyKTtcbiAgICB9XG4gICAgYWRkUHJlc2V0KHByZXNldCwgb3B0aW9ucykge1xuICAgICAgICBVdGlsc18xLlBsdWdpbnMuYWRkUHJlc2V0KHByZXNldCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFkZFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgVXRpbHNfMS5QbHVnaW5zLmFkZFBsdWdpbihwbHVnaW4pO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFpblNsaW0gPSBNYWluU2xpbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbml0UGpzID0gdm9pZCAwO1xuY29uc3QgaW5pdFBqcyA9IChtYWluKSA9PiB7XG4gICAgY29uc3QgcGFydGljbGVzSlMgPSAodGFnSWQsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgcmV0dXJuIG1haW4ubG9hZCh0YWdJZCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBwYXJ0aWNsZXNKUy5sb2FkID0gKHRhZ0lkLCBwYXRoQ29uZmlnSnNvbiwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgbWFpbi5sb2FkSlNPTih0YWdJZCwgcGF0aENvbmZpZ0pzb24pLnRoZW4oKGNvbnRhaW5lcikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcGFydGljbGVzSlMuc2V0T25DbGlja0hhbmRsZXIgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgbWFpbi5zZXRPbkNsaWNrSGFuZGxlcihjYWxsYmFjayk7XG4gICAgfTtcbiAgICBjb25zdCBwSlNEb20gPSBtYWluLmRvbSgpO1xuICAgIHJldHVybiB7IHBhcnRpY2xlc0pTLCBwSlNEb20gfTtcbn07XG5leHBvcnRzLmluaXRQanMgPSBpbml0UGpzO1xuIiwiaW1wb3J0ICdyZWFjdC1ub3RpZmljYXRpb25zLWNvbXBvbmVudC9kaXN0L3RoZW1lLmNzcydcclxuaW1wb3J0IFJlYWN0Tm90aWZpY2F0aW9uIGZyb20gJ3JlYWN0LW5vdGlmaWNhdGlvbnMtY29tcG9uZW50J1xyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCBOYXZiYXIgZnJvbSAnLi4vc3ViY29tcG9uZW50cy9OYXZiYXIvTmF2YmFyJ1xyXG5pbXBvcnQgTWFpbiBmcm9tICcuLi9zdWJjb21wb25lbnRzL01haW4vTWFpbidcclxuaW1wb3J0IHsgRW52aXJvbm1lbnRTZXJ2aWNlIH0gZnJvbSAnc3JjL3NlcnZpY2VzL0Vudmlyb25tZW50LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCbG9ja2NoYWluU2VydmljZSB9IGZyb20gJ3NyYy9zZXJ2aWNlcy9CbG9ja2NoYWluLnNlcnZpY2UnO1xyXG5pbXBvcnQgRW1pdHRlciwgeyBFVkVOVF9CTE9DS0NIQUlOX0RBVEFfQ0hBTkdFRCB9IGZyb20gJ3NyYy9zZXJ2aWNlcy9FdmVudC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQXBwUHJvcHMgfSBmcm9tICduZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXInO1xyXG5pbXBvcnQgJy4uL3N0eWxlcy9pbmRleC5jc3MnO1xyXG5pbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnXHJcbmltcG9ydCB7IEJnUGFydGljbGVzIH0gZnJvbSAnc3JjL3N1YmNvbXBvbmVudHMvQmdQYXJ0aWNsZXMvQmdQYXJ0aWNsZXMnXHJcblxyXG5pbnRlcmZhY2UgSUFwcFN0YXRlIHtcclxuICBpc0Nvbm5lY3RpbmdUb0Jsb2NrY2hhaW46IGJvb2xlYW47XHJcbiAgYWNjb3VudDogc3RyaW5nO1xyXG59XHJcblxyXG5jbGFzcyBBcHAgZXh0ZW5kcyBDb21wb25lbnQ8QXBwUHJvcHMsIElBcHBTdGF0ZT4ge1xyXG5cclxuICBhc3luYyBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IEJsb2NrY2hhaW5TZXJ2aWNlLmNvbm5lY3RUb0Jsb2NrY2hhaW4oKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIC8vIGFsc28gc3RvcCBsb2FkaW5nIGluIGNhc2UgYmxvY2tjaGFpbiBuZXR3b3JrIGlzIGRvd24gKGUuZy4gbG9jYWwgZ2FuYWNoZSlcclxuICAgICAgdGhpcy5zZXRTdGF0ZSh7Li4udGhpcy5zdGF0ZSwgaXNDb25uZWN0aW5nVG9CbG9ja2NoYWluOiBmYWxzZX0pO1xyXG4gICAgfVxyXG5cclxuICAgIEVtaXR0ZXIub24oRVZFTlRfQkxPQ0tDSEFJTl9EQVRBX0NIQU5HRUQsIGFzeW5jICgpID0+IHtcclxuICAgICAgdGhpcy5zZXRTdGF0ZSh7Li4udGhpcy5zdGF0ZSwgYWNjb3VudDogYXdhaXQgQmxvY2tjaGFpblNlcnZpY2UuZ2V0Q3VycmVudEFjY291bnQoKSB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKVxyXG5cclxuICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgIGFjY291bnQ6ICcweDAnLFxyXG4gICAgICBpc0Nvbm5lY3RpbmdUb0Jsb2NrY2hhaW46IHRydWVcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJlbmRlcigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDw+XHJcbiAgICAgIDxIZWFkPlxyXG4gICAgICAgIDx0aXRsZT5XYXZlY3TCriBUb2tlbiAtIFBheSBpbiBDcnlwdG8gJiBTYXZlIE1vbmV5PC90aXRsZT5cclxuICAgICAgICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnRpdGxlXCIgY29udGVudD1cIldhdmVjdMKuIFRva2VuIC0gUGF5IGluIENyeXB0byAmIFNhdmUgTW9uZXlcIiBrZXk9XCJ0aXRsZVwiIC8+XHJcbiAgICAgICAgPHNjcmlwdCBzcmM9XCJodHRwczovL2Nkbi5yYXdnaXQuY29tL3Byb2dlcnMvcGF0aHNlZy9tYXN0ZXIvcGF0aHNlZy5qc1wiPjwvc2NyaXB0PlxyXG4gICAgICA8L0hlYWQ+XHJcbiAgICAgIDxkaXY+XHJcbiAgICAgICAgPFJlYWN0Tm90aWZpY2F0aW9uIC8+XHJcbiAgICAgICAgPEJnUGFydGljbGVzIC8+XHJcbiAgICAgICAgPE5hdmJhciBhY2NvdW50PXt0aGlzLnN0YXRlLmFjY291bnR9IC8+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXItZmx1aWQgbXQtNVwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cclxuICAgICAgICAgICAgPG1haW4gcm9sZT1cIm1haW5cIiBjbGFzc05hbWU9XCJjb2wtbGctMTIgbWwtYXV0byBtci1hdXRvXCIgc3R5bGU9e3sgbWF4V2lkdGg6ICc4NSUnIH19PlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGVudCBtci1hdXRvIG1sLWF1dG9cIj5cclxuXHJcbiAgICAgICAgICAgICAgPE1haW5cclxuICAgICAgICAgICAgICAgIHNob3dNYWludGVuYW5jZU1vZGU9e0Vudmlyb25tZW50U2VydmljZS5pc1Byb2R1Y3Rpb25FbnYoKX1cclxuICAgICAgICAgICAgICAgIGlzQ29ubmVjdGluZ1RvQmxvY2tjaGFpbj17dGhpcy5zdGF0ZS5pc0Nvbm5lY3RpbmdUb0Jsb2NrY2hhaW59XHJcbiAgICAgICAgICAgICAgLz5cclxuXHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvbWFpbj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC8+XHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQXBwO1xyXG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0yIS4vQmdQYXJ0aWNsZXMubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiKSB7XG4gIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcDtcblxuICBmb3IgKHAgaW4gYSkge1xuICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yIChwIGluIGIpIHtcbiAgICBpZiAoIWFbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi0yLTIhLi9CZ1BhcnRpY2xlcy5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMiEuL0JnUGFydGljbGVzLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IFBhcnRpY2xlcyBmcm9tIFwicmVhY3QtcGFydGljbGVzLWpzXCJcclxuaW1wb3J0IHsgQXNzZXRTZXJ2aWNlIH0gZnJvbSBcInNyYy9zZXJ2aWNlcy9Bc3NldC5zZXJ2aWNlXCJcclxuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0JnUGFydGljbGVzLm1vZHVsZS5jc3MnO1xyXG5cclxuZXhwb3J0IGNvbnN0IEJnUGFydGljbGVzID0gKHByb3BzOiBhbnkpID0+IHtcclxuICAgIHJldHVybiA8UGFydGljbGVzIGNhbnZhc0NsYXNzTmFtZT17c3R5bGVzLnBhcnRpY2xlc0JnfSBwYXJhbXM9e3tcclxuICAgICAgICBcInBhcnRpY2xlc1wiOiB7XHJcblx0ICAgICAgICBcIm51bWJlclwiOiB7XHJcblx0ICAgICAgICAgICAgXCJ2YWx1ZVwiOiA2MFxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIFwic2l6ZVwiOiB7XHJcblx0ICAgICAgICAgICAgXCJ2YWx1ZVwiOiAyXHJcbiAgICAgICAgICAgIH0sXHJcblx0ICAgIH0sXHJcblx0ICAgIFwiaW50ZXJhY3Rpdml0eVwiOiB7XHJcblx0ICAgICAgICBcImV2ZW50c1wiOiB7XHJcblx0ICAgICAgICAgICAgXCJvbmhvdmVyXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgXCJlbmFibGVcIjogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgXCJtb2RlXCI6IFwicmVwdWxzZVwiXHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG4gICAgICAgIH0sICAgICBcclxuICAgICAgICBcInJldGluYV9kZXRlY3RcIjogdHJ1ZSBcclxuICAgIH19IC8+XHJcbn1cclxuXHJcbi8qXHJcbiAgcG9seWdvbjoge1xyXG4gICAgICAgICAgICBlbmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHR5cGU6ICdpbnNpZGUnLFxyXG4gICAgICAgICAgICBtb3ZlOiB7XHJcbiAgICAgICAgICAgICAgICByYWRpdXM6IDEwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVybDogQXNzZXRTZXJ2aWNlLmdldFBhdGgoJ0xvZ29fV0FWRUNUX2NvbG9yX3N5bS5zdmcnKSxcclxuICAgICAgICB9XHJcbiovIl0sInNvdXJjZVJvb3QiOiIifQ==